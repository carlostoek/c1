diff --git a/.env.example b/.env.example
index 8cf5f65..6ba3bc5 100644
--- a/.env.example
+++ b/.env.example
@@ -12,3 +12,7 @@ FREE_CHANNEL_ID=
 # Bot Settings
 DEFAULT_WAIT_TIME_MINUTES=5
 LOG_LEVEL=INFO
+
+# Background Tasks
+CLEANUP_INTERVAL_MINUTES=60
+PROCESS_FREE_QUEUE_MINUTES=5
diff --git a/CHANGELOG.md b/CHANGELOG.md
index 5ceda4f..fde542e 100644
--- a/CHANGELOG.md
+++ b/CHANGELOG.md
@@ -12,6 +12,11 @@ y este proyecto sigue [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
 - T7: Subscription Service - Gesti√≥n completa de suscripciones VIP (tokens, validaci√≥n, canjes) y cola de acceso Free
 - T8: Channel Service - Gesti√≥n completa de canales VIP y Free con verificaci√≥n de permisos y env√≠o de publicaciones
 - T9: Config Service - Gesti√≥n de configuraci√≥n global del bot, tiempos de espera, reacciones y tarifas
+- T10: Middlewares - Implementaci√≥n de AdminAuthMiddleware y DatabaseMiddleware para autenticaci√≥n de administradores e inyecci√≥n autom√°tica de sesiones de base de datos
+- T11: FSM States - Implementaci√≥n de estados FSM para administradores y usuarios para flujos de configuraci√≥n y canje de tokens
+- T12: Admin Handler - Handler del comando /admin que muestra el men√∫ principal de administraci√≥n con navegaci√≥n, verificaci√≥n de estado de configuraci√≥n y teclado inline
+- T13: Handlers VIP y Free - Submen√∫ VIP (gesti√≥n del canal VIP con generaci√≥n de tokens de invitaci√≥n), Configuraci√≥n del canal VIP (configuraci√≥n del canal VIP por reenv√≠o de mensajes), Generaci√≥n de tokens de invitaci√≥n (creaci√≥n de tokens VIP con duraci√≥n configurable), Submen√∫ Free (gesti√≥n del canal Free con configuraci√≥n de tiempo de espera), Configuraci√≥n del canal Free (configuraci√≥n del canal Free por reenv√≠o de mensajes), Configuraci√≥n de tiempo de espera (configuraci√≥n de tiempo de espera para acceso Free)
+- T15: Background Tasks - Tareas programadas que expulsan VIPs expirados del canal, procesan la cola Free para enviar invite links a usuarios que completaron tiempo de espera, limpian datos antiguos y usan APScheduler con configuraci√≥n de intervalos mediante variables de entorno
 
 ## [1.0.0] - 2025-12-11
 
@@ -24,7 +29,7 @@ y este proyecto sigue [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
 - T7: Sistema de cola Free con wait_time configurable
 - T7: Invite links de un solo uso (member_limit=1)
 - T7: Gesti√≥n de tokens VIP: generaci√≥n, validaci√≥n, canje y extensi√≥n
-- T7: Gesti√≥n de suscriptores VIP: creaci√≥n, extensi√≥n y expiraci√≥n autom√°tica
+- T7: Gesti√≥n de suscriptores VIP: creaci√≥n, extenci√≥n y expiraci√≥n autom√°tica
 - T7: Gesti√≥n de solicitudes Free: creaci√≥n y procesamiento autom√°tico
 - T7: Limpieza autom√°tica de datos antiguos
 - T8: ChannelService con m√©todos para gesti√≥n de canales VIP y Free
@@ -40,11 +45,42 @@ y este proyecto sigue [Semantic Versioning](https://semver.org/spec/v2.0.0.html)
 - T9: Configuraci√≥n y gesti√≥n de tarifas de suscripci√≥n
 - T9: Validaci√≥n de configuraci√≥n completa y resumen de estado
 - T9: M√©todos para resetear configuraci√≥n a valores por defecto
+- T11: ChannelSetupStates - Estados para configurar canales VIP y Free con extracci√≥n de ID de canal desde reenv√≠o de mensajes
+- T11: WaitTimeSetupStates - Estados para configurar tiempo de espera del canal Free con validaci√≥n de entrada num√©rica
+- T11: BroadcastStates - Estados para env√≠o de publicaciones a canales con soporte para diferentes tipos de contenido
+- T11: TokenRedemptionStates - Estados para canje de tokens VIP con validaci√≥n de formato y vigencia
+- T11: FreeAccessStates - Estados para solicitud de acceso Free con manejo de solicitudes pendientes
+- T11: Implementaci√≥n de ejemplos de uso de estados FSM en handlers de administraci√≥n y usuarios
+- T11: Documentaci√≥n completa de estados FSM con ejemplos de implementaci√≥n y flujos de usuario
+- T12: Admin Handler - Handler del comando /admin que muestra el men√∫ principal de administraci√≥n con navegaci√≥n, verificaci√≥n de estado de configuraci√≥n y teclado inline
+- T12: Implementaci√≥n de navegaci√≥n del men√∫ principal con estado de configuraci√≥n
+- T12: Aplicaci√≥n de middlewares AdminAuthMiddleware y DatabaseMiddleware al router de admin
+- T12: Verificaci√≥n de estado de configuraci√≥n del bot en el men√∫ principal
+- T12: Callback handlers para navegaci√≥n entre men√∫s
+- T12: Teclado inline con opciones de administraci√≥n
+- T12: Documentaci√≥n completa del handler admin con ejemplos de uso
+- T13: Handlers VIP y Free - Submen√∫ VIP (gesti√≥n del canal VIP con generaci√≥n de tokens de invitaci√≥n), Configuraci√≥n del canal VIP (configuraci√≥n del canal VIP por reenv√≠o de mensajes), Generaci√≥n de tokens de invitaci√≥n (creaci√≥n de tokens VIP con duraci√≥n configurable), Submen√∫ Free (gesti√≥n del canal Free con configuraci√≥n de tiempo de espera), Configuraci√≥n del canal Free (configuraci√≥n del canal Free por reenv√≠o de mensajes), Configuraci√≥n de tiempo de espera (configuraci√≥n de tiempo de espera para acceso Free)
+- T13: Implementaci√≥n de submen√∫ VIP con opciones de generaci√≥n de tokens y reconfiguraci√≥n de canal
+- T13: Implementaci√≥n de submen√∫ Free con opciones de configuraci√≥n de tiempo de espera y reconfiguraci√≥n de canal
+- T13: Implementaci√≥n de flujo de configuraci√≥n de canales por reenv√≠o de mensajes con validaci√≥n de permisos
+- T13: Implementaci√≥n de generaci√≥n de tokens VIP con duraci√≥n configurable
+- T13: Implementaci√≥n de configuraci√≥n de tiempo de espera para acceso Free con validaci√≥n de entrada num√©rica
+- T13: Implementaci√≥n de teclados inline espec√≠ficos para los men√∫s VIP y Free
+- T13: Documentaci√≥n completa de los handlers VIP y Free con ejemplos de uso
+- T14: Handlers User (/start, flujos) - Handler /start con detecci√≥n de rol (admin/VIP/usuario), Flujo VIP (canje de tokens VIP con validaci√≥n y generaci√≥n de invite links), Flujo Free (solicitud de acceso Free con tiempo de espera y notificaciones autom√°ticas), Middleware de base de datos (inyecci√≥n de sesiones sin autenticaci√≥n de admin), FSM para validaci√≥n de tokens (estados para manejo de entrada de tokens), Validaci√≥n de configuraci√≥n (verificaci√≥n de canales configurados antes de procesar)
+- T14: Implementaci√≥n del handler /start con detecci√≥n de rol de usuario (admin, VIP, normal)
+- T14: Implementaci√≥n del flujo VIP para canje de tokens con validaci√≥n y generaci√≥n de invite links √∫nicos
+- T14: Implementaci√≥n del flujo Free para solicitud de acceso con tiempo de espera configurable
+- T14: Aplicaci√≥n de DatabaseMiddleware a handlers de usuario sin autenticaci√≥n de admin
+- T14: Uso de TokenRedemptionStates para manejo de entrada de tokens VIP
+- T14: Validaci√≥n de configuraci√≥n de canales antes de procesar solicitudes de usuarios
+- T14: Documentaci√≥n completa de los handlers User con ejemplos de uso
 
 ### Changed
 - Refactorizaci√≥n completa de la arquitectura de servicios para usar el contenedor
 - Optimizaci√≥n de consumo de memoria mediante lazy loading de servicios
 - Mejora en la estructura de gesti√≥n de suscripciones VIP y Free
+- Actualizaci√≥n de documentaci√≥n para incluir los nuevos handlers User
 
 ### Fixed
 - Problemas de consumo de memoria en entornos con recursos limitados como Termux
diff --git a/CLAUDE.md b/CLAUDE.md
index 1e62969..c6ed3a2 100644
--- a/CLAUDE.md
+++ b/CLAUDE.md
@@ -299,13 +299,145 @@ reset_to_defaults() ‚Üí None
 
 ---
 
-### FASE 1.3: HANDLERS ADMIN B√ÅSICOS (T10-T12) üîÑ SIGUIENTE
-Handlers para administraci√≥n del bot.
+### FASE 1.3: HANDLERS ADMIN B√ÅSICOS (T10-T12) üîÑ EN PROGRESO
 
-- **T10:** Middlewares (AdminAuth, Database Injection)
-- **T11:** Admin Main Menu Handler
-- **T12:** Admin VIP Management Handler
-- *T13-T17: M√°s handlers y features*
+#### T10: Middlewares (AdminAuth + Database) ‚úÖ COMPLETADO
+**Archivo:** `bot/middlewares/` (155 l√≠neas + tests)
+**Patr√≥n:** BaseMiddleware + DI
+**Responsabilidades:**
+- AdminAuthMiddleware: Validaci√≥n de permisos de administrador
+- DatabaseMiddleware: Inyecci√≥n de sesi√≥n de base de datos
+
+**Implementaci√≥n:**
+```
+bot/middlewares/
+‚îú‚îÄ‚îÄ admin_auth.py       ‚Üí AdminAuthMiddleware (87 l√≠neas)
+‚îú‚îÄ‚îÄ database.py         ‚Üí DatabaseMiddleware (68 l√≠neas)
+‚îî‚îÄ‚îÄ __init__.py         ‚Üí Exports
+```
+
+**AdminAuthMiddleware:**
+- Verifica `Config.is_admin(user.id)` para Message y CallbackQuery
+- Env√≠a mensaje de error si no es admin (HTML para Message, alert para CallbackQuery)
+- No ejecuta handler si no es admin (retorna None)
+- Logging: WARNING para intentos denegados, DEBUG para admins verificados
+
+**DatabaseMiddleware:**
+- Crea AsyncSession usando `get_session()` (context manager)
+- Inyecta sesi√≥n en `data["session"]` para que handlers accedan autom√°ticamente
+- Manejo autom√°tico de commit/rollback v√≠a SessionContextManager
+- Logging: ERROR si ocurre excepci√≥n en handler
+
+**Tests Validaci√≥n:** ‚úÖ 3 tests funcionales
+- Admin pass test ‚úÖ
+- Non-admin blocked test ‚úÖ
+- Session injection test ‚úÖ
+
+---
+
+#### T11: Estados FSM para Admin y User ‚úÖ COMPLETADO
+**Archivo:** `bot/states/` (107 l√≠neas + tests)
+**Patr√≥n:** StatesGroup + State + Docstrings explicando flujo
+**Responsabilidades:**
+- Definir estados FSM para flujos multi-paso
+- Agrupar l√≥gicamente estados relacionados
+- Documentar el flujo completo en docstrings
+
+**Implementaci√≥n:**
+```
+bot/states/
+‚îú‚îÄ‚îÄ admin.py         ‚Üí ChannelSetupStates, WaitTimeSetupStates, BroadcastStates
+‚îú‚îÄ‚îÄ user.py         ‚Üí TokenRedemptionStates, FreeAccessStates
+‚îî‚îÄ‚îÄ __init__.py     ‚Üí Exports
+```
+
+**Estados Admin:**
+- ChannelSetupStates: 2 estados
+  * waiting_for_vip_channel: Admin reenv√≠a mensaje del canal VIP
+  * waiting_for_free_channel: Admin reenv√≠a mensaje del canal Free
+
+- WaitTimeSetupStates: 1 estado
+  * waiting_for_minutes: Admin env√≠a n√∫mero de minutos
+
+- BroadcastStates: 2 estados
+  * waiting_for_content: Admin env√≠a contenido (texto, foto, video)
+  * waiting_for_confirmation: Admin confirma env√≠o (opcional)
+
+**Estados User:**
+- TokenRedemptionStates: 1 estado
+  * waiting_for_token: Usuario env√≠a token a canjear
+
+- FreeAccessStates: 1 estado
+  * waiting_for_approval: Usuario con solicitud pendiente
+
+**Tests Validaci√≥n:** ‚úÖ Todos pasaron
+- ‚úÖ Admin states (ChannelSetupStates, WaitTimeSetupStates, BroadcastStates)
+- ‚úÖ User states (TokenRedemptionStates, FreeAccessStates)
+- ‚úÖ Exports en __init__.py
+- ‚úÖ State strings correctos
+- Total: 5 StatesGroup, 7 States
+
+---
+
+#### T12: Handler /admin (Men√∫ Principal) ‚úÖ COMPLETADO
+**Archivo:** `bot/handlers/admin/main.py` (157 l√≠neas) + `bot/utils/keyboards.py` (95 l√≠neas)
+**Patr√≥n:** Router + Middlewares + Magic Filters + InlineKeyboards
+**Responsabilidades:**
+- Crear men√∫ principal de administraci√≥n
+- Navegar entre submen√∫s
+- Mostrar estado de configuraci√≥n
+
+**Implementaci√≥n:**
+```
+bot/handlers/admin/
+‚îú‚îÄ‚îÄ main.py              ‚Üí cmd_admin, callback_admin_main, callback_admin_config
+‚îî‚îÄ‚îÄ __init__.py          ‚Üí Export de admin_router
+
+bot/utils/
+‚îú‚îÄ‚îÄ keyboards.py         ‚Üí Factory functions para keyboards
+‚îî‚îÄ‚îÄ __init__.py          ‚Üí (ya existe)
+```
+
+**Keyboards Factory:**
+- `create_inline_keyboard()`: Funci√≥n base para crear keyboards
+- `admin_main_menu_keyboard()`: Men√∫ principal (3 opciones)
+- `back_to_main_menu_keyboard()`: Bot√≥n volver
+- `yes_no_keyboard()`: Confirmaci√≥n S√≠/No
+
+**Handlers Admin:**
+- `cmd_admin`: Handler /admin
+  * Verifica estado de configuraci√≥n
+  * Muestra advertencia si faltan elementos
+  * Env√≠a nuevo mensaje (no edita)
+
+- `callback_admin_main`: Volver al men√∫
+  * Callback "admin:main"
+  * Edita mensaje existente (eficiente)
+  * Maneja error "message is not modified"
+
+- `callback_admin_config`: Mostrar configuraci√≥n
+  * Callback "admin:config"
+  * Usa get_config_summary() del service
+  * Edita mensaje con resumen
+
+**Router Configuration:**
+- Nombre: "admin"
+- Middlewares en orden correcto:
+  * DatabaseMiddleware (inyecta session)
+  * AdminAuthMiddleware (valida permisos)
+- Aplicados a message y callback_query
+
+**Tests Validaci√≥n:** ‚úÖ Todos pasaron
+- ‚úÖ Keyboards: estructura y callbacks correctos
+- ‚úÖ Router: configurado con nombre "admin"
+- ‚úÖ Middlewares: registrados en orden
+- ‚úÖ Handlers: importables y compilables
+- ‚úÖ Manejo de errores de edici√≥n
+
+---
+
+- *T13: Handlers VIP y Free (Submen√∫s)*
+- *T14-T17: M√°s handlers y features*
 
 ---
 
@@ -345,6 +477,7 @@ Handlers para usuarios, testing completo, y deployment.
    - Mensaje describiendo cambios
    - Listas de m√©todos implementados
    - Caracter√≠sticas clave
+   - Sin referencias a herramientas externas como Claude code
 
 6. **Documentaci√≥n (Optional)**
    - Actualizar README.md si aplica
@@ -373,6 +506,35 @@ bot/services/
 ‚îî‚îÄ‚îÄ __init__.py       ‚Üí Exports de todos los services
 ```
 
+### Middlewares (T10)
+```
+bot/middlewares/
+‚îú‚îÄ‚îÄ admin_auth.py     ‚Üí AdminAuthMiddleware (validaci√≥n de admin)
+‚îú‚îÄ‚îÄ database.py       ‚Üí DatabaseMiddleware (inyecci√≥n de sesi√≥n)
+‚îî‚îÄ‚îÄ __init__.py       ‚Üí Exports de middlewares
+```
+
+### States (T11)
+```
+bot/states/
+‚îú‚îÄ‚îÄ admin.py          ‚Üí ChannelSetupStates, WaitTimeSetupStates, BroadcastStates
+‚îú‚îÄ‚îÄ user.py           ‚Üí TokenRedemptionStates, FreeAccessStates
+‚îî‚îÄ‚îÄ __init__.py       ‚Üí Exports de estados
+```
+
+### Handlers (T12-T13)
+```
+bot/handlers/admin/
+‚îú‚îÄ‚îÄ main.py           ‚Üí cmd_admin, callback_admin_main, callback_admin_config
+‚îú‚îÄ‚îÄ vip.py            ‚Üí VIP submen√∫, setup canal, generaci√≥n tokens
+‚îú‚îÄ‚îÄ free.py           ‚Üí Free submen√∫, setup canal, wait time config
+‚îî‚îÄ‚îÄ __init__.py       ‚Üí Exports de routers
+
+bot/utils/
+‚îú‚îÄ‚îÄ keyboards.py      ‚Üí Factory functions para inline keyboards
+‚îî‚îÄ‚îÄ __init__.py       ‚Üí Exports (si existe)
+```
+
 ---
 
 ## üéØ INTEGRACI√ìN CON SERVICIOS
@@ -419,4 +581,390 @@ async def handle_setup_vip(message: Message, state: FSMContext):
 - [x] Documentaci√≥n t√©cnica
 
 **Status:** ‚úÖ FASE 1.2 COMPLETADA
-**Pr√≥ximo:** T10 - Middlewares (AdminAuth, Database)
+
+## ‚úÖ CHECKLIST FASE 1.3
+
+- [x] T10: Middlewares (AdminAuth + Database)
+  - [x] AdminAuthMiddleware verifica Config.is_admin()
+  - [x] AdminAuthMiddleware env√≠a mensaje de error a no-admins
+  - [x] AdminAuthMiddleware NO ejecuta handler si no es admin
+  - [x] DatabaseMiddleware inyecta sesi√≥n en data["session"]
+  - [x] DatabaseMiddleware usa context manager correctamente
+  - [x] 3 tests funcionales validaci√≥n
+
+- [x] T11: Estados FSM para Admin y User
+  - [x] ChannelSetupStates (2 estados)
+  - [x] WaitTimeSetupStates (1 estado)
+  - [x] BroadcastStates (2 estados)
+  - [x] TokenRedemptionStates (1 estado)
+  - [x] FreeAccessStates (1 estado)
+  - [x] Exports en __init__.py
+  - [x] Tests validaci√≥n completos
+
+- [x] T12: Handler /admin (Men√∫ Principal)
+  - [x] Keyboard factory (create_inline_keyboard)
+  - [x] admin_main_menu_keyboard (3 opciones)
+  - [x] back_to_main_menu_keyboard
+  - [x] yes_no_keyboard
+  - [x] cmd_admin handler
+  - [x] callback_admin_main handler
+  - [x] callback_admin_config handler
+  - [x] Admin router configurado
+  - [x] Middlewares en orden correcto
+  - [x] Tests validaci√≥n completos
+
+- [x] T13: Handlers VIP y Free (Setup + Token Generation)
+  - [x] Submen√∫ VIP con estado de configuraci√≥n
+  - [x] FSM setup canal VIP (forward ‚Üí extrae ID ‚Üí configura)
+  - [x] Generaci√≥n de tokens VIP (24h)
+  - [x] Submen√∫ Free con estado de configuraci√≥n
+  - [x] FSM setup canal Free (forward ‚Üí extrae ID ‚Üí configura)
+  - [x] FSM configuraci√≥n tiempo de espera (validaci√≥n >= 1 minuto)
+  - [x] Keyboards din√°micos
+  - [x] Error handling y validaciones
+  - [x] Tests validaci√≥n completos
+
+#### T13: Handlers VIP y Free (Setup + Token Generation) ‚úÖ COMPLETADO
+**Archivo:** `bot/handlers/admin/vip.py` (232 l√≠neas) + `bot/handlers/admin/free.py` (297 l√≠neas)
+**Patr√≥n:** FSM + Callbacks + Message Handlers
+**Responsabilidades:**
+- Submen√∫s VIP y Free adaptables al estado de configuraci√≥n
+- Flujos FSM para setup de canales (forward ‚Üí extrae ID ‚Üí configura)
+- Generaci√≥n de tokens VIP
+- Configuraci√≥n de tiempo de espera Free
+
+**Implementaci√≥n VIP:**
+- `callback_vip_menu`: Muestra submen√∫ VIP
+- `callback_vip_setup`: Inicia FSM waiting_for_vip_channel
+- `process_vip_channel_forward`: Procesa forward, extrae ID, configura
+- `callback_generate_vip_token`: Genera token v√°lido 24h
+- `vip_menu_keyboard()`: Keyboard din√°mico
+
+**Implementaci√≥n Free:**
+- `callback_free_menu`: Muestra submen√∫ Free
+- `callback_free_setup`: Inicia FSM waiting_for_free_channel
+- `process_free_channel_forward`: Procesa forward, extrae ID, configura
+- `callback_set_wait_time`: Inicia FSM waiting_for_minutes
+- `process_wait_time_input`: Procesa minutos, valida (>= 1), actualiza
+- `free_menu_keyboard()`: Keyboard din√°mico
+
+**Flujos FSM:**
+```
+Setup Canal VIP/Free:
+  User: Click "Configurar"
+  Bot: Entra estado waiting_for_vip/free_channel
+  User: Reenv√≠a forward del canal
+  Bot: Extrae forward_from_chat.id ‚Üí Configura ‚Üí state.clear()
+
+Setup Wait Time (Free):
+  User: Click "Configurar Tiempo"
+  Bot: Entra estado waiting_for_minutes
+  User: Env√≠a n√∫mero (ej: 5)
+  Bot: Valida >= 1 ‚Üí Configura ‚Üí state.clear()
+```
+
+**Validaciones:**
+- ‚úÖ Forward validation (rechaza texto, requiere canal/supergrupo)
+- ‚úÖ Channel type check (channel o supergroup)
+- ‚úÖ Token generation (solo si canal VIP configurado)
+- ‚úÖ Wait time >= 1 minuto
+- ‚úÖ Error recovery (mantener FSM state en errores recuperables)
+
+**Tests Validaci√≥n:** ‚úÖ Todos pasaron
+- ‚úÖ Keyboards VIP y Free (ambos estados)
+- ‚úÖ Handlers importables
+- ‚úÖ admin_router compartido
+- ‚úÖ Callback data correctos
+- ‚úÖ FSM States disponibles
+
+---
+
+#### T14: Handlers User (/start, Canje Token, Solicitud Free) ‚úÖ COMPLETADO
+**Archivo:** `bot/handlers/user/start.py` (104 l√≠neas) + `bot/handlers/user/vip_flow.py` (173 l√≠neas) + `bot/handlers/user/free_flow.py` (107 l√≠neas)
+**Patr√≥n:** FSM + Callbacks + Message Handlers
+**Responsabilidades:**
+- Punto de entrada para usuarios (/start)
+- Detecci√≥n de rol (admin/VIP/usuario)
+- Flujo de canje de tokens VIP
+- Flujo de solicitud de acceso Free
+
+**Implementaci√≥n Start:**
+- `cmd_start`: Detecta rol y adapta mensaje
+  * Admin ‚Üí Redirige a /admin
+  * VIP activo ‚Üí Muestra d√≠as restantes
+  * Usuario normal ‚Üí Muestra opciones
+
+**Implementaci√≥n VIP Flow:**
+- `callback_redeem_token`: Inicia FSM
+- `process_token_input`: Procesa token, crea link (1h, 1 uso)
+- `callback_cancel`: Cancela flujo en cualquier momento
+
+**Implementaci√≥n Free Flow:**
+- `callback_request_free`: Crea solicitud Free
+  * Verifica que no haya solicitud pendiente
+  * Si existe ‚Üí Muestra tiempo restante
+  * Si no ‚Üí Crea nueva, muestra tiempo de espera
+
+**Flujos Completos:**
+```
+VIP Token Redeem:
+  User: /start ‚Üí Canjear Token
+  Bot: waiting_for_token
+  User: Env√≠a token
+  Bot: Valida ‚Üí Crea link ‚Üí Env√≠a ‚Üí state.clear()
+
+Free Request:
+  User: /start ‚Üí Solicitar Free
+  Bot: Crea solicitud (sin FSM)
+  Background task procesar√° despu√©s
+```
+
+**Validaciones:**
+- ‚úÖ Admin detection (Config.is_admin)
+- ‚úÖ VIP active check (d√≠as restantes)
+- ‚úÖ Canal VIP/Free configured
+- ‚úÖ Token validation (redeem_vip_token)
+- ‚úÖ Duplicate free request prevention
+- ‚úÖ Error handling con mensajes claros
+
+**Tests Validaci√≥n:** ‚úÖ Todos pasaron
+- ‚úÖ Router 'user' configurado
+- ‚úÖ Handler /start implementado
+- ‚úÖ VIP flow completo
+- ‚úÖ Free flow completo
+- ‚úÖ Callback data correctos
+- ‚úÖ FSM States importables
+- ‚úÖ user_router compartido
+
+---
+
+
+  - [x] Handler /start con detecci√≥n de rol (admin/VIP/usuario)
+  - [x] Flujo VIP: redeem_token ‚Üí process_token ‚Üí create_link
+  - [x] Flujo Free: request_free con check de duplicados
+  - [x] FSM waiting_for_token para validaci√≥n de tokens
+  - [x] Invite links con expiraci√≥n (1h)
+  - [x] Mensajes descriptivos y amigables
+  - [x] Manejo de solicitudes duplicadas
+  - [x] Tests validaci√≥n completos
+
+- [ ] T15: Background Tasks (Expulsi√≥n VIP, Procesamiento Free)
+- [ ] T16-T17: Features finales y deployment
+
+**Status:** ‚úÖ FASE 1.3 COMPLETA (5/5 tareas handlers)
+**Pr√≥ximo:** T15 - Background Tasks (Expulsi√≥n VIP, Procesamiento Free)
+
+---
+
+## ‚úÖ CHECKLIST FASE 1.4
+
+- [x] T15: Background Tasks (Expulsi√≥n VIP + Procesamiento Free)
+  - [x] APScheduler integrado correctamente
+  - [x] expire_and_kick_vip_subscribers() implementado
+  - [x] process_free_queue() implementado
+  - [x] cleanup_old_data() implementado
+  - [x] start_background_tasks() inicia scheduler
+  - [x] stop_background_tasks() detiene scheduler gracefully
+  - [x] get_scheduler_status() retorna estado correcto
+  - [x] max_instances=1 previene ejecuciones simult√°neas
+  - [x] Manejo de canales no configurados (WARNING, no crash)
+  - [x] Error handling robusto (no crashea scheduler)
+  - [x] Logging completo (INFO, WARNING, ERROR)
+  - [x] Frecuencias configurables en config.py
+  - [x] Integraci√≥n en main.py (on_startup, on_shutdown)
+  - [x] 4 tests de error handling (todos pasaron)
+
+---
+
+#### T15: Background Tasks (Expulsi√≥n VIP + Procesamiento Free) ‚úÖ COMPLETADO
+**Archivo:** `bot/background/tasks.py` (280 l√≠neas) + `main.py` (integraci√≥n)
+**Patr√≥n:** APScheduler + AsyncIOScheduler + Error Handling
+**Responsabilidades:**
+- Expulsi√≥n autom√°tica de suscriptores VIP expirados
+- Procesamiento autom√°tico de cola Free
+- Limpieza autom√°tica de datos antiguos
+
+**Implementaci√≥n Tareas:**
+- `expire_and_kick_vip_subscribers()`: Expulsa VIPs expirados cada 60 min
+- `process_free_queue()`: Procesa cola Free cada 5 min
+- `cleanup_old_data()`: Limpia datos antiguos diariamente (3 AM UTC)
+- `start_background_tasks()`: Inicia scheduler con 3 tareas
+- `stop_background_tasks()`: Detiene scheduler gracefully
+- `get_scheduler_status()`: Obtiene estado del scheduler
+
+**Configuraci√≥n Scheduler:**
+- Expulsi√≥n VIP: IntervalTrigger(minutes=60)
+- Procesamiento Free: IntervalTrigger(minutes=5)
+- Limpieza: CronTrigger(hour=3, minute=0, timezone="UTC")
+- max_instances=1: Previene ejecuciones simult√°neas
+- replace_existing=True: Reemplaza jobs al reiniciar
+
+**Validaciones:**
+- ‚úÖ Canales VIP/Free no configurados (WARNING, return early)
+- ‚úÖ Usuario bloquea bot (ERROR, contin√∫a con siguiente)
+- ‚úÖ Scheduler ya corre (WARNING, ignora segundo inicio)
+- ‚úÖ Stop sin start (WARNING, manejo graceful)
+- ‚úÖ max_instances=1 previene race conditions
+
+**Flujos Completos:**
+```
+Expulsi√≥n VIP:
+  ‚Ä¢ Busca VIPs con expiry_date <= now
+  ‚Ä¢ Marca como "expired" (status='expired')
+  ‚Ä¢ Expulsa del canal VIP
+  ‚Ä¢ Loguea resultados
+
+Procesamiento Free:
+  ‚Ä¢ Busca solicitudes con request_date + wait_time <= now
+  ‚Ä¢ Para cada solicitud:
+    - Crea invite link (24h, 1 uso)
+    - Env√≠a link por mensaje privado
+    - Si falla: loguea ERROR, contin√∫a siguiente
+  ‚Ä¢ Resumen: √©xitos y errores
+
+Limpieza:
+  ‚Ä¢ Elimina solicitudes Free procesadas >30 d√≠as
+  ‚Ä¢ Ejecuta diariamente a las 3 AM UTC
+```
+
+**Integraci√≥n main.py:**
+```python
+# on_startup: Iniciar background tasks
+start_background_tasks(bot)
+
+# on_shutdown: Detener background tasks
+stop_background_tasks()
+```
+
+**Tests Validaci√≥n:** ‚úÖ Todos pasaron (4 tests)
+- ‚úÖ Test 1: Scheduler lifecycle (start/stop)
+- ‚úÖ Test 2: Manejo de canales no configurados
+- ‚úÖ Test 3: Idempotencia (start dos veces)
+- ‚úÖ Test 4: Stop sin start
+
+**Logging:**
+- INFO: Inicio/fin de tareas, √©xitos
+- WARNING: Canal no configurado, scheduler ya corre
+- ERROR: Errores en env√≠o de mensajes, excepciones
+- DEBUG: No hay datos procesables
+
+**Configuraci√≥n en config.py:**
+```python
+CLEANUP_INTERVAL_MINUTES: int = 60        # Expulsi√≥n VIP
+PROCESS_FREE_QUEUE_MINUTES: int = 5       # Procesamiento Free
+```
+
+---
+
+**Status:** ‚úÖ FASE 1.4 COMPLETADA (T15)
+**Pr√≥ximo:** T16 - Integraci√≥n Final y Testing E2E
+
+---
+
+## ‚úÖ CHECKLIST FASE 1.5
+
+- [x] T16: Integraci√≥n Final y Testing E2E
+  - [x] conftest.py con fixtures compartidos
+  - [x] 5 tests E2E implementados y pasando
+  - [x] 4 tests integraci√≥n implementados y pasando
+  - [x] event_loop fixture para tests async
+  - [x] db_setup fixture (autouse) para setup/teardown
+  - [x] mock_bot fixture con AsyncMocks
+  - [x] tests/README.md con documentaci√≥n completa
+  - [x] scripts/run_tests.sh ejecutable
+  - [x] Requirements.txt actualizado (pytest, pytest-asyncio)
+  - [x] README.md con secci√≥n Testing
+  - [x] Todos los 9 tests pasando sin errores
+  - [x] Tests independientes (orden no importa)
+  - [x] BD limpia entre tests
+  - [x] Fixtures configurados correctamente
+
+---
+
+#### T16: Integraci√≥n Final y Testing E2E ‚úÖ COMPLETADO
+**Archivos:** `tests/` (estructura completa con 9 tests)
+**Patr√≥n:** pytest + pytest-asyncio + fixtures compartidos
+**Responsabilidades:**
+- Suite de tests E2E para flujos completos
+- Tests de integraci√≥n entre servicios
+- Validaci√≥n de funcionalidad del bot
+
+**Implementaci√≥n Tests:**
+
+**E2E Tests (5 tests):**
+1. `test_vip_flow_complete`: Flujo VIP completo
+   - Admin genera token ‚Üí Usuario canjea ‚Üí Acceso activo
+   - Valida: token generado, suscriptor creado, token marcado usado
+
+2. `test_free_flow_complete`: Flujo Free completo
+   - Usuario solicita ‚Üí Espera tiempo configurado ‚Üí Procesa cola
+   - Valida: solicitud pendiente, no procesa inmediatamente, no duplica
+
+3. `test_vip_expiration`: Expulsi√≥n autom√°tica de VIP
+   - Crear VIP expirado ‚Üí Ejecutar tarea expiration ‚Üí Verificar expirado
+   - Valida: is_expired() detecta, marca como expired, is_vip_active() retorna False
+
+4. `test_token_validation_edge_cases`: Validaci√≥n de tokens
+   - Token no existe, usado, expirado, v√°lido
+   - Cada caso valida retorno correcto de is_valid y mensaje claro
+
+5. `test_duplicate_free_request_prevention`: Prevenci√≥n de duplicados
+   - Primera solicitud crea, segunda retorna existente (no duplica)
+
+**Integration Tests (4 tests):**
+1. `test_service_container_lazy_loading`: Lazy loading de servicios
+   - Container vac√≠o ‚Üí Acceder subscription ‚Üí Se carga
+   - Verificar reutilizaci√≥n de instancia
+
+2. `test_config_service_singleton`: BotConfig como singleton
+   - Ambos gets retornan id=1
+   - Cambios persisten en BD
+
+3. `test_database_session_management`: Manejo de sesiones
+   - M√∫ltiples sesiones ven cambios rec√≠procos
+   - Transacciones se aplican correctamente
+
+4. `test_error_handling_across_services`: Error handling robusto
+   - Token inv√°lido rechazado
+   - Token inexistente detectado
+   - No crashes ante errores
+
+**Fixtures Compartidos (conftest.py):**
+- `event_loop`: Event loop para tests async
+- `db_setup` (autouse): Init/close BD autom√°ticamente
+- `mock_bot`: Mock del bot de Telegram
+
+**Documentaci√≥n:**
+- `tests/README.md`: Gu√≠a completa de tests y ejecuci√≥n
+- `scripts/run_tests.sh`: Helper script ejecutable
+
+**Ejecuci√≥n:**
+```bash
+# Instalar dependencias
+pip install pytest==7.4.3 pytest-asyncio==0.21.1 --break-system-packages
+
+# Ejecutar tests
+pytest tests/ -v
+
+# O usar script helper
+bash scripts/run_tests.sh
+```
+
+**Output Esperado:**
+```
+======================== 9 passed in 5.99s ========================
+```
+
+**Validaciones:**
+- ‚úÖ 9 tests E2E e integraci√≥n (todos pasando)
+- ‚úÖ Fixtures funcionales (autouse, setup/teardown)
+- ‚úÖ Mocks del bot configurados correctamente
+- ‚úÖ Tests independientes (orden no importa)
+- ‚úÖ BD limpia entre tests
+- ‚úÖ Documentaci√≥n completa
+- ‚úÖ Script helper ejecutable
+
+---
+
+**Status:** ‚úÖ FASE 1.5 COMPLETADA (T16)
+**Pr√≥ximo:** T17 - Features Finales y Deployment
diff --git a/README.md b/README.md
index d811e1b..260d166 100644
--- a/README.md
+++ b/README.md
@@ -119,35 +119,1190 @@ Gesti√≥n de configuraci√≥n global del bot con funcionalidades clave:
 - **Validaci√≥n de configuraci√≥n:** Verificar que la configuraci√≥n est√© completa
 - **Tarifas de suscripci√≥n:** Configurar y gestionar precios de suscripciones
 
-**Ejemplo de uso del Service Container:**
+### Middlewares (T10)
+Implementaci√≥n de middlewares para autenticaci√≥n de administradores e inyecci√≥n autom√°tica de sesiones de base de datos:
+
+- **AdminAuthMiddleware:** Valida que el usuario tenga permisos de administrador antes de ejecutar handlers protegidos
+- **DatabaseMiddleware:** Inyecta autom√°ticamente una sesi√≥n de SQLAlchemy a cada handler que lo requiera
+- **Aplicaci√≥n a handlers:** Se aplican a routers y handlers que requieren permisos administrativos o acceso a BD
+- **Manejo de errores:** Si el usuario no es admin, responde con mensaje de error y no ejecuta el handler
+- **Inyecci√≥n autom√°tica:** Proporciona una sesi√≥n de SQLAlchemy a cada handler autom√°ticamente
+
+**Ejemplo de uso de los middlewares:**
+```python
+from aiogram import Router
+from bot.middlewares.admin_auth import AdminAuthMiddleware
+from bot.middlewares.database import DatabaseMiddleware
+
+# Aplicar middlewares a un router de administraci√≥n
+admin_router = Router()
+admin_router.message.middleware(AdminAuthMiddleware())  # Protege todos los handlers de mensajes
+admin_router.callback_query.middleware(AdminAuthMiddleware())  # Protege callbacks
+
+# Aplicar middleware de base de datos al dispatcher para inyectar sesiones
+dispatcher.update.middleware(DatabaseMiddleware())
+
+# Handler que recibe la sesi√≥n autom√°ticamente gracias al middleware
+@admin_router.message(Command("admin_command"))
+async def admin_handler(message: Message, session: AsyncSession):
+    # La sesi√≥n est√° disponible autom√°ticamente gracias al DatabaseMiddleware
+    # Si el usuario no es admin, este handler no se ejecuta gracias al AdminAuthMiddleware
+    await message.answer("Comando de administrador ejecutado correctamente")
+```
+
+**Ejemplo de validaci√≥n de permisos de administrador:**
+```python
+# El middleware AdminAuthMiddleware se encarga de validar autom√°ticamente
+# Si el usuario no es admin, env√≠a un mensaje de error y no ejecuta el handler
+# Configuraci√≥n en config.py:
+# ADMIN_USER_IDS = [123456789, 987654321]  # Lista de IDs de administradores
+```
+
+**Ejemplo de inyecci√≥n autom√°tica de sesiones de base de datos:**
+```python
+# El middleware DatabaseMiddleware inyecta la sesi√≥n autom√°ticamente
+# No es necesario abrir/cerrar conexiones manualmente
+async def handler_con_bd(message: Message, session: AsyncSession):
+    # Usar la sesi√≥n inyectada para operaciones de base de datos
+    result = await session.execute(select(User).where(User.id == message.from_user.id))
+    user = result.scalar_one_or_none()
+
+    if user:
+        await message.answer(f"Usuario encontrado: {user.name}")
+    else:
+        await message.answer("Usuario no encontrado")
+```
+
+### FSM States (T11)
+Implementaci√≥n de Finite State Machine (FSM) para manejar flujos interactivos con m√∫ltiples pasos:
+
+- **Admin States:** Estados para flujos de administraci√≥n como configuraci√≥n de canales y env√≠o de publicaciones
+- **User States:** Estados para flujos de usuarios como canje de tokens VIP y solicitud de acceso Free
+- **Storage:** MemoryStorage para mantener estados en memoria (ligero para Termux)
+- **Flujos implementados:**
+  - Configuraci√≥n de canales VIP y Free (extracci√≥n de IDs de canales)
+  - Configuraci√≥n de tiempo de espera del canal Free
+  - Env√≠o de publicaciones a canales (broadcast)
+  - Canje de tokens VIP
+  - Solicitud de acceso Free
+
+**Ejemplo de uso de estados FSM:**
 ```python
-container = ServiceContainer(session, bot)
+from aiogram.fsm.context import FSMContext
+from bot.states.admin import ChannelSetupStates
 
-# Primera vez: carga el servicio (lazy loading)
-token = await container.subscription.generate_token(...)
+# Handler que inicia un flujo FSM
+@admin_router.message(Command("setup_vip_channel"))
+async def setup_vip_channel_start(message: Message, state: FSMContext):
+    await message.answer("Por favor, reenv√≠a un mensaje del canal VIP para extraer su ID:")
+    await state.set_state(ChannelSetupStates.waiting_for_vip_channel)
 
-# Segunda vez: reutiliza instancia ya cargada
-result = await container.subscription.validate_token(...)
+# Handler que procesa el siguiente paso del flujo FSM
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel, F.forward_from_chat)
+async def process_vip_channel(message: Message, state: FSMContext):
+    channel_id = str(message.forward_from_chat.id)
 
-# Uso del servicio de canales
-success, message = await container.channel.setup_vip_channel("-1001234567890")
-is_valid, perm_message = await container.channel.verify_bot_permissions("-1001234567890")
-sent_success, sent_message, sent_msg = await container.channel.send_to_channel(
-    channel_id="-1001234567890",
-    text="Publicaci√≥n VIP",
-    photo="photo_file_id"
-)
+    # Aqu√≠ se procesar√≠a la configuraci√≥n del canal
+    await message.answer(f"Canal VIP configurado con ID: {channel_id}")
+    await state.clear()  # Limpiar estado al finalizar flujo
 
-# Uso del servicio de configuraci√≥n
-config = await container.config.get_config()
-wait_time = await container.config.get_wait_time()
-await container.config.set_wait_time(10)  # 10 minutos de espera
-await container.config.set_vip_reactions(["üëç", "‚ù§Ô∏è", "üî•"])
-await container.config.set_subscription_fees({"monthly": 10, "yearly": 100})
-is_configured = await container.config.is_fully_configured()
-summary = await container.config.get_config_summary()
+# Handler para manejar entradas inv√°lidas durante el flujo FSM
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def invalid_vip_channel(message: Message):
+    await message.answer("Por favor, reenv√≠a un mensaje del canal VIP (no un mensaje normal).")
 ```
 
+**Estados Admin disponibles:**
+- `ChannelSetupStates`: Configuraci√≥n de canales VIP y Free
+- `WaitTimeSetupStates`: Configuraci√≥n de tiempo de espera del canal Free
+- `BroadcastStates`: Env√≠o de publicaciones a canales
+
+**Estados User disponibles:**
+- `TokenRedemptionStates`: Canje de tokens VIP
+- `FreeAccessStates`: Solicitud de acceso Free
+```
+
+### Admin Handler (T12)
+Handler del comando /admin que muestra el men√∫ principal de administraci√≥n con navegaci√≥n, verificaci√≥n de estado de configuraci√≥n y teclado inline:
+
+- **Navegaci√≥n del men√∫ principal:** Permite navegar entre diferentes secciones de administraci√≥n con estado de configuraci√≥n
+- **Aplicaci√≥n de middlewares:** Utiliza AdminAuthMiddleware y DatabaseMiddleware para protecci√≥n y acceso a base de datos
+- **Verificaci√≥n de estado de configuraci√≥n:** Muestra estado actual de configuraci√≥n del bot (completo o incompleto)
+- **Callback handlers:** Implementa manejadores de callback para navegaci√≥n entre men√∫s
+- **Teclado inline:** Proporciona opciones de administraci√≥n a trav√©s de teclado inline
+
+**Ejemplo de uso del handler admin:**
+```python
+from aiogram import Router, F
+from aiogram.filters import Command
+from aiogram.types import Message, CallbackQuery
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares import AdminAuthMiddleware, DatabaseMiddleware
+from bot.utils.keyboards import admin_main_menu_keyboard, back_to_main_menu_keyboard
+from bot.services.container import ServiceContainer
+
+# Router para handlers de admin
+admin_router = Router(name="admin")
+
+# Aplicar middlewares (orden correcto: Database primero, AdminAuth despu√©s)
+admin_router.message.middleware(DatabaseMiddleware())
+admin_router.message.middleware(AdminAuthMiddleware())
+admin_router.callback_query.middleware(DatabaseMiddleware())
+admin_router.callback_query.middleware(AdminAuthMiddleware())
+
+@admin_router.message(Command("admin"))
+async def cmd_admin(message: Message, session: AsyncSession):
+    """
+    Handler del comando /admin.
+
+    Muestra el men√∫ principal de administraci√≥n con estado de configuraci√≥n.
+    """
+    # Crear container de services
+    container = ServiceContainer(session, message.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    await message.answer(
+        text=text,
+        reply_markup=admin_main_menu_keyboard(),
+        parse_mode="HTML"
+    )
+
+@admin_router.callback_query(F.data == "admin:main")
+async def callback_admin_main(callback: CallbackQuery, session: AsyncSession):
+    """
+    Handler del callback para volver al men√∫ principal.
+    """
+    # Crear container de services
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫ (mismo que cmd_admin)
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    # Editar mensaje existente (no enviar nuevo)
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=admin_main_menu_keyboard(),
+        parse_mode="HTML"
+    )
+
+    # Responder al callback (quitar "loading" del bot√≥n)
+    await callback.answer()
+```
+
+### VIP and Free Handlers (T13)
+Handlers para la gesti√≥n de canales VIP y Free con funcionalidades completas de configuraci√≥n y administraci√≥n:
+
+- **Submen√∫ VIP:** Gesti√≥n del canal VIP con generaci√≥n de tokens de invitaci√≥n
+- **Configuraci√≥n del canal VIP:** Configuraci√≥n del canal VIP por reenv√≠o de mensajes
+- **Generaci√≥n de tokens de invitaci√≥n:** Creaci√≥n de tokens VIP con duraci√≥n configurable
+- **Submen√∫ Free:** Gesti√≥n del canal Free con configuraci√≥n de tiempo de espera
+- **Configuraci√≥n del canal Free:** Configuraci√≥n del canal Free por reenv√≠o de mensajes
+- **Configuraci√≥n de tiempo de espera:** Configuraci√≥n de tiempo de espera para acceso Free
+
+### User Handler (T14)
+Handler del comando /start que detecta el rol del usuario y proporciona flujos para canje de tokens VIP y solicitud de acceso Free:
+
+- **Handler /start:** Punto de entrada para usuarios con detecci√≥n de rol (admin/VIP/usuario)
+- **Flujo VIP:** Canje de tokens VIP con validaci√≥n y generaci√≥n de invite links
+- **Flujo Free:** Solicitud de acceso Free con tiempo de espera y notificaciones autom√°ticas
+- **Middleware de base de datos:** Inyecci√≥n de sesiones sin autenticaci√≥n de admin
+- **FSM para validaci√≥n de tokens:** Estados para manejo de entrada de tokens
+- **Validaci√≥n de configuraci√≥n:** Verificaci√≥n de canales configurados antes de procesar
+
+### Background Tasks (T15)
+Tareas programadas autom√°ticas que realizan operaciones peri√≥dicas para mantener el sistema funcionando correctamente:
+
+- **Expulsi√≥n de VIPs expirados:** Tarea que marca como expirados y expulsa del canal a los suscriptores VIP cuya fecha pas√≥
+- **Procesamiento de cola Free:** Tarea que busca solicitudes que cumplieron el tiempo de espera y env√≠a invite links a los usuarios
+- **Limpieza de datos antiguos:** Tarea que elimina solicitudes Free procesadas hace m√°s de 30 d√≠as
+- **Scheduler con tareas programadas:** Configuraci√≥n del scheduler APScheduler con intervalos configurables
+- **Configuraci√≥n de intervalos:** Configuraci√≥n de frecuencias de ejecuci√≥n mediante variables de entorno
+- **Manejo de errores:** Control de errores en todas las tareas con logging apropiado
+
+**Ejemplo de uso de las background tasks:**
+```python
+from aiogram import Bot
+from bot.background.tasks import start_background_tasks, stop_background_tasks
+
+# Iniciar tareas programadas al inicio del bot
+async def on_startup(bot: Bot, dispatcher: Dispatcher) -> None:
+    # ... otras inicializaciones ...
+
+    # Iniciar background tasks
+    start_background_tasks(bot)
+
+# Detener tareas programadas al apagar el bot
+async def on_shutdown(bot: Bot, dispatcher: Dispatcher) -> None:
+    # Detener background tasks
+    stop_background_tasks()
+
+    # ... otras tareas de cierre ...
+
+# Configuraci√≥n de intervalos en config.py:
+# CLEANUP_INTERVAL_MINUTES = int(os.getenv("CLEANUP_INTERVAL_MINUTES", "60"))  # Expulsi√≥n VIPs
+# PROCESS_FREE_QUEUE_MINUTES = int(os.getenv("PROCESS_FREE_QUEUE_MINUTES", "5"))  # Procesamiento Free
+```
+
+**Tareas programadas configuradas:**
+- `expire_and_kick_vip_subscribers`: Cada 60 minutos (configurable) - Expulsa VIPs expirados del canal
+- `process_free_queue`: Cada 5 minutos (configurable) - Procesa solicitudes Free que cumplieron tiempo de espera
+- `cleanup_old_data`: Diariamente a las 3 AM UTC - Limpia datos antiguos de solicitudes Free
+```
+
+**Ejemplo de uso del handler User:**
+```python
+from aiogram import Router, F
+from aiogram.filters import Command
+from aiogram.types import Message, CallbackQuery
+from aiogram.fsm.context import FSMContext
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares import DatabaseMiddleware
+from bot.utils.keyboards import create_inline_keyboard
+from bot.services.container import ServiceContainer
+from bot.states.user import TokenRedemptionStates
+from config import Config
+
+# Router para handlers de usuario
+user_router = Router(name="user")
+
+# Aplicar middleware de database (NO AdminAuth, estos son usuarios normales)
+user_router.message.middleware(DatabaseMiddleware())
+user_router.callback_query.middleware(DatabaseMiddleware())
+
+@user_router.message(Command("start"))
+async def cmd_start(message: Message, session: AsyncSession):
+    """
+    Handler del comando /start para usuarios.
+
+    Comportamiento:
+    - Si es admin ‚Üí Redirige a /admin
+    - Si es VIP activo ‚Üí Muestra mensaje de bienvenida con d√≠as restantes
+    - Si no es admin ‚Üí Muestra men√∫ de usuario (VIP/Free)
+    """
+    user_id = message.from_user.id
+    user_name = message.from_user.first_name or "Usuario"
+
+    # Verificar si es admin
+    if Config.is_admin(user_id):
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"Eres administrador. Usa /admin para gestionar los canales.",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario normal: verificar si es VIP activo
+    container = ServiceContainer(session, message.bot)
+
+    is_vip = await container.subscription.is_vip_active(user_id)
+
+    if is_vip:
+        # Usuario ya tiene acceso VIP
+        subscriber = await container.subscription.get_vip_subscriber(user_id)
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"‚úÖ Tienes acceso VIP activo\n"
+            f"‚è±Ô∏è D√≠as restantes: <b>{days_remaining}</b>\n\n"
+            f"Disfruta del contenido exclusivo! üéâ",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario no es VIP: mostrar opciones
+    keyboard = create_inline_keyboard([
+        [{"text": "üéüÔ∏è Canjear Token VIP", "callback_data": "user:redeem_token"}],
+        [{"text": "üì∫ Solicitar Acceso Free", "callback_data": "user:request_free"}],
+    ])
+
+    await message.answer(
+        f"üëã Hola <b>{user_name}</b>!\n\n"
+        f"Bienvenido al bot de acceso a canales.\n\n"
+        f"<b>Opciones disponibles:</b>\n\n"
+        f"üéüÔ∏è <b>Canjear Token VIP</b>\n"
+        f"Si tienes un token de invitaci√≥n, canj√©alo para acceso VIP.\n\n"
+        f"üì∫ <b>Solicitar Acceso Free</b>\n"
+        f"Solicita acceso al canal gratuito (con tiempo de espera).\n\n"
+        f"üëâ Selecciona una opci√≥n:",
+        reply_markup=keyboard,
+        parse_mode="HTML"
+    )
+
+# Flujo de canje de token VIP
+@user_router.callback_query(F.data == "user:redeem_token")
+async def callback_redeem_token(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el flujo de canje de token VIP.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = callback.from_user.id
+
+    # Verificar que canal VIP est√° configurado
+    container = ServiceContainer(session, callback.bot)
+
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal VIP no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Entrar en estado FSM
+    await state.set_state(TokenRedemptionStates.waiting_for_token)
+
+    try:
+        await callback.message.edit_text(
+            "üéüÔ∏è <b>Canjear Token VIP</b>\n\n"
+            "Por favor, env√≠a tu token de invitaci√≥n.\n\n"
+            "El token tiene este formato:\n"
+            "<code>A1b2C3d4E5f6G7h8</code>\n\n"
+            "üëâ Copia y pega tu token aqu√≠:",
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "user:cancel"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
+
+@user_router.message(TokenRedemptionStates.waiting_for_token)
+async def process_token_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el token enviado por el usuario.
+
+    Valida el token, lo canjea y env√≠a invite link.
+
+    Args:
+        message: Mensaje con el token
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = message.from_user.id
+    token_str = message.text.strip()
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar canjear token
+    success, msg, subscriber = await container.subscription.redeem_vip_token(
+        token_str=token_str,
+        user_id=user_id
+    )
+
+    if not success:
+        # Token inv√°lido
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica el token e intenta nuevamente.\n\n"
+            f"Si el problema persiste, contacta al administrador.",
+            parse_mode="HTML"
+        )
+        # Mantener estado para reintentar
+        return
+
+    # Token v√°lido: crear invite link
+    vip_channel_id = await container.channel.get_vip_channel_id()
+
+    try:
+        invite_link = await container.subscription.create_invite_link(
+            channel_id=vip_channel_id,
+            user_id=user_id,
+            expire_hours=1  # Link expira en 1 hora
+        )
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"‚úÖ <b>Token Canjeado Exitosamente!</b>\n\n"
+            f"üéâ Tu acceso VIP est√° activo\n"
+            f"‚è±Ô∏è Duraci√≥n: <b>{days_remaining} d√≠as</b>\n\n"
+            f"üëá Usa este link para unirte al canal VIP:\n"
+            f"{invite_link.invite_link}\n\n"
+            f"‚ö†Ô∏è <b>Importante:</b>\n"
+            f"‚Ä¢ El link expira en 1 hora\n"
+            f"‚Ä¢ Solo puedes usarlo 1 vez\n"
+            f"‚Ä¢ No lo compartas con otros\n\n"
+            f"Disfruta del contenido exclusivo! üöÄ",
+            parse_mode="HTML"
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error creando invite link para user {user_id}: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al crear el link de invitaci√≥n.\n\n"
+            "Tu token fue canjeado correctamente, pero hubo un problema t√©cnico.\n"
+            "Contacta al administrador.",
+            parse_mode="HTML"
+        )
+        await state.clear()
+
+# Flujo de solicitud Free
+@user_router.callback_query(F.data == "user:request_free")
+async def callback_request_free(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Procesa solicitud de acceso al canal Free.
+
+    Crea la solicitud y notifica al usuario del tiempo de espera.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    user_id = callback.from_user.id
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal Free est√° configurado
+    if not await container.channel.is_free_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal Free no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Verificar si ya tiene solicitud pendiente
+    existing_request = await container.subscription.get_free_request(user_id)
+
+    if existing_request:
+        # Calcular tiempo restante
+        from datetime import datetime, timezone, timedelta
+
+        wait_time_minutes = await container.config.get_wait_time()
+        time_since_request = (datetime.now(timezone.utc) - existing_request.request_date).total_seconds() / 60
+        minutes_remaining = max(0, int(wait_time_minutes - time_since_request))
+
+        try:
+            await callback.message.edit_text(
+                f"‚è±Ô∏è <b>Solicitud Pendiente</b>\n\n"
+                f"Ya tienes una solicitud en proceso.\n\n"
+                f"Tiempo transcurrido: <b>{int(time_since_request)} minutos</b>\n"
+                f"Tiempo restante: <b>{minutes_remaining} minutos</b>\n\n"
+                f"Recibir√°s el link de acceso autom√°ticamente cuando el tiempo se cumpla.\n\n"
+                f"üí° <i>Puedes cerrar este chat, te notificar√© cuando est√© listo.</i>",
+                parse_mode="HTML"
+            )
+        except Exception as e:
+            if "message is not modified" not in str(e):
+                logger.error(f"Error editando mensaje: {e}")
+
+        await callback.answer()
+        return
+
+    # Crear nueva solicitud
+    request = await container.subscription.create_free_request(user_id)
+    wait_time = await container.config.get_wait_time()
+
+    try:
+        await callback.message.edit_text(
+            f"‚úÖ <b>Solicitud Recibida</b>\n\n"
+            f"Tu solicitud de acceso al canal Free ha sido registrada.\n\n"
+            f"‚è±Ô∏è Tiempo de espera: <b>{wait_time} minutos</b>\n\n"
+            f"üì® Recibir√°s un mensaje con el link de invitaci√≥n cuando el tiempo se cumpla.\n\n"
+            f"üí° <i>No necesitas hacer nada m√°s, el proceso es autom√°tico.</i>\n\n"
+            f"Puedes cerrar este chat, te notificar√© cuando est√© listo! üîî",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer("‚úÖ Solicitud creada")
+
+# Cancelar flujo
+@user_router.callback_query(F.data == "user:cancel")
+async def callback_cancel(
+    callback: CallbackQuery,
+    state: FSMContext
+):
+    """
+    Cancela el flujo actual y limpia estado FSM.
+
+    Args:
+        callback: Callback query
+        state: FSM context
+    """
+    await state.clear()
+
+    try:
+        await callback.message.edit_text(
+            "‚ùå Operaci√≥n cancelada.\n\n"
+            "Usa /start para volver al men√∫ principal.",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
+```
+
+**Ejemplo de uso de los handlers VIP y Free:**
+```python
+from aiogram import Router, F
+from aiogram.types import CallbackQuery, Message
+from aiogram.fsm.context import FSMContext
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.handlers.admin.main import admin_router
+from bot.states.admin import ChannelSetupStates, WaitTimeSetupStates
+from bot.services.container import ServiceContainer
+from bot.utils.keyboards import create_inline_keyboard
+
+# Submen√∫ VIP
+def vip_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ VIP.
+
+    Args:
+        is_configured: Si el canal VIP est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones VIP
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "üéüÔ∏è Generar Token de Invitaci√≥n", "callback_data": "vip:generate_token"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "vip:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal VIP", "callback_data": "vip:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+
+@admin_router.callback_query(F.data == "admin:vip")
+async def callback_vip_menu(callback: CallbackQuery, session: AsyncSession):
+    """
+    Muestra el submen√∫ de gesti√≥n VIP.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD (inyectada por middleware)
+    """
+    logger.debug(f"üì∫ Usuario {callback.from_user.id} abri√≥ men√∫ VIP")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar si canal VIP est√° configurado
+    is_configured = await container.channel.is_vip_channel_configured()
+
+    if is_configured:
+        vip_channel_id = await container.channel.get_vip_channel_id()
+
+        # Obtener info del canal
+        channel_info = await container.channel.get_channel_info(vip_channel_id)
+        channel_name = channel_info.title if channel_info else "Canal VIP"
+
+        text = (
+            f"üì∫ <b>Gesti√≥n Canal VIP</b>\n\n"
+            f"‚úÖ Canal configurado: <b>{channel_name}</b>\n"
+            f"ID: <code>{vip_channel_id}</code>\n\n"
+            f"Selecciona una opci√≥n:"
+        )
+    else:
+        text = (
+            "üì∫ <b>Gesti√≥n Canal VIP</b>\n\n"
+            "‚ö†Ô∏è Canal VIP no configurado\n\n"
+            "Configura el canal para comenzar a generar tokens de invitaci√≥n."
+        )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=vip_menu_keyboard(is_configured),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje VIP: {e}")
+
+    await callback.answer()
+
+# Configuraci√≥n del canal VIP
+@admin_router.callback_query(F.data == "vip:setup")
+async def callback_vip_setup(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el proceso de configuraci√≥n del canal VIP.
+
+    Entra en estado FSM esperando que el admin reenv√≠e un mensaje del canal.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚öôÔ∏è Usuario {callback.from_user.id} iniciando setup VIP")
+
+    # Entrar en estado FSM
+    await state.set_state(ChannelSetupStates.waiting_for_vip_channel)
+
+    text = (
+        "‚öôÔ∏è <b>Configurar Canal VIP</b>\n\n"
+        "Para configurar el canal VIP, necesito que:\n\n"
+        "1Ô∏è‚É£ Vayas al canal VIP\n"
+        "2Ô∏è‚É£ Reenv√≠es cualquier mensaje del canal a este chat\n"
+        "3Ô∏è‚É£ Yo extraer√© el ID autom√°ticamente\n\n"
+        "‚ö†Ô∏è <b>Importante:</b>\n"
+        "- El bot debe ser administrador del canal\n"
+        "- El bot debe tener permiso para invitar usuarios\n\n"
+        "üëâ Reenv√≠a un mensaje del canal ahora..."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:vip"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje setup VIP: {e}")
+
+    await callback.answer()
+
+# Procesamiento del reenv√≠o para configuraci√≥n del canal VIP
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def process_vip_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal VIP.
+
+    Extrae el ID del canal del forward y lo configura.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Verificar que es un forward de un canal
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal VIP.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    # Verificar que es un canal (no grupo ni usuario)
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal VIP.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal VIP: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_vip_channel(channel_id)
+
+    if success:
+        # Configuraci√≥n exitosa
+        await message.answer(
+            f"‚úÖ <b>Canal VIP Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Ya puedes generar tokens de invitaci√≥n.",
+            parse_mode="HTML",
+            reply_markup=vip_menu_keyboard(True)
+        )
+
+        # Limpiar estado FSM
+        await state.clear()
+    else:
+        # Error en configuraci√≥n
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica que:\n"
+            f"‚Ä¢ El bot es administrador del canal\n"
+            f"‚Ä¢ El bot tiene permiso para invitar usuarios\n\n"
+            f"Intenta nuevamente reenviando un mensaje del canal.",
+            parse_mode="HTML"
+        )
+        # Mantener estado FSM para reintentar
+
+# Generaci√≥n de tokens VIP
+@admin_router.callback_query(F.data == "vip:generate_token")
+async def callback_generate_vip_token(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Genera un token de invitaci√≥n VIP.
+
+    Token v√°lido por 24 horas, un solo uso.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.info(f"üéüÔ∏è Usuario {callback.from_user.id} generando token VIP")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal VIP est√° configurado
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ùå Debes configurar el canal VIP primero",
+            show_alert=True
+        )
+        return
+
+    try:
+        # Generar token (24 horas por defecto)
+        token = await container.subscription.generate_vip_token(
+            generated_by=callback.from_user.id,
+            duration_hours=Config.DEFAULT_TOKEN_DURATION_HOURS
+        )
+
+        # Crear mensaje con el token
+        token_message = (
+            f"üéüÔ∏è <b>Token VIP Generado</b>\n\n"
+            f"Token: <code>{token.token}</code>\n\n"
+            f"‚è±Ô∏è V√°lido por: {token.duration_hours} horas\n"
+            f"üìÖ Expira: {token.created_at.strftime('%Y-%m-%d %H:%M')} UTC\n\n"
+            f"üëâ Comparte este token con el usuario.\n"
+            f"El usuario debe enviarlo al bot para canjear acceso VIP."
+        )
+
+        await callback.message.answer(
+            text=token_message,
+            parse_mode="HTML"
+        )
+
+        await callback.answer("‚úÖ Token generado")
+
+    except Exception as e:
+        logger.error(f"Error generando token VIP: {e}", exc_info=True)
+        await callback.answer(
+            "‚ùå Error al generar token. Intenta nuevamente.",
+            show_alert=True
+        )
+
+# Submen√∫ Free
+def free_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ Free.
+
+    Args:
+        is_configured: Si el canal Free est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones Free
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "‚è±Ô∏è Configurar Tiempo de Espera", "callback_data": "free:set_wait_time"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "free:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal Free", "callback_data": "free:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+
+@admin_router.callback_query(F.data == "admin:free")
+async def callback_free_menu(callback: CallbackQuery, session: AsyncSession):
+    """
+    Muestra el submen√∫ de gesti√≥n Free.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.debug(f"üì∫ Usuario {callback.from_user.id} abri√≥ men√∫ Free")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar si canal Free est√° configurado
+    is_configured = await container.channel.is_free_channel_configured()
+
+    if is_configured:
+        free_channel_id = await container.channel.get_free_channel_id()
+        wait_time = await container.config.get_wait_time()
+
+        # Obtener info del canal
+        channel_info = await container.channel.get_channel_info(free_channel_id)
+        channel_name = channel_info.title if channel_info else "Canal Free"
+
+        text = (
+            f"üì∫ <b>Gesti√≥n Canal Free</b>\n\n"
+            f"‚úÖ Canal configurado: <b>{channel_name}</b>\n"
+            f"ID: <code>{free_channel_id}</code>\n\n"
+            f"‚è±Ô∏è Tiempo de espera: <b>{wait_time} minutos</b>\n\n"
+            f"Selecciona una opci√≥n:"
+        )
+    else:
+        text = (
+            "üì∫ <b>Gesti√≥n Canal Free</b>\n\n"
+            "‚ö†Ô∏è Canal Free no configurado\n\n"
+            "Configura el canal para que usuarios puedan solicitar acceso."
+        )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=free_menu_keyboard(is_configured),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje Free: {e}")
+
+    await callback.answer()
+
+# Configuraci√≥n del canal Free
+@admin_router.callback_query(F.data == "free:setup")
+async def callback_free_setup(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el proceso de configuraci√≥n del canal Free.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚öôÔ∏è Usuario {callback.from_user.id} iniciando setup Free")
+
+    # Entrar en estado FSM
+    await state.set_state(ChannelSetupStates.waiting_for_free_channel)
+
+    text = (
+        "‚öôÔ∏è <b>Configurar Canal Free</b>\n\n"
+        "Para configurar el canal Free:\n\n"
+        "1Ô∏è‚É£ Vayas al canal Free\n"
+        "2Ô∏è‚É£ Reenv√≠es cualquier mensaje del canal a este chat\n"
+        "3Ô∏è‚É£ Yo extraer√© el ID autom√°ticamente\n\n"
+        "‚ö†Ô∏è <b>Importante:</b>\n"
+        "- El bot debe ser administrador del canal\n"
+        "- El bot debe tener permiso para invitar usuarios\n\n"
+        "üëâ Reenv√≠a un mensaje del canal ahora..."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje setup Free: {e}")
+
+    await callback.answer()
+
+# Procesamiento del reenv√≠o para configuraci√≥n del canal Free
+@admin_router.message(ChannelSetupStates.waiting_for_free_channel)
+async def process_free_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal Free.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Validaciones id√©nticas a VIP
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal Free.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal Free.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal Free: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_free_channel(channel_id)
+
+    if success:
+        await message.answer(
+            f"‚úÖ <b>Canal Free Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Los usuarios ya pueden solicitar acceso.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        await state.clear()
+    else:
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica permisos del bot e intenta nuevamente.",
+            parse_mode="HTML"
+        )
+
+# Configuraci√≥n de tiempo de espera
+@admin_router.callback_query(F.data == "free:set_wait_time")
+async def callback_set_wait_time(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia configuraci√≥n de tiempo de espera.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚è±Ô∏è Usuario {callback.from_user.id} configurando wait time")
+
+    container = ServiceContainer(session, callback.bot)
+    current_wait_time = await container.config.get_wait_time()
+
+    # Entrar en estado FSM
+    await state.set_state(WaitTimeSetupStates.waiting_for_minutes)
+
+    text = (
+        f"‚è±Ô∏è <b>Configurar Tiempo de Espera</b>\n\n"
+        f"Tiempo actual: <b>{current_wait_time} minutos</b>\n\n"
+        f"Env√≠a el nuevo tiempo de espera en minutos.\n"
+        f"Ejemplo: <code>5</code>\n\n"
+        f"El tiempo debe ser mayor o igual a 1 minuto."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje wait time: {e}")
+
+    await callback.answer()
+
+# Procesamiento del tiempo de espera
+@admin_router.message(WaitTimeSetupStates.waiting_for_minutes)
+async def process_wait_time_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el input de tiempo de espera.
+
+    Args:
+        message: Mensaje con los minutos
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Intentar convertir a n√∫mero
+    try:
+        minutes = int(message.text)
+    except ValueError:
+        await message.answer(
+            "‚ùå Debes enviar un n√∫mero v√°lido.\n\n"
+            "Ejemplo: <code>5</code>",
+            parse_mode="HTML"
+        )
+        return
+
+    # Validar rango
+    if minutes < 1:
+        await message.answer(
+            "‚ùå El tiempo debe ser al menos 1 minuto.\n\n"
+            "Env√≠a un n√∫mero mayor o igual a 1.",
+            parse_mode="HTML"
+        )
+        return
+
+    container = ServiceContainer(session, message.bot)
+
+    try:
+        # Actualizar configuraci√≥n
+        await container.config.set_wait_time(minutes)
+
+        await message.answer(
+            f"‚úÖ <b>Tiempo de Espera Actualizado</b>\n\n"
+            f"Nuevo tiempo: <b>{minutes} minutos</b>\n\n"
+            f"Las nuevas solicitudes esperar√°n {minutes} minutos antes de procesarse.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error actualizando wait time: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al actualizar el tiempo de espera.\n\n"
+            "Intenta nuevamente.",
+            parse_mode="HTML"
+        )
+```
+
+## üß™ Testing
+
+El proyecto incluye suite completa de tests E2E e integraci√≥n para validar funcionalidad.
+
+### Instalar Dependencias de Testing
+
+```bash
+# Instalar pytest y pytest-asyncio
+pip install pytest==7.4.3 pytest-asyncio==0.21.1 --break-system-packages
+```
+
+### Ejecutar Tests
+
+```bash
+# Todos los tests
+pytest tests/ -v
+
+# Solo tests E2E
+pytest tests/test_e2e_flows.py -v
+
+# Solo tests de integracion
+pytest tests/test_integration.py -v
+
+# Test especifico
+pytest tests/test_e2e_flows.py::test_vip_flow_complete -v
+
+# Script helper (limpia BD y ejecuta tests)
+bash scripts/run_tests.sh
+```
+
+### Tests Disponibles
+
+**End-to-End (E2E):**
+- `test_vip_flow_complete` - Flujo VIP completo (generar token ‚Üí canjear ‚Üí acceso)
+- `test_free_flow_complete` - Flujo Free completo (solicitar ‚Üí esperar ‚Üí acceso)
+- `test_vip_expiration` - Expiracion automatica de VIP
+- `test_token_validation_edge_cases` - Validacion de tokens (casos edge)
+- `test_duplicate_free_request_prevention` - Prevencion de solicitudes duplicadas
+
+**Integracion:**
+- `test_service_container_lazy_loading` - Lazy loading de servicios
+- `test_config_service_singleton` - BotConfig como singleton
+- `test_database_session_management` - Manejo de sesiones de BD
+- `test_error_handling_across_services` - Error handling entre servicios
+
+Ver `tests/README.md` para documentacion completa.
+
 ## üîß Desarrollo
 
 Este proyecto est√° en desarrollo iterativo. Consulta las tareas completadas:
@@ -155,6 +1310,12 @@ Este proyecto est√° en desarrollo iterativo. Consulta las tareas completadas:
 - [x] T7: Subscription Service - Gesti√≥n completa de suscripciones VIP (tokens, validaci√≥n, canjes) y cola de acceso Free
 - [x] T8: Channel Service - Gesti√≥n completa de canales VIP y Free con verificaci√≥n de permisos y env√≠o de publicaciones
 - [x] T9: Config Service - Gesti√≥n de configuraci√≥n global del bot, tiempos de espera, reacciones y tarifas
+- [x] T10: Middlewares - Implementaci√≥n de AdminAuthMiddleware y DatabaseMiddleware para autenticaci√≥n de administradores e inyecci√≥n autom√°tica de sesiones de base de datos
+- [x] T11: FSM States - Implementaci√≥n de estados FSM para administradores y usuarios para flujos de configuraci√≥n y canje de tokens
+- [x] T12: Handler /admin (Men√∫ Principal) - Handler del comando /admin que muestra el men√∫ principal de administraci√≥n con navegaci√≥n, verificaci√≥n de estado de configuraci√≥n y teclado inline
+- [x] T13: Handlers VIP y Free - Submen√∫ VIP (gesti√≥n del canal VIP con generaci√≥n de tokens de invitaci√≥n), Configuraci√≥n del canal VIP (configuraci√≥n del canal VIP por reenv√≠o de mensajes), Generaci√≥n de tokens de invitaci√≥n (creaci√≥n de tokens VIP con duraci√≥n configurable), Submen√∫ Free (gesti√≥n del canal Free con configuraci√≥n de tiempo de espera), Configuraci√≥n del canal Free (configuraci√≥n del canal Free por reenv√≠o de mensajes), Configuraci√≥n de tiempo de espera (configuraci√≥n de tiempo de espera para acceso Free)
+- [x] T14: Handlers User (/start, flujos) - Handler /start con detecci√≥n de rol (admin/VIP/usuario), Flujo VIP (canje de tokens VIP con validaci√≥n y generaci√≥n de invite links), Flujo Free (solicitud de acceso Free con tiempo de espera y notificaciones autom√°ticas), Middleware de base de datos (inyecci√≥n de sesiones sin autenticaci√≥n de admin), FSM para validaci√≥n de tokens (estados para manejo de entrada de tokens), Validaci√≥n de configuraci√≥n (verificaci√≥n de canales configurados antes de procesar)
+- [x] T15: Background Tasks - Tareas programadas que expulsan VIPs expirados del canal, procesan la cola Free para enviar invite links a usuarios que completaron tiempo de espera, limpian datos antiguos y usan APScheduler con configuraci√≥n de intervalos mediante variables de entorno
 - [ ] ONDA 1: MVP Funcional (T1-T17)
 - [ ] ONDA 2: Features Avanzadas (T18-T33)
 - [ ] ONDA 3: Optimizaci√≥n (T34-T44)
diff --git a/bot/background/__init__.py b/bot/background/__init__.py
index e69de29..dda5f91 100644
--- a/bot/background/__init__.py
+++ b/bot/background/__init__.py
@@ -0,0 +1,16 @@
+"""
+Background Tasks - Module for automatic scheduled tasks.
+
+Exports functions to start and stop the scheduler.
+"""
+from bot.background.tasks import (
+    start_background_tasks,
+    stop_background_tasks,
+    get_scheduler_status
+)
+
+__all__ = [
+    "start_background_tasks",
+    "stop_background_tasks",
+    "get_scheduler_status"
+]
diff --git a/bot/background/tasks.py b/bot/background/tasks.py
new file mode 100644
index 0000000..9a46a41
--- /dev/null
+++ b/bot/background/tasks.py
@@ -0,0 +1,318 @@
+"""
+Background Tasks - Tareas programadas autom√°ticas.
+
+Tareas:
+- Expulsi√≥n de VIPs expirados del canal
+- Procesamiento de cola Free (env√≠o de invite links)
+- Limpieza de datos antiguos
+"""
+import logging
+from typing import Optional
+
+from aiogram import Bot
+from apscheduler.schedulers.asyncio import AsyncIOScheduler
+from apscheduler.triggers.interval import IntervalTrigger
+from apscheduler.triggers.cron import CronTrigger
+
+from bot.database import get_session
+from bot.services.container import ServiceContainer
+from config import Config
+
+logger = logging.getLogger(__name__)
+
+# Scheduler global
+_scheduler: Optional[AsyncIOScheduler] = None
+
+
+async def expire_and_kick_vip_subscribers(bot: Bot):
+    """
+    Tarea: Expulsar suscriptores VIP expirados del canal.
+
+    Proceso:
+    1. Marca como expirados los suscriptores cuya fecha pas√≥
+    2. Expulsa del canal VIP a los expirados
+    3. Loguea resultados
+
+    Args:
+        bot: Instancia del bot de Telegram
+    """
+    logger.info("üîÑ Ejecutando tarea: Expulsi√≥n VIP expirados")
+
+    try:
+        async with get_session() as session:
+            container = ServiceContainer(session, bot)
+
+            # Verificar que canal VIP est√° configurado
+            vip_channel_id = await container.channel.get_vip_channel_id()
+
+            if not vip_channel_id:
+                logger.warning("‚ö†Ô∏è Canal VIP no configurado, saltando expulsi√≥n")
+                return
+
+            # Marcar como expirados
+            expired_count = await container.subscription.expire_vip_subscribers()
+
+            if expired_count > 0:
+                logger.info(f"‚è±Ô∏è {expired_count} suscriptor(es) VIP expirados")
+
+                # Expulsar del canal
+                kicked_count = await container.subscription.kick_expired_vip_from_channel(
+                    vip_channel_id
+                )
+
+                logger.info(f"‚úÖ {kicked_count} usuario(s) expulsados del canal VIP")
+            else:
+                logger.debug("‚úì No hay VIPs expirados")
+
+    except Exception as e:
+        logger.error(f"‚ùå Error en tarea de expulsi√≥n VIP: {e}", exc_info=True)
+
+
+async def process_free_queue(bot: Bot):
+    """
+    Tarea: Procesar cola de solicitudes Free.
+
+    Proceso:
+    1. Busca solicitudes que cumplieron el tiempo de espera
+    2. Para cada solicitud:
+       - Marca como procesada
+       - Crea invite link
+       - Env√≠a link al usuario por mensaje privado
+    3. Loguea resultados
+
+    Args:
+        bot: Instancia del bot de Telegram
+    """
+    logger.info("üîÑ Ejecutando tarea: Procesamiento cola Free")
+
+    try:
+        async with get_session() as session:
+            container = ServiceContainer(session, bot)
+
+            # Verificar que canal Free est√° configurado
+            free_channel_id = await container.channel.get_free_channel_id()
+
+            if not free_channel_id:
+                logger.warning("‚ö†Ô∏è Canal Free no configurado, saltando procesamiento")
+                return
+
+            # Obtener tiempo de espera configurado
+            wait_time = await container.config.get_wait_time()
+
+            # Buscar solicitudes listas para procesar
+            ready_requests = await container.subscription.process_free_queue(wait_time)
+
+            if not ready_requests:
+                logger.debug("‚úì No hay solicitudes Free listas")
+                return
+
+            logger.info(f"üìã Procesando {len(ready_requests)} solicitud(es) Free")
+
+            # Procesar cada solicitud
+            success_count = 0
+            error_count = 0
+
+            for request in ready_requests:
+                user_id = request.user_id
+
+                try:
+                    # Crear invite link personal
+                    invite_link = await container.subscription.create_invite_link(
+                        channel_id=free_channel_id,
+                        user_id=user_id,
+                        expire_hours=24  # Link Free v√°lido por 24 horas
+                    )
+
+                    # Enviar link al usuario por mensaje privado
+                    message_text = (
+                        f"‚úÖ <b>¬°Tu Acceso Free est√° Listo!</b>\n\n"
+                        f"Has esperado {wait_time} minutos como se requiere.\n\n"
+                        f"üëá Usa este link para unirte al canal Free:\n"
+                        f"{invite_link.invite_link}\n\n"
+                        f"‚ö†Ô∏è <b>Importante:</b>\n"
+                        f"‚Ä¢ El link expira en 24 horas\n"
+                        f"‚Ä¢ Solo puedes usarlo 1 vez\n"
+                        f"‚Ä¢ No lo compartas con otros\n\n"
+                        f"Disfruta del contenido! üéâ"
+                    )
+
+                    await bot.send_message(
+                        chat_id=user_id,
+                        text=message_text,
+                        parse_mode="HTML"
+                    )
+
+                    success_count += 1
+                    logger.info(f"‚úÖ Link Free enviado a user {user_id}")
+
+                except Exception as e:
+                    error_count += 1
+                    logger.error(
+                        f"‚ùå Error enviando link Free a user {user_id}: {e}",
+                        exc_info=True
+                    )
+                    # Continuar con siguiente usuario
+
+            logger.info(
+                f"‚úÖ Cola Free procesada: {success_count} √©xitos, {error_count} errores"
+            )
+
+    except Exception as e:
+        logger.error(f"‚ùå Error en tarea de procesamiento Free: {e}", exc_info=True)
+
+
+async def cleanup_old_data(bot: Bot):
+    """
+    Tarea: Limpieza de datos antiguos.
+
+    Proceso:
+    1. Elimina solicitudes Free procesadas hace m√°s de 30 d√≠as
+    2. (Futuro: Limpiar tokens expirados muy antiguos)
+
+    Args:
+        bot: Instancia del bot
+    """
+    logger.info("üîÑ Ejecutando tarea: Limpieza de datos antiguos")
+
+    try:
+        async with get_session() as session:
+            container = ServiceContainer(session, bot)
+
+            # Limpiar solicitudes Free antiguas
+            deleted_count = await container.subscription.cleanup_old_free_requests(
+                days_old=30
+            )
+
+            if deleted_count > 0:
+                logger.info(f"üóëÔ∏è {deleted_count} solicitud(es) Free antiguas eliminadas")
+            else:
+                logger.debug("‚úì No hay datos antiguos para limpiar")
+
+    except Exception as e:
+        logger.error(f"‚ùå Error en tarea de limpieza: {e}", exc_info=True)
+
+
+def start_background_tasks(bot: Bot):
+    """
+    Inicia el scheduler con todas las tareas programadas.
+
+    Configuraci√≥n:
+    - Expulsi√≥n VIP: Cada 60 minutos (configurable)
+    - Procesamiento Free: Cada 5 minutos (o seg√∫n wait_time)
+    - Limpieza: Cada 24 horas (diaria a las 3 AM)
+
+    Args:
+        bot: Instancia del bot de Telegram
+    """
+    global _scheduler
+
+    if _scheduler is not None:
+        logger.warning("‚ö†Ô∏è Scheduler ya est√° corriendo")
+        return
+
+    logger.info("üöÄ Iniciando background tasks...")
+
+    _scheduler = AsyncIOScheduler(timezone="UTC")
+
+    # Tarea 1: Expulsi√≥n VIP expirados
+    # Frecuencia: Cada 60 minutos (Config.CLEANUP_INTERVAL_MINUTES)
+    _scheduler.add_job(
+        expire_and_kick_vip_subscribers,
+        trigger=IntervalTrigger(minutes=Config.CLEANUP_INTERVAL_MINUTES),
+        args=[bot],
+        id="expire_vip",
+        name="Expulsar VIPs expirados",
+        replace_existing=True,
+        max_instances=1  # No permitir m√∫ltiples instancias simult√°neas
+    )
+    logger.info(
+        f"‚úÖ Tarea programada: Expulsi√≥n VIP (cada {Config.CLEANUP_INTERVAL_MINUTES} min)"
+    )
+
+    # Tarea 2: Procesamiento cola Free
+    # Frecuencia: Cada 5 minutos (Config.PROCESS_FREE_QUEUE_MINUTES)
+    _scheduler.add_job(
+        process_free_queue,
+        trigger=IntervalTrigger(minutes=Config.PROCESS_FREE_QUEUE_MINUTES),
+        args=[bot],
+        id="process_free_queue",
+        name="Procesar cola Free",
+        replace_existing=True,
+        max_instances=1
+    )
+    logger.info(
+        f"‚úÖ Tarea programada: Cola Free (cada {Config.PROCESS_FREE_QUEUE_MINUTES} min)"
+    )
+
+    # Tarea 3: Limpieza de datos antiguos
+    # Frecuencia: Diaria a las 3 AM UTC
+    _scheduler.add_job(
+        cleanup_old_data,
+        trigger=CronTrigger(hour=3, minute=0, timezone="UTC"),
+        args=[bot],
+        id="cleanup_old_data",
+        name="Limpieza de datos antiguos",
+        replace_existing=True,
+        max_instances=1
+    )
+    logger.info("‚úÖ Tarea programada: Limpieza (diaria 3 AM UTC)")
+
+    # Iniciar scheduler
+    _scheduler.start()
+    logger.info("‚úÖ Background tasks iniciados correctamente")
+
+
+def stop_background_tasks():
+    """
+    Detiene el scheduler y todas las tareas programadas.
+
+    Debe llamarse en el shutdown del bot para cleanup limpio.
+    """
+    global _scheduler
+
+    if _scheduler is None:
+        logger.warning("‚ö†Ô∏è Scheduler no est√° corriendo")
+        return
+
+    logger.info("üõë Deteniendo background tasks...")
+
+    _scheduler.shutdown(wait=True)
+    _scheduler = None
+
+    logger.info("‚úÖ Background tasks detenidos correctamente")
+
+
+def get_scheduler_status() -> dict:
+    """
+    Obtiene el estado actual del scheduler.
+
+    √ötil para dashboard admin (ONDA 2).
+
+    Returns:
+        Dict con informaci√≥n del scheduler:
+        {
+            "running": bool,
+            "jobs_count": int,
+            "jobs": List[dict]
+        }
+    """
+    if _scheduler is None:
+        return {
+            "running": False,
+            "jobs_count": 0,
+            "jobs": []
+        }
+
+    jobs_info = []
+    for job in _scheduler.get_jobs():
+        jobs_info.append({
+            "id": job.id,
+            "name": job.name,
+            "next_run": job.next_run_time.isoformat() if job.next_run_time else None
+        })
+
+    return {
+        "running": True,
+        "jobs_count": len(jobs_info),
+        "jobs": jobs_info
+    }
diff --git a/bot/handlers/admin/__init__.py b/bot/handlers/admin/__init__.py
index e69de29..32db3cd 100644
--- a/bot/handlers/admin/__init__.py
+++ b/bot/handlers/admin/__init__.py
@@ -0,0 +1,7 @@
+"""
+Admin handlers module.
+"""
+from bot.handlers.admin.main import admin_router
+from bot.handlers.admin import vip, free
+
+__all__ = ["admin_router", "vip", "free"]
diff --git a/bot/handlers/admin/free.py b/bot/handlers/admin/free.py
new file mode 100644
index 0000000..9bac1ad
--- /dev/null
+++ b/bot/handlers/admin/free.py
@@ -0,0 +1,309 @@
+"""
+Free Handlers - Gesti√≥n del canal Free.
+
+Handlers para:
+- Submen√∫ Free
+- Configuraci√≥n del canal Free
+- Configuraci√≥n de tiempo de espera
+"""
+import logging
+from aiogram import F
+from aiogram.types import CallbackQuery, Message
+from aiogram.fsm.context import FSMContext
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.handlers.admin.main import admin_router
+from bot.states.admin import ChannelSetupStates, WaitTimeSetupStates
+from bot.services.container import ServiceContainer
+from bot.utils.keyboards import create_inline_keyboard
+
+logger = logging.getLogger(__name__)
+
+
+def free_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ Free.
+
+    Args:
+        is_configured: Si el canal Free est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones Free
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "‚è±Ô∏è Configurar Tiempo de Espera", "callback_data": "free:set_wait_time"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "free:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal Free", "callback_data": "free:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+
+
+@admin_router.callback_query(F.data == "admin:free")
+async def callback_free_menu(callback: CallbackQuery, session: AsyncSession):
+    """
+    Muestra el submen√∫ de gesti√≥n Free.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.debug(f"üì∫ Usuario {callback.from_user.id} abri√≥ men√∫ Free")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar si canal Free est√° configurado
+    is_configured = await container.channel.is_free_channel_configured()
+
+    if is_configured:
+        free_channel_id = await container.channel.get_free_channel_id()
+        wait_time = await container.config.get_wait_time()
+
+        # Obtener info del canal
+        channel_info = await container.channel.get_channel_info(free_channel_id)
+        channel_name = channel_info.title if channel_info else "Canal Free"
+
+        text = (
+            f"üì∫ <b>Gesti√≥n Canal Free</b>\n\n"
+            f"‚úÖ Canal configurado: <b>{channel_name}</b>\n"
+            f"ID: <code>{free_channel_id}</code>\n\n"
+            f"‚è±Ô∏è Tiempo de espera: <b>{wait_time} minutos</b>\n\n"
+            f"Selecciona una opci√≥n:"
+        )
+    else:
+        text = (
+            "üì∫ <b>Gesti√≥n Canal Free</b>\n\n"
+            "‚ö†Ô∏è Canal Free no configurado\n\n"
+            "Configura el canal para que usuarios puedan solicitar acceso."
+        )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=free_menu_keyboard(is_configured),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje Free: {e}")
+
+    await callback.answer()
+
+
+@admin_router.callback_query(F.data == "free:setup")
+async def callback_free_setup(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el proceso de configuraci√≥n del canal Free.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚öôÔ∏è Usuario {callback.from_user.id} iniciando setup Free")
+
+    # Entrar en estado FSM
+    await state.set_state(ChannelSetupStates.waiting_for_free_channel)
+
+    text = (
+        "‚öôÔ∏è <b>Configurar Canal Free</b>\n\n"
+        "Para configurar el canal Free:\n\n"
+        "1Ô∏è‚É£ Vayas al canal Free\n"
+        "2Ô∏è‚É£ Reenv√≠es cualquier mensaje del canal a este chat\n"
+        "3Ô∏è‚É£ Yo extraer√© el ID autom√°ticamente\n\n"
+        "‚ö†Ô∏è <b>Importante:</b>\n"
+        "- El bot debe ser administrador del canal\n"
+        "- El bot debe tener permiso para invitar usuarios\n\n"
+        "üëâ Reenv√≠a un mensaje del canal ahora..."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje setup Free: {e}")
+
+    await callback.answer()
+
+
+@admin_router.message(ChannelSetupStates.waiting_for_free_channel)
+async def process_free_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal Free.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Validaciones id√©nticas a VIP
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal Free.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal Free.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal Free: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_free_channel(channel_id)
+
+    if success:
+        await message.answer(
+            f"‚úÖ <b>Canal Free Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Los usuarios ya pueden solicitar acceso.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        await state.clear()
+    else:
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica permisos del bot e intenta nuevamente.",
+            parse_mode="HTML"
+        )
+
+
+@admin_router.callback_query(F.data == "free:set_wait_time")
+async def callback_set_wait_time(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia configuraci√≥n de tiempo de espera.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚è±Ô∏è Usuario {callback.from_user.id} configurando wait time")
+
+    container = ServiceContainer(session, callback.bot)
+    current_wait_time = await container.config.get_wait_time()
+
+    # Entrar en estado FSM
+    await state.set_state(WaitTimeSetupStates.waiting_for_minutes)
+
+    text = (
+        f"‚è±Ô∏è <b>Configurar Tiempo de Espera</b>\n\n"
+        f"Tiempo actual: <b>{current_wait_time} minutos</b>\n\n"
+        f"Env√≠a el nuevo tiempo de espera en minutos.\n"
+        f"Ejemplo: <code>5</code>\n\n"
+        f"El tiempo debe ser mayor o igual a 1 minuto."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje wait time: {e}")
+
+    await callback.answer()
+
+
+@admin_router.message(WaitTimeSetupStates.waiting_for_minutes)
+async def process_wait_time_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el input de tiempo de espera.
+
+    Args:
+        message: Mensaje con los minutos
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Intentar convertir a n√∫mero
+    try:
+        minutes = int(message.text)
+    except ValueError:
+        await message.answer(
+            "‚ùå Debes enviar un n√∫mero v√°lido.\n\n"
+            "Ejemplo: <code>5</code>",
+            parse_mode="HTML"
+        )
+        return
+
+    # Validar rango
+    if minutes < 1:
+        await message.answer(
+            "‚ùå El tiempo debe ser al menos 1 minuto.\n\n"
+            "Env√≠a un n√∫mero mayor o igual a 1.",
+            parse_mode="HTML"
+        )
+        return
+
+    container = ServiceContainer(session, message.bot)
+
+    try:
+        # Actualizar configuraci√≥n
+        await container.config.set_wait_time(minutes)
+
+        await message.answer(
+            f"‚úÖ <b>Tiempo de Espera Actualizado</b>\n\n"
+            f"Nuevo tiempo: <b>{minutes} minutos</b>\n\n"
+            f"Las nuevas solicitudes esperar√°n {minutes} minutos antes de procesarse.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error actualizando wait time: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al actualizar el tiempo de espera.\n\n"
+            "Intenta nuevamente.",
+            parse_mode="HTML"
+        )
diff --git a/bot/handlers/admin/main.py b/bot/handlers/admin/main.py
new file mode 100644
index 0000000..437f239
--- /dev/null
+++ b/bot/handlers/admin/main.py
@@ -0,0 +1,156 @@
+"""
+Admin Main Handler - Men√∫ principal de administraci√≥n.
+
+Handler del comando /admin y navegaci√≥n del men√∫ principal.
+"""
+import logging
+from aiogram import Router, F
+from aiogram.filters import Command
+from aiogram.types import Message, CallbackQuery
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares import AdminAuthMiddleware, DatabaseMiddleware
+from bot.utils.keyboards import admin_main_menu_keyboard, back_to_main_menu_keyboard
+from bot.services.container import ServiceContainer
+
+logger = logging.getLogger(__name__)
+
+# Router para handlers de admin
+admin_router = Router(name="admin")
+
+# Aplicar middlewares (orden correcto: Database primero, AdminAuth despu√©s)
+admin_router.message.middleware(DatabaseMiddleware())
+admin_router.message.middleware(AdminAuthMiddleware())
+admin_router.callback_query.middleware(DatabaseMiddleware())
+admin_router.callback_query.middleware(AdminAuthMiddleware())
+
+
+@admin_router.message(Command("admin"))
+async def cmd_admin(message: Message, session: AsyncSession):
+    """
+    Handler del comando /admin.
+
+    Muestra el men√∫ principal de administraci√≥n con estado de configuraci√≥n.
+
+    Args:
+        message: Mensaje del usuario
+        session: Sesi√≥n de BD (inyectada por middleware)
+    """
+    logger.info(f"üìã Admin panel abierto por user {message.from_user.id}")
+
+    # Crear container de services
+    container = ServiceContainer(session, message.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    await message.answer(
+        text=text,
+        reply_markup=admin_main_menu_keyboard(),
+        parse_mode="HTML"
+    )
+
+
+@admin_router.callback_query(F.data == "admin:main")
+async def callback_admin_main(callback: CallbackQuery, session: AsyncSession):
+    """
+    Handler del callback para volver al men√∫ principal.
+
+    Se activa cuando usuario presiona "üîô Volver al Men√∫ Principal"
+    desde cualquier submen√∫.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD (inyectada por middleware)
+    """
+    logger.debug(f"‚Ü©Ô∏è Usuario {callback.from_user.id} volvi√≥ al men√∫ principal")
+
+    # Crear container de services
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫ (mismo que cmd_admin)
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    # Editar mensaje existente (no enviar nuevo)
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=admin_main_menu_keyboard(),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        # Si el mensaje es igual, Telegram lanza error (es esperado)
+        if "message is not modified" not in str(e):
+            logger.error(f"‚ùå Error editando mensaje: {e}")
+        else:
+            logger.debug("‚ÑπÔ∏è Mensaje sin cambios, ignorando")
+
+    # Responder al callback (quitar "loading" del bot√≥n)
+    await callback.answer()
+
+
+@admin_router.callback_query(F.data == "admin:config")
+async def callback_admin_config(callback: CallbackQuery, session: AsyncSession):
+    """
+    Handler para mostrar estado de configuraci√≥n.
+
+    Muestra resumen detallado de la configuraci√≥n actual del bot.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.debug(f"‚öôÔ∏è Usuario {callback.from_user.id} abri√≥ configuraci√≥n")
+
+    # Crear container de services
+    container = ServiceContainer(session, callback.bot)
+
+    # Obtener resumen de configuraci√≥n
+    summary = await container.config.get_config_summary()
+
+    # Editar mensaje con resumen
+    try:
+        await callback.message.edit_text(
+            text=summary,
+            reply_markup=back_to_main_menu_keyboard(),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"‚ùå Error editando mensaje de config: {e}")
+        else:
+            logger.debug("‚ÑπÔ∏è Mensaje sin cambios, ignorando")
+
+    await callback.answer()
diff --git a/bot/handlers/admin/vip.py b/bot/handlers/admin/vip.py
new file mode 100644
index 0000000..1abfff6
--- /dev/null
+++ b/bot/handlers/admin/vip.py
@@ -0,0 +1,273 @@
+"""
+VIP Handlers - Gesti√≥n del canal VIP.
+
+Handlers para:
+- Submen√∫ VIP
+- Configuraci√≥n del canal VIP
+- Generaci√≥n de tokens de invitaci√≥n
+"""
+import logging
+from aiogram import F
+from aiogram.types import CallbackQuery, Message
+from aiogram.fsm.context import FSMContext
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.handlers.admin.main import admin_router
+from bot.states.admin import ChannelSetupStates
+from bot.services.container import ServiceContainer
+from bot.utils.keyboards import create_inline_keyboard
+from config import Config
+
+logger = logging.getLogger(__name__)
+
+
+def vip_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ VIP.
+
+    Args:
+        is_configured: Si el canal VIP est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones VIP
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "üéüÔ∏è Generar Token de Invitaci√≥n", "callback_data": "vip:generate_token"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "vip:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal VIP", "callback_data": "vip:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+
+
+@admin_router.callback_query(F.data == "admin:vip")
+async def callback_vip_menu(callback: CallbackQuery, session: AsyncSession):
+    """
+    Muestra el submen√∫ de gesti√≥n VIP.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD (inyectada por middleware)
+    """
+    logger.debug(f"üì∫ Usuario {callback.from_user.id} abri√≥ men√∫ VIP")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar si canal VIP est√° configurado
+    is_configured = await container.channel.is_vip_channel_configured()
+
+    if is_configured:
+        vip_channel_id = await container.channel.get_vip_channel_id()
+
+        # Obtener info del canal
+        channel_info = await container.channel.get_channel_info(vip_channel_id)
+        channel_name = channel_info.title if channel_info else "Canal VIP"
+
+        text = (
+            f"üì∫ <b>Gesti√≥n Canal VIP</b>\n\n"
+            f"‚úÖ Canal configurado: <b>{channel_name}</b>\n"
+            f"ID: <code>{vip_channel_id}</code>\n\n"
+            f"Selecciona una opci√≥n:"
+        )
+    else:
+        text = (
+            "üì∫ <b>Gesti√≥n Canal VIP</b>\n\n"
+            "‚ö†Ô∏è Canal VIP no configurado\n\n"
+            "Configura el canal para comenzar a generar tokens de invitaci√≥n."
+        )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=vip_menu_keyboard(is_configured),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje VIP: {e}")
+
+    await callback.answer()
+
+
+@admin_router.callback_query(F.data == "vip:setup")
+async def callback_vip_setup(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el proceso de configuraci√≥n del canal VIP.
+
+    Entra en estado FSM esperando que el admin reenv√≠e un mensaje del canal.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚öôÔ∏è Usuario {callback.from_user.id} iniciando setup VIP")
+
+    # Entrar en estado FSM
+    await state.set_state(ChannelSetupStates.waiting_for_vip_channel)
+
+    text = (
+        "‚öôÔ∏è <b>Configurar Canal VIP</b>\n\n"
+        "Para configurar el canal VIP, necesito que:\n\n"
+        "1Ô∏è‚É£ Vayas al canal VIP\n"
+        "2Ô∏è‚É£ Reenv√≠es cualquier mensaje del canal a este chat\n"
+        "3Ô∏è‚É£ Yo extraer√© el ID autom√°ticamente\n\n"
+        "‚ö†Ô∏è <b>Importante:</b>\n"
+        "- El bot debe ser administrador del canal\n"
+        "- El bot debe tener permiso para invitar usuarios\n\n"
+        "üëâ Reenv√≠a un mensaje del canal ahora..."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:vip"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje setup VIP: {e}")
+
+    await callback.answer()
+
+
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def process_vip_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal VIP.
+
+    Extrae el ID del canal del forward y lo configura.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Verificar que es un forward de un canal
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal VIP.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    # Verificar que es un canal (no grupo ni usuario)
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal VIP.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal VIP: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_vip_channel(channel_id)
+
+    if success:
+        # Configuraci√≥n exitosa
+        await message.answer(
+            f"‚úÖ <b>Canal VIP Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Ya puedes generar tokens de invitaci√≥n.",
+            parse_mode="HTML",
+            reply_markup=vip_menu_keyboard(True)
+        )
+
+        # Limpiar estado FSM
+        await state.clear()
+    else:
+        # Error en configuraci√≥n
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica que:\n"
+            f"‚Ä¢ El bot es administrador del canal\n"
+            f"‚Ä¢ El bot tiene permiso para invitar usuarios\n\n"
+            f"Intenta nuevamente reenviando un mensaje del canal.",
+            parse_mode="HTML"
+        )
+        # Mantener estado FSM para reintentar
+
+
+@admin_router.callback_query(F.data == "vip:generate_token")
+async def callback_generate_vip_token(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Genera un token de invitaci√≥n VIP.
+
+    Token v√°lido por 24 horas, un solo uso.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.info(f"üéüÔ∏è Usuario {callback.from_user.id} generando token VIP")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal VIP est√° configurado
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ùå Debes configurar el canal VIP primero",
+            show_alert=True
+        )
+        return
+
+    try:
+        # Generar token (24 horas por defecto)
+        token = await container.subscription.generate_vip_token(
+            generated_by=callback.from_user.id,
+            duration_hours=Config.DEFAULT_TOKEN_DURATION_HOURS
+        )
+
+        # Crear mensaje con el token
+        token_message = (
+            f"üéüÔ∏è <b>Token VIP Generado</b>\n\n"
+            f"Token: <code>{token.token}</code>\n\n"
+            f"‚è±Ô∏è V√°lido por: {token.duration_hours} horas\n"
+            f"üìÖ Expira: {token.created_at.strftime('%Y-%m-%d %H:%M')} UTC\n\n"
+            f"üëâ Comparte este token con el usuario.\n"
+            f"El usuario debe enviarlo al bot para canjear acceso VIP."
+        )
+
+        await callback.message.answer(
+            text=token_message,
+            parse_mode="HTML"
+        )
+
+        await callback.answer("‚úÖ Token generado")
+
+    except Exception as e:
+        logger.error(f"Error generando token VIP: {e}", exc_info=True)
+        await callback.answer(
+            "‚ùå Error al generar token. Intenta nuevamente.",
+            show_alert=True
+        )
diff --git a/bot/handlers/user/__init__.py b/bot/handlers/user/__init__.py
index e69de29..fc251c7 100644
--- a/bot/handlers/user/__init__.py
+++ b/bot/handlers/user/__init__.py
@@ -0,0 +1,6 @@
+"""
+User handlers module.
+"""
+from bot.handlers.user.start import user_router
+
+__all__ = ["user_router"]
diff --git a/bot/handlers/user/free_flow.py b/bot/handlers/user/free_flow.py
new file mode 100644
index 0000000..b938923
--- /dev/null
+++ b/bot/handlers/user/free_flow.py
@@ -0,0 +1,92 @@
+"""
+Free Flow Handler - Solicitud de acceso al canal Free.
+
+Flujo para que usuarios soliciten acceso Free y esperen aprobaci√≥n autom√°tica.
+"""
+import logging
+from aiogram import F
+from aiogram.types import CallbackQuery
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.handlers.user.start import user_router
+from bot.services.container import ServiceContainer
+
+logger = logging.getLogger(__name__)
+
+
+@user_router.callback_query(F.data == "user:request_free")
+async def callback_request_free(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Procesa solicitud de acceso al canal Free.
+
+    Crea la solicitud y notifica al usuario del tiempo de espera.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    user_id = callback.from_user.id
+    logger.info(f"üì∫ Usuario {user_id} solicitando acceso Free")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal Free est√° configurado
+    if not await container.channel.is_free_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal Free no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Verificar si ya tiene solicitud pendiente
+    existing_request = await container.subscription.get_free_request(user_id)
+
+    if existing_request:
+        # Calcular tiempo restante
+        from datetime import datetime, timezone, timedelta
+
+        wait_time_minutes = await container.config.get_wait_time()
+        time_since_request = (datetime.now(timezone.utc) - existing_request.request_date).total_seconds() / 60
+        minutes_remaining = max(0, int(wait_time_minutes - time_since_request))
+
+        try:
+            await callback.message.edit_text(
+                f"‚è±Ô∏è <b>Solicitud Pendiente</b>\n\n"
+                f"Ya tienes una solicitud en proceso.\n\n"
+                f"Tiempo transcurrido: <b>{int(time_since_request)} minutos</b>\n"
+                f"Tiempo restante: <b>{minutes_remaining} minutos</b>\n\n"
+                f"Recibir√°s el link de acceso autom√°ticamente cuando el tiempo se cumpla.\n\n"
+                f"üí° <i>Puedes cerrar este chat, te notificar√© cuando est√© listo.</i>",
+                parse_mode="HTML"
+            )
+        except Exception as e:
+            if "message is not modified" not in str(e):
+                logger.error(f"Error editando mensaje: {e}")
+
+        await callback.answer()
+        return
+
+    # Crear nueva solicitud
+    request = await container.subscription.create_free_request(user_id)
+    wait_time = await container.config.get_wait_time()
+
+    try:
+        await callback.message.edit_text(
+            f"‚úÖ <b>Solicitud Recibida</b>\n\n"
+            f"Tu solicitud de acceso al canal Free ha sido registrada.\n\n"
+            f"‚è±Ô∏è Tiempo de espera: <b>{wait_time} minutos</b>\n\n"
+            f"üì® Recibir√°s un mensaje con el link de invitaci√≥n cuando el tiempo se cumpla.\n\n"
+            f"üí° <i>No necesitas hacer nada m√°s, el proceso es autom√°tico.</i>\n\n"
+            f"Puedes cerrar este chat, te notificar√© cuando est√© listo! üîî",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer("‚úÖ Solicitud creada")
+
+    logger.info(f"‚úÖ Solicitud Free creada para user {user_id} (wait: {wait_time}min)")
diff --git a/bot/handlers/user/start.py b/bot/handlers/user/start.py
new file mode 100644
index 0000000..4b7eada
--- /dev/null
+++ b/bot/handlers/user/start.py
@@ -0,0 +1,97 @@
+"""
+User Start Handler - Punto de entrada para usuarios.
+
+Handler del comando /start que detecta si el usuario es admin o usuario normal.
+"""
+import logging
+from aiogram import Router
+from aiogram.filters import Command
+from aiogram.types import Message
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares import DatabaseMiddleware
+from bot.utils.keyboards import create_inline_keyboard
+from bot.services.container import ServiceContainer
+from config import Config
+
+logger = logging.getLogger(__name__)
+
+# Router para handlers de usuario
+user_router = Router(name="user")
+
+# Aplicar middleware de database (NO AdminAuth, estos son usuarios normales)
+user_router.message.middleware(DatabaseMiddleware())
+user_router.callback_query.middleware(DatabaseMiddleware())
+
+
+@user_router.message(Command("start"))
+async def cmd_start(message: Message, session: AsyncSession):
+    """
+    Handler del comando /start para usuarios.
+
+    Comportamiento:
+    - Si es admin ‚Üí Redirige a /admin
+    - Si es VIP activo ‚Üí Muestra mensaje de bienvenida con d√≠as restantes
+    - Si no es admin ‚Üí Muestra men√∫ de usuario (VIP/Free)
+
+    Args:
+        message: Mensaje del usuario
+        session: Sesi√≥n de BD (inyectada por middleware)
+    """
+    user_id = message.from_user.id
+    user_name = message.from_user.first_name or "Usuario"
+
+    logger.info(f"üëã Usuario {user_id} ({user_name}) ejecut√≥ /start")
+
+    # Verificar si es admin
+    if Config.is_admin(user_id):
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"Eres administrador. Usa /admin para gestionar los canales.",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario normal: verificar si es VIP activo
+    container = ServiceContainer(session, message.bot)
+
+    is_vip = await container.subscription.is_vip_active(user_id)
+
+    if is_vip:
+        # Usuario ya tiene acceso VIP
+        subscriber = await container.subscription.get_vip_subscriber(user_id)
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"‚úÖ Tienes acceso VIP activo\n"
+            f"‚è±Ô∏è D√≠as restantes: <b>{days_remaining}</b>\n\n"
+            f"Disfruta del contenido exclusivo! üéâ",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario no es VIP: mostrar opciones
+    keyboard = create_inline_keyboard([
+        [{"text": "üéüÔ∏è Canjear Token VIP", "callback_data": "user:redeem_token"}],
+        [{"text": "üì∫ Solicitar Acceso Free", "callback_data": "user:request_free"}],
+    ])
+
+    await message.answer(
+        f"üëã Hola <b>{user_name}</b>!\n\n"
+        f"Bienvenido al bot de acceso a canales.\n\n"
+        f"<b>Opciones disponibles:</b>\n\n"
+        f"üéüÔ∏è <b>Canjear Token VIP</b>\n"
+        f"Si tienes un token de invitaci√≥n, canj√©alo para acceso VIP.\n\n"
+        f"üì∫ <b>Solicitar Acceso Free</b>\n"
+        f"Solicita acceso al canal gratuito (con tiempo de espera).\n\n"
+        f"üëâ Selecciona una opci√≥n:",
+        reply_markup=keyboard,
+        parse_mode="HTML"
+    )
diff --git a/bot/handlers/user/vip_flow.py b/bot/handlers/user/vip_flow.py
new file mode 100644
index 0000000..8d2d4a9
--- /dev/null
+++ b/bot/handlers/user/vip_flow.py
@@ -0,0 +1,180 @@
+"""
+VIP Flow Handler - Canje de tokens de invitaci√≥n.
+
+Flujo para que usuarios canjeen tokens VIP y reciban invite link.
+"""
+import logging
+from aiogram import F
+from aiogram.types import CallbackQuery, Message
+from aiogram.fsm.context import FSMContext
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.handlers.user.start import user_router
+from bot.states.user import TokenRedemptionStates
+from bot.services.container import ServiceContainer
+from bot.utils.keyboards import create_inline_keyboard
+
+logger = logging.getLogger(__name__)
+
+
+@user_router.callback_query(F.data == "user:redeem_token")
+async def callback_redeem_token(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el flujo de canje de token VIP.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = callback.from_user.id
+    logger.info(f"üéüÔ∏è Usuario {user_id} iniciando canje de token")
+
+    # Verificar que canal VIP est√° configurado
+    container = ServiceContainer(session, callback.bot)
+
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal VIP no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Entrar en estado FSM
+    await state.set_state(TokenRedemptionStates.waiting_for_token)
+
+    try:
+        await callback.message.edit_text(
+            "üéüÔ∏è <b>Canjear Token VIP</b>\n\n"
+            "Por favor, env√≠a tu token de invitaci√≥n.\n\n"
+            "El token tiene este formato:\n"
+            "<code>A1b2C3d4E5f6G7h8</code>\n\n"
+            "üëâ Copia y pega tu token aqu√≠:",
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "user:cancel"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
+
+
+@user_router.message(TokenRedemptionStates.waiting_for_token)
+async def process_token_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el token enviado por el usuario.
+
+    Valida el token, lo canjea y env√≠a invite link.
+
+    Args:
+        message: Mensaje con el token
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = message.from_user.id
+    token_str = message.text.strip()
+
+    logger.info(f"üéüÔ∏è Usuario {user_id} canjeando token: {token_str[:8]}...")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar canjear token
+    success, msg, subscriber = await container.subscription.redeem_vip_token(
+        token_str=token_str,
+        user_id=user_id
+    )
+
+    if not success:
+        # Token inv√°lido
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica el token e intenta nuevamente.\n\n"
+            f"Si el problema persiste, contacta al administrador.",
+            parse_mode="HTML"
+        )
+        # Mantener estado para reintentar
+        return
+
+    # Token v√°lido: crear invite link
+    vip_channel_id = await container.channel.get_vip_channel_id()
+
+    try:
+        invite_link = await container.subscription.create_invite_link(
+            channel_id=vip_channel_id,
+            user_id=user_id,
+            expire_hours=1  # Link expira en 1 hora
+        )
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"‚úÖ <b>Token Canjeado Exitosamente!</b>\n\n"
+            f"üéâ Tu acceso VIP est√° activo\n"
+            f"‚è±Ô∏è Duraci√≥n: <b>{days_remaining} d√≠as</b>\n\n"
+            f"üëá Usa este link para unirte al canal VIP:\n"
+            f"{invite_link.invite_link}\n\n"
+            f"‚ö†Ô∏è <b>Importante:</b>\n"
+            f"‚Ä¢ El link expira en 1 hora\n"
+            f"‚Ä¢ Solo puedes usarlo 1 vez\n"
+            f"‚Ä¢ No lo compartas con otros\n\n"
+            f"Disfruta del contenido exclusivo! üöÄ",
+            parse_mode="HTML"
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+        logger.info(f"‚úÖ Usuario {user_id} obtuvo acceso VIP ({days_remaining} d√≠as)")
+
+    except Exception as e:
+        logger.error(f"Error creando invite link para user {user_id}: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al crear el link de invitaci√≥n.\n\n"
+            "Tu token fue canjeado correctamente, pero hubo un problema t√©cnico.\n"
+            "Contacta al administrador.",
+            parse_mode="HTML"
+        )
+        await state.clear()
+
+
+@user_router.callback_query(F.data == "user:cancel")
+async def callback_cancel(
+    callback: CallbackQuery,
+    state: FSMContext
+):
+    """
+    Cancela el flujo actual y limpia estado FSM.
+
+    Args:
+        callback: Callback query
+        state: FSM context
+    """
+    await state.clear()
+
+    try:
+        await callback.message.edit_text(
+            "‚ùå Operaci√≥n cancelada.\n\n"
+            "Usa /start para volver al men√∫ principal.",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
diff --git a/bot/middlewares/__init__.py b/bot/middlewares/__init__.py
index e69de29..2fef856 100644
--- a/bot/middlewares/__init__.py
+++ b/bot/middlewares/__init__.py
@@ -0,0 +1,10 @@
+"""
+Middlewares module - Procesamiento pre/post handlers.
+"""
+from bot.middlewares.admin_auth import AdminAuthMiddleware
+from bot.middlewares.database import DatabaseMiddleware
+
+__all__ = [
+    "AdminAuthMiddleware",
+    "DatabaseMiddleware",
+]
diff --git a/bot/middlewares/admin_auth.py b/bot/middlewares/admin_auth.py
new file mode 100644
index 0000000..10aede0
--- /dev/null
+++ b/bot/middlewares/admin_auth.py
@@ -0,0 +1,102 @@
+"""
+Admin Auth Middleware - Valida que el usuario tenga permisos de admin.
+
+Se aplica a handlers que requieren permisos administrativos.
+Si el usuario no es admin, responde con mensaje de error y no ejecuta el handler.
+"""
+import logging
+from typing import Callable, Dict, Any, Awaitable
+
+from aiogram import BaseMiddleware
+from aiogram.types import Message, CallbackQuery, TelegramObject
+
+from config import Config
+
+logger = logging.getLogger(__name__)
+
+
+def is_admin(user_id: int) -> bool:
+    """Verifica si un usuario es administrador.
+
+    Args:
+        user_id: ID de usuario de Telegram a verificar
+
+    Returns:
+        True si el usuario es administrador, False en caso contrario
+    """
+    return Config.is_admin(user_id)
+
+
+class AdminAuthMiddleware(BaseMiddleware):
+    """
+    Middleware que valida permisos de administrador.
+
+    Uso:
+        # En el router de admin:
+        admin_router.message.middleware(AdminAuthMiddleware())
+        admin_router.callback_query.middleware(AdminAuthMiddleware())
+
+    Si el usuario no es admin:
+    - Env√≠a mensaje de error
+    - No ejecuta el handler
+    - Loguea el intento
+    """
+
+    async def __call__(
+        self,
+        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
+        event: TelegramObject,
+        data: Dict[str, Any]
+    ) -> Any:
+        """
+        Ejecuta el middleware.
+
+        Args:
+            handler: Handler a ejecutar si pasa validaci√≥n
+            event: Evento de Telegram (Message, CallbackQuery, etc)
+            data: Data del handler (incluye bot, session, etc)
+
+        Returns:
+            Resultado del handler si es admin, None si no
+        """
+        # Extraer user del event
+        user = None
+
+        if isinstance(event, Message):
+            user = event.from_user
+        elif isinstance(event, CallbackQuery):
+            user = event.from_user
+
+        if user is None:
+            # No se pudo extraer usuario (edge case raro)
+            logger.warning("‚ö†Ô∏è No se pudo extraer usuario del evento")
+            return await handler(event, data)
+
+        # Verificar si es admin
+        if not Config.is_admin(user.id):
+            # Usuario no es admin
+            logger.warning(
+                f"üö´ Acceso denegado: user {user.id} (@{user.username or 'sin username'}) "
+                f"intent√≥ acceder a handler admin"
+            )
+
+            # Enviar mensaje de error
+            error_message = (
+                "üö´ <b>Acceso Denegado</b>\n\n"
+                "Este comando es solo para administradores."
+            )
+
+            if isinstance(event, Message):
+                await event.answer(error_message, parse_mode="HTML")
+            elif isinstance(event, CallbackQuery):
+                await event.answer(
+                    "üö´ Acceso denegado: solo administradores",
+                    show_alert=True
+                )
+
+            # No ejecutar handler
+            return None
+
+        # Usuario es admin: ejecutar handler normalmente
+        logger.debug(f"‚úÖ Admin verificado: user {user.id}")
+        return await handler(event, data)
diff --git a/bot/middlewares/database.py b/bot/middlewares/database.py
new file mode 100644
index 0000000..7b3931e
--- /dev/null
+++ b/bot/middlewares/database.py
@@ -0,0 +1,70 @@
+"""
+Database Middleware - Inyecta sesi√≥n de base de datos en handlers.
+
+Proporciona una sesi√≥n de SQLAlchemy a cada handler autom√°ticamente.
+"""
+import logging
+from typing import Callable, Dict, Any, Awaitable
+
+from aiogram import BaseMiddleware
+from aiogram.types import TelegramObject
+
+from bot.database import get_session
+
+logger = logging.getLogger(__name__)
+
+
+def get_db_session():
+    """Obtiene una sesi√≥n de base de datos para su uso en handlers.
+
+    Returns:
+        Context manager para una sesi√≥n de base de datos
+    """
+    return get_session()
+
+
+class DatabaseMiddleware(BaseMiddleware):
+    """
+    Middleware que inyecta sesi√≥n de base de datos.
+
+    Uso:
+        dispatcher.update.middleware(DatabaseMiddleware())
+
+    El handler recibe autom√°ticamente:
+        async def handler(message: Message, session: AsyncSession):
+            # session est√° disponible
+            pass
+    """
+
+    async def __call__(
+        self,
+        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
+        event: TelegramObject,
+        data: Dict[str, Any]
+    ) -> Any:
+        """
+        Ejecuta el middleware.
+
+        Crea una sesi√≥n de base de datos y la inyecta en data["session"].
+        El handler puede acceder a ella como par√°metro.
+
+        Args:
+            handler: Handler a ejecutar
+            event: Evento de Telegram
+            data: Data del handler
+
+        Returns:
+            Resultado del handler
+        """
+        # Crear sesi√≥n y ejecutar handler dentro del contexto
+        async with get_session() as session:
+            # Inyectar sesi√≥n en data
+            data["session"] = session
+
+            try:
+                # Ejecutar handler
+                return await handler(event, data)
+            except Exception as e:
+                # Loguear error pero dejar que se propague
+                logger.error(f"‚ùå Error en handler con sesi√≥n DB: {e}", exc_info=True)
+                raise
diff --git a/bot/states/__init__.py b/bot/states/__init__.py
index e69de29..197ea95 100644
--- a/bot/states/__init__.py
+++ b/bot/states/__init__.py
@@ -0,0 +1,23 @@
+"""
+States module - FSM states para flujos multi-paso.
+"""
+from bot.states.admin import (
+    ChannelSetupStates,
+    WaitTimeSetupStates,
+    BroadcastStates
+)
+from bot.states.user import (
+    TokenRedemptionStates,
+    FreeAccessStates
+)
+
+__all__ = [
+    # Admin states
+    "ChannelSetupStates",
+    "WaitTimeSetupStates",
+    "BroadcastStates",
+
+    # User states
+    "TokenRedemptionStates",
+    "FreeAccessStates",
+]
diff --git a/bot/states/admin.py b/bot/states/admin.py
new file mode 100644
index 0000000..225f32e
--- /dev/null
+++ b/bot/states/admin.py
@@ -0,0 +1,73 @@
+"""
+FSM States para handlers de administraci√≥n.
+
+Estados para flujos de configuraci√≥n que requieren m√∫ltiples pasos.
+"""
+from aiogram.fsm.state import State, StatesGroup
+
+
+class ChannelSetupStates(StatesGroup):
+    """
+    Estados para configurar canales VIP y Free.
+
+    Flujo t√≠pico:
+    1. Admin selecciona "Configurar Canal VIP"
+    2. Bot entra en estado waiting_for_vip_channel
+    3. Admin reenv√≠a mensaje del canal
+    4. Bot extrae ID del canal y configura
+    5. Bot sale del estado (clear state)
+
+    Extracci√≥n de ID:
+    - Usuario reenv√≠a mensaje del canal ‚Üí Bot extrae forward_from_chat.id
+    - ID extra√≠do es negativo y empieza con -100
+    - Si no es forward o no es de canal ‚Üí Error claro
+    """
+
+    # Esperando que admin reenv√≠e mensaje del canal para extraer ID
+    waiting_for_vip_channel = State()
+    waiting_for_free_channel = State()
+
+
+class WaitTimeSetupStates(StatesGroup):
+    """
+    Estados para configurar tiempo de espera del canal Free.
+
+    Flujo:
+    1. Admin selecciona "Configurar Tiempo de Espera"
+    2. Bot entra en estado waiting_for_minutes
+    3. Admin env√≠a n√∫mero de minutos
+    4. Bot valida y guarda
+    5. Bot sale del estado
+
+    Validaci√≥n de Minutos:
+    - Usuario env√≠a texto ‚Üí Bot intenta convertir a int
+    - Valor debe ser >= 1
+    - Si no es n√∫mero o es inv√°lido ‚Üí Error y mantener estado
+    """
+
+    # Esperando que admin env√≠e n√∫mero de minutos
+    waiting_for_minutes = State()
+
+
+class BroadcastStates(StatesGroup):
+    """
+    Estados para env√≠o de publicaciones a canales.
+
+    Flujo:
+    1. Admin selecciona "Enviar a Canal VIP"
+    2. Bot entra en estado waiting_for_content
+    3. Admin env√≠a mensaje (texto, foto o video)
+    4. Bot pide confirmaci√≥n (opcional)
+    5. Bot env√≠a al canal y sale del estado
+
+    Tipos de Contenido:
+    - Soportar: texto, foto, video
+    - Estado waiting_for_content acepta cualquiera
+    - Estado waiting_for_confirmation es opcional (puede omitirse)
+    """
+
+    # Esperando contenido del mensaje a enviar
+    waiting_for_content = State()
+
+    # Esperando confirmaci√≥n de env√≠o (opcional)
+    waiting_for_confirmation = State()
diff --git a/bot/states/user.py b/bot/states/user.py
new file mode 100644
index 0000000..f23f1e7
--- /dev/null
+++ b/bot/states/user.py
@@ -0,0 +1,49 @@
+"""
+FSM States para handlers de usuarios.
+
+Estados para flujos de usuarios (canje de tokens, solicitud Free).
+"""
+from aiogram.fsm.state import State, StatesGroup
+
+
+class TokenRedemptionStates(StatesGroup):
+    """
+    Estados para canje de tokens VIP.
+
+    Flujo:
+    1. Usuario env√≠a /start
+    2. Bot pregunta por token
+    3. Bot entra en estado waiting_for_token
+    4. Usuario env√≠a token
+    5. Bot valida y canjea
+    6. Bot sale del estado
+
+    Validaci√≥n de Token:
+    - Usuario env√≠a texto ‚Üí Bot valida formato y existe en BD
+    - Token debe estar vigente (no expirado)
+    - Token debe no estar ya canjeado
+    - Si token es inv√°lido ‚Üí Error claro y mantener estado
+    """
+
+    # Esperando que usuario env√≠e token
+    waiting_for_token = State()
+
+
+class FreeAccessStates(StatesGroup):
+    """
+    Estados para solicitud de acceso Free.
+
+    Flujo:
+    1. Usuario solicita acceso Free
+    2. Bot crea solicitud
+    3. Bot puede usar estado para tracking (opcional)
+
+    Nota: Este flujo es mayormente autom√°tico (background task),
+    pero el estado se puede usar para prevenir spam de solicitudes.
+
+    Estados:
+    - waiting_for_approval: Usuario tiene solicitud pendiente de aprobaci√≥n
+    """
+
+    # Usuario tiene solicitud pendiente
+    waiting_for_approval = State()
diff --git a/bot/utils/keyboards.py b/bot/utils/keyboards.py
new file mode 100644
index 0000000..dde63b4
--- /dev/null
+++ b/bot/utils/keyboards.py
@@ -0,0 +1,101 @@
+"""
+Keyboard Factory - Generador de teclados inline.
+
+Centraliza la creaci√≥n de keyboards para consistencia visual.
+"""
+from typing import List
+from aiogram.types import InlineKeyboardMarkup, InlineKeyboardButton
+
+
+def create_inline_keyboard(
+    buttons: List[List[dict]],
+    **kwargs
+) -> InlineKeyboardMarkup:
+    """
+    Crea un inline keyboard a partir de una estructura de botones.
+
+    Args:
+        buttons: Lista de filas, cada fila es lista de botones
+                 Cada bot√≥n es dict con 'text' y 'callback_data'
+
+    Ejemplo:
+        keyboard = create_inline_keyboard([
+            [{"text": "Bot√≥n 1", "callback_data": "btn1"}],
+            [
+                {"text": "Bot√≥n 2", "callback_data": "btn2"},
+                {"text": "Bot√≥n 3", "callback_data": "btn3"}
+            ]
+        ])
+
+    Returns:
+        InlineKeyboardMarkup
+    """
+    inline_keyboard = []
+
+    for row in buttons:
+        keyboard_row = []
+        for button in row:
+            keyboard_row.append(
+                InlineKeyboardButton(
+                    text=button["text"],
+                    callback_data=button["callback_data"]
+                )
+            )
+        inline_keyboard.append(keyboard_row)
+
+    return InlineKeyboardMarkup(inline_keyboard=inline_keyboard, **kwargs)
+
+
+def admin_main_menu_keyboard() -> InlineKeyboardMarkup:
+    """
+    Keyboard del men√∫ principal de admin.
+
+    Opciones:
+    - Gesti√≥n VIP
+    - Gesti√≥n Free
+    - Configuraci√≥n
+
+    Returns:
+        InlineKeyboardMarkup con men√∫ principal
+    """
+    return create_inline_keyboard([
+        [{"text": "üì∫ Gesti√≥n Canal VIP", "callback_data": "admin:vip"}],
+        [{"text": "üì∫ Gesti√≥n Canal Free", "callback_data": "admin:free"}],
+        [{"text": "‚öôÔ∏è Configuraci√≥n", "callback_data": "admin:config"}],
+    ])
+
+
+def back_to_main_menu_keyboard() -> InlineKeyboardMarkup:
+    """
+    Keyboard con solo bot√≥n "Volver al men√∫ principal".
+
+    Usado en submen√∫s para regresar.
+
+    Returns:
+        InlineKeyboardMarkup con bot√≥n volver
+    """
+    return create_inline_keyboard([
+        [{"text": "üîô Volver al Men√∫ Principal", "callback_data": "admin:main"}]
+    ])
+
+
+def yes_no_keyboard(
+    yes_callback: str,
+    no_callback: str
+) -> InlineKeyboardMarkup:
+    """
+    Keyboard de confirmaci√≥n S√≠/No.
+
+    Args:
+        yes_callback: Callback data para "S√≠"
+        no_callback: Callback data para "No"
+
+    Returns:
+        InlineKeyboardMarkup con botones S√≠/No
+    """
+    return create_inline_keyboard([
+        [
+            {"text": "‚úÖ S√≠", "callback_data": yes_callback},
+            {"text": "‚ùå No", "callback_data": no_callback}
+        ]
+    ])
diff --git a/docs/API.md b/docs/API.md
index 6e60433..bbcd504 100644
--- a/docs/API.md
+++ b/docs/API.md
@@ -1,718 +1,1169 @@
-# Referencia de API Interna
+# Integraci√≥n con la API de Telegram
 
-Gu√≠a de m√©todos, funciones p√∫blicas y puntos de integraci√≥n del bot.
+Documentaci√≥n t√©cnica sobre c√≥mo el bot interact√∫a con la API de Telegram, incluyendo los handlers VIP y Free.
 
-## Tabla de Contenidos
+## API de Telegram
 
-1. [Configuraci√≥n (Config)](#configuraci√≥n)
-2. [Base de Datos (Database)](#base-de-datos)
-3. [Modelos (Models)](#modelos)
-4. [Servicios (Services)](#servicios-planeados)
-5. [Aiogram API](#aiogram-api-telegram)
+### Configuraci√≥n B√°sica
 
-## Configuraci√≥n
-
-### M√≥dulo: `config.py`
-
-#### Clase: `Config`
-
-Configuraci√≥n global del bot con validaci√≥n.
-
-**Variables de Clase:**
+El bot se comunica con la API de Telegram a trav√©s del framework Aiogram 3, usando el siguiente esquema:
 
 ```python
-# Telegram
-Config.BOT_TOKEN: str
-Config.ADMIN_USER_IDS: List[int]
+from aiogram import Bot, Dispatcher
+from aiogram.client.default import DefaultBotProperties
+from aiogram.enums import ParseMode
+
+bot = Bot(
+    token=Config.BOT_TOKEN,
+    default=DefaultBotProperties(
+        parse_mode=ParseMode.HTML
+    )
+)
+```
+
+## Handlers VIP y Free
 
-# Database
-Config.DATABASE_URL: str
+### Handler de Men√∫ VIP (`/admin` ‚Üí `admin:vip`)
 
-# Canales
-Config.VIP_CHANNEL_ID: Optional[str]
-Config.FREE_CHANNEL_ID: Optional[str]
+#### Callback Query: `admin:vip`
 
-# Tiempos
-Config.DEFAULT_WAIT_TIME_MINUTES: int
-Config.DEFAULT_TOKEN_DURATION_HOURS: int
-Config.TOKEN_LENGTH: int
+**Descripci√≥n:** Muestra el submen√∫ de gesti√≥n VIP.
 
-# Limpieza
-Config.CLEANUP_INTERVAL_MINUTES: int
-Config.PROCESS_FREE_QUEUE_MINUTES: int
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "Gesti√≥n Canal VIP" en el men√∫ principal
+2. Bot recibe callback `admin:vip`
+3. Bot verifica configuraci√≥n del canal VIP
+4. Bot env√≠a mensaje con informaci√≥n del canal y opciones disponibles
+5. Bot actualiza el mensaje existente con teclado VIP
 
-# Logging
-Config.LOG_LEVEL: str
-Config.MAX_VIP_SUBSCRIBERS: int
+**Implementaci√≥n:**
+```python
+@admin_router.callback_query(F.data == "admin:vip")
+async def callback_vip_menu(callback: CallbackQuery, session: AsyncSession):
+    # Verificar si canal VIP est√° configurado
+    is_configured = await container.channel.is_vip_channel_configured()
+    
+    # Construir mensaje seg√∫n estado
+    if is_configured:
+        text = f"üì∫ <b>Gesti√≥n Canal VIP</b>\n\n‚úÖ Canal configurado: <b>{channel_name}</b>..."
+    else:
+        text = "üì∫ <b>Gesti√≥n Canal VIP</b>\n\n‚ö†Ô∏è Canal VIP no configurado..."
+    
+    # Enviar mensaje con teclado VIP
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=vip_menu_keyboard(is_configured),
+        parse_mode="HTML"
+    )
 ```
 
-**M√©todos de Clase:**
+**API Calls:**
+- `callback.message.edit_text()` - Edita el mensaje existente con nuevo contenido
+- `container.channel.is_vip_channel_configured()` - Consulta BD para verificar configuraci√≥n
+- `container.channel.get_vip_channel_id()` - Obtiene ID del canal VIP de la BD
+- `container.channel.get_channel_info()` - Obtiene informaci√≥n del canal de la API de Telegram
 
-```python
-@classmethod
-def validate() -> bool:
-    """
-    Valida configuraci√≥n m√≠nima.
+### Configuraci√≥n de Canal VIP
 
-    Requerido:
-    - BOT_TOKEN (longitud > 20)
-    - ADMIN_USER_IDS (al menos 1)
-    - DATABASE_URL
+#### Callback Query: `vip:setup`
 
-    Returns:
-        True si v√°lida, False en error
-    """
+**Descripci√≥n:** Inicia el proceso de configuraci√≥n del canal VIP.
 
-@classmethod
-def load_admin_ids() -> List[int]:
-    """
-    Carga y parsea IDs de admins desde ADMIN_USER_IDS.
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "‚öôÔ∏è Configurar Canal VIP"
+2. Bot recibe callback `vip:setup`
+3. Bot entra en estado FSM `waiting_for_vip_channel`
+4. Bot env√≠a instrucciones para reenviar mensaje del canal
+5. Bot espera mensaje reenviado
 
-    Formato en .env: "123456,789012,345678"
+**Implementaci√≥n:**
+```python
+@admin_router.callback_query(F.data == "vip:setup")
+async def callback_vip_setup(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    # Entrar en estado FSM
+    await state.set_state(ChannelSetupStates.waiting_for_vip_channel)
+    
+    text = (
+        "‚öôÔ∏è <b>Configurar Canal VIP</b>\n\n"
+        "Para configurar el canal VIP, necesito que:\n\n"
+        "1Ô∏è‚É£ Vayas al canal VIP\n"
+        "2Ô∏è‚É£ Reenv√≠es cualquier mensaje del canal a este chat\n"
+        "3Ô∏è‚É£ Yo extraer√© el ID autom√°ticamente\n\n"
+        "‚ö†Ô∏è <b>Importante:</b>\n"
+        "- El bot debe ser administrador del canal\n"
+        "- El bot debe tener permiso para invitar usuarios\n\n"
+        "üëâ Reenv√≠a un mensaje del canal ahora..."
+    )
+    
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=create_inline_keyboard([
+            [{"text": "‚ùå Cancelar", "callback_data": "admin:vip"}]
+        ]),
+        parse_mode="HTML"
+    )
+```
 
-    Returns:
-        Lista de IDs de administradores
-    """
+**API Calls:**
+- `state.set_state()` - Establece el estado FSM para esperar mensaje reenviado
+- `callback.message.edit_text()` - Edita mensaje con instrucciones
 
-@classmethod
-def is_admin(user_id: int) -> bool:
-    """
-    Verifica si usuario es administrador.
+#### Message Handler: `ChannelSetupStates.waiting_for_vip_channel`
 
-    Args:
-        user_id: ID de Telegram
+**Descripci√≥n:** Procesa el mensaje reenviado para configurar el canal VIP.
 
-    Returns:
-        True si es admin, False en caso contrario
-    """
+**Flujo de ejecuci√≥n:**
+1. Usuario reenv√≠a mensaje del canal VIP al bot
+2. Bot recibe mensaje mientras est√° en estado `waiting_for_vip_channel`
+3. Bot verifica que sea un reenv√≠o de canal
+4. Bot extrae ID del canal del mensaje reenviado
+5. Bot configura el canal VIP
+6. Bot sale del estado FSM
 
-@classmethod
-def setup_logging() -> None:
-    """
-    Configura logging seg√∫n LOG_LEVEL.
+**Implementaci√≥n:**
+```python
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def process_vip_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    # Verificar que es un forward de un canal
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal VIP...",
+            parse_mode="HTML"
+        )
+        return
+    
+    forward_chat = message.forward_from_chat
+    
+    # Verificar que es un canal
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b>...",
+            parse_mode="HTML"
+        )
+        return
+    
+    channel_id = str(forward_chat.id)
+    
+    # Configurar canal VIP
+    container = ServiceContainer(session, message.bot)
+    success, msg = await container.channel.setup_vip_channel(channel_id)
+    
+    if success:
+        await message.answer(
+            f"‚úÖ <b>Canal VIP Configurado</b>...",
+            parse_mode="HTML",
+            reply_markup=vip_menu_keyboard(True)
+        )
+        await state.clear()
+    else:
+        await message.answer(f"{msg}...", parse_mode="HTML")
+```
 
-    Niveles: DEBUG, INFO, WARNING, ERROR, CRITICAL
-    """
+**API Calls:**
+- `message.forward_from_chat` - Accede a la informaci√≥n del canal reenviado
+- `message.answer()` - Env√≠a mensaje de respuesta al usuario
+- `state.clear()` - Limpia el estado FSM
+- `container.channel.setup_vip_channel()` - Configura el canal en la BD y verifica permisos
 
-@classmethod
-def get_summary() -> str:
-    """
-    Retorna resumen de configuraci√≥n (para logging).
+### Generaci√≥n de Tokens VIP
 
-    Oculta informaci√≥n sensible (token truncado).
+#### Callback Query: `vip:generate_token`
 
-    Returns:
-        String formateado con resumen
-    """
-```
+**Descripci√≥n:** Genera un token de invitaci√≥n VIP.
 
-**Ejemplo de Uso:**
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "üéüÔ∏è Generar Token de Invitaci√≥n"
+2. Bot recibe callback `vip:generate_token`
+3. Bot verifica que canal VIP est√© configurado
+4. Bot genera token √∫nico con duraci√≥n configurable
+5. Bot env√≠a token al administrador
 
+**Implementaci√≥n:**
 ```python
-from config import Config
+@admin_router.callback_query(F.data == "vip:generate_token")
+async def callback_generate_vip_token(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    container = ServiceContainer(session, callback.bot)
+    
+    # Verificar que canal VIP est√° configurado
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ùå Debes configurar el canal VIP primero",
+            show_alert=True
+        )
+        return
+    
+    # Generar token
+    token = await container.subscription.generate_vip_token(
+        generated_by=callback.from_user.id,
+        duration_hours=Config.DEFAULT_TOKEN_DURATION_HOURS
+    )
+    
+    # Enviar token al admin
+    token_message = (
+        f"üéüÔ∏è <b>Token VIP Generado</b>\n\n"
+        f"Token: <code>{token.token}</code>\n\n"
+        f"‚è±Ô∏è V√°lido por: {token.duration_hours} horas\n"
+        f"üìÖ Expira: {token.created_at.strftime('%Y-%m-%d %H:%M')} UTC\n\n"
+        f"üëâ Comparte este token con el usuario."
+    )
+    
+    await callback.message.answer(
+        text=token_message,
+        parse_mode="HTML"
+    )
+```
 
-# Validar
-if not Config.validate():
-    print("Configuraci√≥n inv√°lida")
-    exit(1)
+**API Calls:**
+- `callback.answer()` - Responde al callback (con alerta si error)
+- `callback.message.answer()` - Env√≠a mensaje con token generado
+- `container.subscription.generate_vip_token()` - Genera token en la BD
 
-# Verificar permisos
-if not Config.is_admin(user_id):
-    print("Usuario no es admin")
+## Handlers Free
 
-# Obtener valor
-wait_time = Config.DEFAULT_WAIT_TIME_MINUTES
-```
+### Handler de Men√∫ Free (`/admin` ‚Üí `admin:free`)
 
-## Base de Datos
+#### Callback Query: `admin:free`
 
-### M√≥dulo: `bot/database/engine.py`
+**Descripci√≥n:** Muestra el submen√∫ de gesti√≥n Free.
 
-#### Funciones de Engine
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "Gesti√≥n Canal Free" en el men√∫ principal
+2. Bot recibe callback `admin:free`
+3. Bot verifica configuraci√≥n del canal Free y tiempo de espera
+4. Bot env√≠a mensaje con informaci√≥n del canal y tiempo de espera
+5. Bot actualiza el mensaje existente con teclado Free
 
+**Implementaci√≥n:**
 ```python
-def get_engine() -> AsyncEngine:
-    """
-    Retorna engine de SQLAlchemy.
+@admin_router.callback_query(F.data == "admin:free")
+async def callback_free_menu(callback: CallbackQuery, session: AsyncSession):
+    container = ServiceContainer(session, callback.bot)
+    
+    # Verificar si canal Free est√° configurado
+    is_configured = await container.channel.is_free_channel_configured()
+    wait_time = await container.config.get_wait_time()
+    
+    # Construir mensaje seg√∫n estado
+    if is_configured:
+        text = f"üì∫ <b>Gesti√≥n Canal Free</b>\n\n‚úÖ Canal configurado: <b>{channel_name}</b>..."
+    else:
+        text = "üì∫ <b>Gesti√≥n Canal Free</b>\n\n‚ö†Ô∏è Canal Free no configurado..."
+    
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=free_menu_keyboard(is_configured),
+        parse_mode="HTML"
+    )
+```
 
-    Debe estar inicializado con init_db() primero.
+### Configuraci√≥n de Canal Free
 
-    Returns:
-        AsyncEngine configurado
+#### Callback Query: `free:setup`
 
-    Raises:
-        RuntimeError: Si init_db() no fue llamado
-    """
+**Descripci√≥n:** Inicia el proceso de configuraci√≥n del canal Free.
 
-def get_session_factory() -> async_sessionmaker[AsyncSession]:
-    """
-    Retorna factory de sesiones async.
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "‚öôÔ∏è Configurar Canal Free"
+2. Bot recibe callback `free:setup`
+3. Bot entra en estado FSM `waiting_for_free_channel`
+4. Bot env√≠a instrucciones para reenviar mensaje del canal
+5. Bot espera mensaje reenviado
 
-    Debe estar inicializado con init_db() primero.
+**Implementaci√≥n similar a VIP setup pero con estado `waiting_for_free_channel`.**
 
-    Returns:
-        async_sessionmaker[AsyncSession]
+#### Message Handler: `ChannelSetupStates.waiting_for_free_channel`
 
-    Raises:
-        RuntimeError: Si init_db() no fue llamado
-    """
+**Descripci√≥n:** Procesa el mensaje reenviado para configurar el canal Free.
 
-def get_session() -> SessionContextManager:
-    """
-    Context manager para sesi√≥n de BD.
+**API Calls y flujo similar a la configuraci√≥n de canal VIP, pero configurando el canal Free.**
 
-    Uso:
-        async with get_session() as session:
-            # Operaciones
-            # Auto-commit si √©xito
-            # Auto-rollback si error
+### Configuraci√≥n de Tiempo de Espera
 
-    Returns:
-        SessionContextManager para usar en async with
+#### Callback Query: `free:set_wait_time`
 
-    Example:
-        async with get_session() as session:
-            query = select(User)
-            result = await session.execute(query)
-            users = result.scalars().all()
-    """
+**Descripci√≥n:** Inicia configuraci√≥n de tiempo de espera para acceso Free.
 
-async def init_db() -> None:
-    """
-    Inicializa base de datos.
+**Flujo de ejecuci√≥n:**
+1. Usuario admin selecciona "‚è±Ô∏è Configurar Tiempo de Espera"
+2. Bot recibe callback `free:set_wait_time`
+3. Bot entra en estado FSM `waiting_for_minutes`
+4. Bot solicita ingresar nuevo tiempo en minutos
+5. Bot espera mensaje con n√∫mero de minutos
 
-    Tareas:
-    1. Crear engine async
-    2. Configurar SQLite (WAL, pragmas)
-    3. Crear tablas
-    4. Crear session factory
-    5. Crear BotConfig initial (singleton)
-
-    Raises:
-        Exception: Si hay error en inicializaci√≥n
-    """
+**Implementaci√≥n:**
+```python
+@admin_router.callback_query(F.data == "free:set_wait_time")
+async def callback_set_wait_time(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    container = ServiceContainer(session, callback.bot)
+    current_wait_time = await container.config.get_wait_time()
+    
+    # Entrar en estado FSM
+    await state.set_state(WaitTimeSetupStates.waiting_for_minutes)
+    
+    text = (
+        f"‚è±Ô∏è <b>Configurar Tiempo de Espera</b>\n\n"
+        f"Tiempo actual: <b>{current_wait_time} minutos</b>\n\n"
+        f"Env√≠a el nuevo tiempo de espera en minutos.\n"
+        f"Ejemplo: <code>5</code>\n\n"
+        f"El tiempo debe ser mayor o igual a 1 minuto."
+    )
+    
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=create_inline_keyboard([
+            [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+        ]),
+        parse_mode="HTML"
+    )
+```
 
-async def close_db() -> None:
-    """
-    Cierra conexiones de base de datos.
+**API Calls:**
+- `state.set_state()` - Establece estado FSM para esperar minutos
+- `container.config.get_wait_time()` - Obtiene tiempo actual de la BD
+- `callback.message.edit_text()` - Edita mensaje con instrucciones
 
-    Debe llamarse en on_shutdown de main.py.
+#### Message Handler: `WaitTimeSetupStates.waiting_for_minutes`
 
-    Limpiar recursos correctamente.
-    """
-```
+**Descripci√≥n:** Procesa el input de tiempo de espera.
 
-**Contexto Manager:**
+**Flujo de ejecuci√≥n:**
+1. Usuario env√≠a n√∫mero de minutos
+2. Bot recibe mensaje mientras est√° en estado `waiting_for_minutes`
+3. Bot convierte texto a n√∫mero
+4. Bot valida rango (m√≠nimo 1 minuto)
+5. Bot actualiza configuraci√≥n de tiempo de espera
+6. Bot sale del estado FSM
 
+**Implementaci√≥n:**
 ```python
-class SessionContextManager:
-    """Context manager para AsyncSession con auto-commit/rollback"""
-
-    async def __aenter__(self) -> AsyncSession:
-        """Retorna la sesi√≥n"""
-
-    async def __aexit__(self, exc_type, exc_val, exc_tb):
-        """Commit si √©xito, rollback si error, siempre cierra"""
+@admin_router.message(WaitTimeSetupStates.waiting_for_minutes)
+async def process_wait_time_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    # Intentar convertir a n√∫mero
+    try:
+        minutes = int(message.text)
+    except ValueError:
+        await message.answer(
+            "‚ùå Debes enviar un n√∫mero v√°lido...",
+            parse_mode="HTML"
+        )
+        return
+    
+    # Validar rango
+    if minutes < 1:
+        await message.answer(
+            "‚ùå El tiempo debe ser al menos 1 minuto...",
+            parse_mode="HTML"
+        )
+        return
+    
+    container = ServiceContainer(session, message.bot)
+    
+    # Actualizar configuraci√≥n
+    await container.config.set_wait_time(minutes)
+    
+    await message.answer(
+        f"‚úÖ <b>Tiempo de Espera Actualizado</b>...",
+        parse_mode="HTML",
+        reply_markup=free_menu_keyboard(True)
+    )
+    
+    # Limpiar estado
+    await state.clear()
 ```
 
-**Ejemplo de Uso:**
+**API Calls:**
+- `message.text` - Accede al texto del mensaje
+- `message.answer()` - Env√≠a confirmaci√≥n de actualizaci√≥n
+- `container.config.set_wait_time()` - Actualiza tiempo en la BD
+- `state.clear()` - Limpia el estado FSM
 
-```python
-from bot.database import init_db, close_db, get_session, BotConfig
+## Manejo de Errores y Excepciones
 
-# En on_startup
-await init_db()
+### Manejo de Edici√≥n de Mensajes
 
-# En handler/servicio
-async with get_session() as session:
-    config = await session.get(BotConfig, 1)
-    config.vip_channel_id = "-100123456789"
-    await session.commit()
+Para evitar errores de "message is not modified" al editar mensajes:
 
-# En on_shutdown
-await close_db()
+```python
+try:
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=keyboard,
+        parse_mode="HTML"
+    )
+except Exception as e:
+    if "message is not modified" not in str(e):
+        logger.error(f"Error editando mensaje: {e}")
+    else:
+        logger.debug("‚ÑπÔ∏è Mensaje sin cambios, ignorando")
 ```
 
-## Modelos
+### Manejo de Permisos
 
-### M√≥dulo: `bot/database/models.py`
-
-#### BotConfig
-
-Tabla singleton de configuraci√≥n global.
-
-**Atributos:**
+Los middlewares verifican permisos antes de ejecutar handlers:
 
 ```python
-id: int                              # Primary key (siempre 1)
-vip_channel_id: Optional[str]       # ID del canal VIP
-free_channel_id: Optional[str]      # ID del canal Free
-wait_time_minutes: int              # Minutos espera Free
-vip_reactions: List[str]            # Emojis reacciones VIP
-free_reactions: List[str]           # Emojis reacciones Free
-subscription_fees: Dict             # Tarifas {"monthly": 10, "yearly": 100}
-created_at: datetime                # Timestamp creaci√≥n
-updated_at: datetime                # Timestamp actualizaci√≥n
+# AdminAuthMiddleware verifica si el usuario es admin
+# DatabaseMiddleware inyecta la sesi√≥n de base de datos
 ```
 
-**M√©todos:**
+## Interacci√≥n con Teclados Inline
 
-```python
-def __repr__(self) -> str:
-    """Representaci√≥n string del objeto"""
-```
+### Creaci√≥n de Teclados
 
-**Ejemplo de Uso:**
+Los teclados se crean usando el factory `create_inline_keyboard()`:
 
 ```python
-async with get_session() as session:
-    # Obtener
-    config = await session.get(BotConfig, 1)
+def vip_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    buttons = []
+    
+    if is_configured:
+        buttons.extend([
+            [{"text": "üéüÔ∏è Generar Token de Invitaci√≥n", "callback_data": "vip:generate_token"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "vip:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal VIP", "callback_data": "vip:setup"}])
+    
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+    
+    return create_inline_keyboard(buttons)
+```
 
-    # Actualizar
-    config.wait_time_minutes = 10
-    await session.commit()
+### Callback Data Format
 
-    # Acceder campos
-    vip_id = config.vip_channel_id
-    fees = config.subscription_fees
-```
+Los callbacks siguen el formato `modulo:accion`:
+- `admin:vip` - Ir al men√∫ VIP
+- `admin:free` - Ir al men√∫ Free
+- `vip:setup` - Configurar canal VIP
+- `vip:generate_token` - Generar token VIP
+- `free:setup` - Configurar canal Free
+- `free:set_wait_time` - Configurar tiempo de espera
+- `admin:main` - Volver al men√∫ principal
 
-#### InvitationToken
+## Handlers User
 
-Tokens de invitaci√≥n VIP.
+### Handler de Men√∫ Principal (`/start`)
 
-**Atributos:**
+#### Message Handler: `/start`
 
-```python
-id: int                             # Primary key
-token: str                          # Token √∫nico (16 chars)
-generated_by: int                   # User ID admin que cre√≥
-created_at: datetime                # Timestamp creaci√≥n
-duration_hours: int                 # Horas de validez
-used: bool                          # Si fue canjeado
-used_by: Optional[int]              # User ID que canje√≥
-used_at: Optional[datetime]         # Timestamp uso
-subscribers: List[VIPSubscriber]    # Relaci√≥n 1:N
-```
+**Descripci√≥n:** Handler del comando /start que detecta el rol del usuario y proporciona opciones seg√∫n su estado.
 
-**M√©todos:**
+**Flujo de ejecuci√≥n:**
+1. Usuario env√≠a `/start`
+2. Bot detecta rol del usuario (admin, VIP, normal)
+3. Si es admin: redirige a panel de administraci√≥n
+4. Si es VIP: muestra mensaje de bienvenida con d√≠as restantes
+5. Si es usuario normal: muestra men√∫ con opciones VIP/Free
 
+**Implementaci√≥n:**
 ```python
-def is_expired(self) -> bool:
-    """Verifica si token expir√≥"""
-
-def is_valid(self) -> bool:
-    """Verifica si puede usarse (no usado y no expirado)"""
+@user_router.message(Command("start"))
+async def cmd_start(message: Message, session: AsyncSession):
+    """
+    Handler del comando /start para usuarios.
 
-def __repr__(self) -> str:
-    """Representaci√≥n string"""
+    Comportamiento:
+    - Si es admin ‚Üí Redirige a /admin
+    - Si es VIP activo ‚Üí Muestra mensaje de bienvenida con d√≠as restantes
+    - Si no es admin ‚Üí Muestra men√∫ de usuario (VIP/Free)
+    """
+    user_id = message.from_user.id
+    user_name = message.from_user.first_name or "Usuario"
+
+    # Verificar si es admin
+    if Config.is_admin(user_id):
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"Eres administrador. Usa /admin para gestionar los canales.",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario normal: verificar si es VIP activo
+    container = ServiceContainer(session, message.bot)
+
+    is_vip = await container.subscription.is_vip_active(user_id)
+
+    if is_vip:
+        # Usuario ya tiene acceso VIP
+        subscriber = await container.subscription.get_vip_subscriber(user_id)
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"‚úÖ Tienes acceso VIP activo\n"
+            f"‚è±Ô∏è D√≠as restantes: <b>{days_remaining}</b>\n\n"
+            f"Disfruta del contenido exclusivo! üéâ",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario no es VIP: mostrar opciones
+    keyboard = create_inline_keyboard([
+        [{"text": "üéüÔ∏è Canjear Token VIP", "callback_data": "user:redeem_token"}],
+        [{"text": "üì∫ Solicitar Acceso Free", "callback_data": "user:request_free"}],
+    ])
+
+    await message.answer(
+        f"üëã Hola <b>{user_name}</b>!\n\n"
+        f"Bienvenido al bot de acceso a canales.\n\n"
+        f"<b>Opciones disponibles:</b>\n\n"
+        f"üéüÔ∏è <b>Canjear Token VIP</b>\n"
+        f"Si tienes un token de invitaci√≥n, canj√©alo para acceso VIP.\n\n"
+        f"üì∫ <b>Solicitar Acceso Free</b>\n"
+        f"Solicita acceso al canal gratuito (con tiempo de espera).\n\n"
+        f"üëâ Selecciona una opci√≥n:",
+        reply_markup=keyboard,
+        parse_mode="HTML"
+    )
 ```
 
-**√çndices:**
+**API Calls:**
+- `message.from_user.id` - Accede al ID del usuario
+- `message.from_user.first_name` - Accede al nombre del usuario
+- `message.answer()` - Env√≠a mensaje de respuesta al usuario
+- `Config.is_admin()` - Verifica si el usuario es administrador
+- `container.subscription.is_vip_active()` - Verifica si el usuario tiene suscripci√≥n VIP activa
+- `container.subscription.get_vip_subscriber()` - Obtiene informaci√≥n del suscriptor VIP
 
-```
-idx_token_used_created: (used, created_at)
-idx_token: UNIQUE(token)
-```
+### Flujo VIP - Canje de Tokens
 
-**Ejemplo de Uso:**
+#### Callback Query: `user:redeem_token`
 
+**Descripci√≥n:** Inicia el flujo de canje de token VIP.
+
+**Flujo de ejecuci√≥n:**
+1. Usuario selecciona "Canjear Token VIP"
+2. Bot recibe callback `user:redeem_token`
+3. Bot verifica que canal VIP est√© configurado
+4. Bot entra en estado FSM `waiting_for_token`
+5. Bot solicita ingresar token de invitaci√≥n
+
+**Implementaci√≥n:**
 ```python
-from sqlalchemy import select
-
-async with get_session() as session:
-    # Crear token
-    token = InvitationToken(
-        token="ABC123XYZ456789",
-        generated_by=admin_id,
-        duration_hours=24
-    )
-    session.add(token)
-    await session.commit()
+@user_router.callback_query(F.data == "user:redeem_token")
+async def callback_redeem_token(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia el flujo de canje de token VIP.
 
-    # Buscar por valor
-    query = select(InvitationToken).where(
-        InvitationToken.token == "ABC123XYZ456789"
-    )
-    result = await session.execute(query)
-    token = result.scalar_one_or_none()
-
-    # Validar
-    if token and token.is_valid():
-        # Usar token
-        pass
-
-    # Marcar como usado
-    token.used = True
-    token.used_by = user_id
-    token.used_at = datetime.utcnow()
-    await session.commit()
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = callback.from_user.id
+
+    # Verificar que canal VIP est√° configurado
+    container = ServiceContainer(session, callback.bot)
+
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal VIP no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Entrar en estado FSM
+    await state.set_state(TokenRedemptionStates.waiting_for_token)
+
+    try:
+        await callback.message.edit_text(
+            "üéüÔ∏è <b>Canjear Token VIP</b>\n\n"
+            "Por favor, env√≠a tu token de invitaci√≥n.\n\n"
+            "El token tiene este formato:\n"
+            "<code>A1b2C3d4E5f6G7h8</code>\n\n"
+            "üëâ Copia y pega tu token aqu√≠:",
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "user:cancel"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
 ```
 
-#### VIPSubscriber
+**API Calls:**
+- `callback.from_user.id` - Accede al ID del usuario
+- `callback.answer()` - Responde al callback
+- `callback.message.edit_text()` - Edita mensaje existente con instrucciones
+- `state.set_state()` - Establece estado FSM para esperar token
+- `container.channel.is_vip_channel_configured()` - Verifica configuraci√≥n del canal VIP
+
+#### Message Handler: `TokenRedemptionStates.waiting_for_token`
 
-Suscriptores VIP.
+**Descripci√≥n:** Procesa el token enviado por el usuario.
 
-**Atributos:**
+**Flujo de ejecuci√≥n:**
+1. Usuario env√≠a token
+2. Bot recibe mensaje mientras est√° en estado `waiting_for_token`
+3. Bot valida token (formato, vigencia, no usado)
+4. Bot canjea token y genera invite link
+5. Bot env√≠a link de acceso al usuario
+6. Bot sale del estado FSM
 
+**Implementaci√≥n:**
 ```python
-id: int                             # Primary key
-user_id: int                        # User ID (UNIQUE)
-join_date: datetime                 # Timestamp suscripci√≥n
-expiry_date: datetime               # Fecha expiraci√≥n
-status: str                         # "active" o "expired"
-token_id: int                       # FK a InvitationToken
-token: InvitationToken              # Relaci√≥n N:1
-```
+@user_router.message(TokenRedemptionStates.waiting_for_token)
+async def process_token_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el token enviado por el usuario.
 
-**M√©todos:**
+    Valida el token, lo canjea y env√≠a invite link.
 
-```python
-def is_expired(self) -> bool:
-    """Verifica si suscripci√≥n expir√≥"""
+    Args:
+        message: Mensaje con el token
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = message.from_user.id
+    token_str = message.text.strip()
+
+    container = ServiceContainer(session, message.bot)
 
-def days_remaining(self) -> int:
-    """Retorna d√≠as restantes (negativo si expirado)"""
+    # Intentar canjear token
+    success, msg, subscriber = await container.subscription.redeem_vip_token(
+        token_str=token_str,
+        user_id=user_id
+    )
 
-def __repr__(self) -> str:
-    """Representaci√≥n string"""
+    if not success:
+        # Token inv√°lido
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica el token e intenta nuevamente.\n\n"
+            f"Si el problema persiste, contacta al administrador.",
+            parse_mode="HTML"
+        )
+        # Mantener estado para reintentar
+        return
+
+    # Token v√°lido: crear invite link
+    vip_channel_id = await container.channel.get_vip_channel_id()
+
+    try:
+        invite_link = await container.subscription.create_invite_link(
+            channel_id=vip_channel_id,
+            user_id=user_id,
+            expire_hours=1  # Link expira en 1 hora
+        )
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"‚úÖ <b>Token Canjeado Exitosamente!</b>\n\n"
+            f"üéâ Tu acceso VIP est√° activo\n"
+            f"‚è±Ô∏è Duraci√≥n: <b>{days_remaining} d√≠as</b>\n\n"
+            f"üëá Usa este link para unirte al canal VIP:\n"
+            f"{invite_link.invite_link}\n\n"
+            f"‚ö†Ô∏è <b>Importante:</b>\n"
+            f"‚Ä¢ El link expira en 1 hora\n"
+            f"‚Ä¢ Solo puedes usarlo 1 vez\n"
+            f"‚Ä¢ No lo compartas con otros\n\n"
+            f"Disfruta del contenido exclusivo! üöÄ",
+            parse_mode="HTML"
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error creando invite link para user {user_id}: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al crear el link de invitaci√≥n.\n\n"
+            "Tu token fue canjeado correctamente, pero hubo un problema t√©cnico.\n"
+            "Contacta al administrador.",
+            parse_mode="HTML"
+        )
+        await state.clear()
 ```
 
-**√çndices:**
+**API Calls:**
+- `message.text` - Accede al texto del mensaje (token)
+- `message.answer()` - Env√≠a respuesta con link de acceso
+- `state.clear()` - Limpia el estado FSM
+- `container.subscription.redeem_vip_token()` - Canjea token en la BD
+- `container.channel.get_vip_channel_id()` - Obtiene ID del canal VIP
+- `container.subscription.create_invite_link()` - Crea link de invitaci√≥n √∫nico
 
-```
-idx_status_expiry: (status, expiry_date)
-idx_user_id: UNIQUE(user_id)
-```
+### Flujo Free - Solicitud de Acceso
 
-**Ejemplo de Uso:**
+#### Callback Query: `user:request_free`
 
+**Descripci√≥n:** Procesa solicitud de acceso al canal Free.
+
+**Flujo de ejecuci√≥n:**
+1. Usuario selecciona "Solicitar Acceso Free"
+2. Bot recibe callback `user:request_free`
+3. Bot verifica que canal Free est√© configurado
+4. Bot verifica si usuario ya tiene solicitud pendiente
+5. Si no tiene solicitud: crea nueva solicitud y notifica tiempo de espera
+6. Si ya tiene solicitud: muestra tiempo restante
+
+**Implementaci√≥n:**
 ```python
-async with get_session() as session:
-    # Crear
-    from datetime import timedelta
-    subscriber = VIPSubscriber(
-        user_id=987654321,
-        token_id=token.id,
-        expiry_date=datetime.utcnow() + timedelta(hours=24),
-        status="active"
-    )
-    session.add(subscriber)
-    await session.commit()
+@user_router.callback_query(F.data == "user:request_free")
+async def callback_request_free(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Procesa solicitud de acceso al canal Free.
 
-    # Buscar activo
-    query = select(VIPSubscriber).where(
-        VIPSubscriber.user_id == user_id
-    )
-    result = await session.execute(query)
-    sub = result.scalar_one_or_none()
+    Crea la solicitud y notifica al usuario del tiempo de espera.
 
-    # Verificar estado
-    if sub and not sub.is_expired():
-        days = sub.days_remaining()
-        print(f"V√°lido {days} d√≠as")
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    user_id = callback.from_user.id
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal Free est√° configurado
+    if not await container.channel.is_free_channel_configured():
+        await callback.answer(
+            "‚ö†Ô∏è Canal Free no est√° configurado. Contacta al administrador.",
+            show_alert=True
+        )
+        return
+
+    # Verificar si ya tiene solicitud pendiente
+    existing_request = await container.subscription.get_free_request(user_id)
+
+    if existing_request:
+        # Calcular tiempo restante
+        from datetime import datetime, timezone, timedelta
+
+        wait_time_minutes = await container.config.get_wait_time()
+        time_since_request = (datetime.now(timezone.utc) - existing_request.request_date).total_seconds() / 60
+        minutes_remaining = max(0, int(wait_time_minutes - time_since_request))
+
+        try:
+            await callback.message.edit_text(
+                f"‚è±Ô∏è <b>Solicitud Pendiente</b>\n\n"
+                f"Ya tienes una solicitud en proceso.\n\n"
+                f"Tiempo transcurrido: <b>{int(time_since_request)} minutos</b>\n"
+                f"Tiempo restante: <b>{minutes_remaining} minutos</b>\n\n"
+                f"Recibir√°s el link de acceso autom√°ticamente cuando el tiempo se cumpla.\n\n"
+                f"üí° <i>Puedes cerrar este chat, te notificar√© cuando est√© listo.</i>",
+                parse_mode="HTML"
+            )
+        except Exception as e:
+            if "message is not modified" not in str(e):
+                logger.error(f"Error editando mensaje: {e}")
+
+        await callback.answer()
+        return
+
+    # Crear nueva solicitud
+    request = await container.subscription.create_free_request(user_id)
+    wait_time = await container.config.get_wait_time()
+
+    try:
+        await callback.message.edit_text(
+            f"‚úÖ <b>Solicitud Recibida</b>\n\n"
+            f"Tu solicitud de acceso al canal Free ha sido registrada.\n\n"
+            f"‚è±Ô∏è Tiempo de espera: <b>{wait_time} minutos</b>\n\n"
+            f"üì® Recibir√°s un mensaje con el link de invitaci√≥n cuando el tiempo se cumpla.\n\n"
+            f"üí° <i>No necesitas hacer nada m√°s, el proceso es autom√°tico.</i>\n\n"
+            f"Puedes cerrar este chat, te notificar√© cuando est√© listo! üîî",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer("‚úÖ Solicitud creada")
 ```
 
-#### FreeChannelRequest
+**API Calls:**
+- `callback.from_user.id` - Accede al ID del usuario
+- `callback.answer()` - Responde al callback
+- `callback.message.edit_text()` - Edita mensaje existente con informaci√≥n de solicitud
+- `container.channel.is_free_channel_configured()` - Verifica configuraci√≥n del canal Free
+- `container.subscription.get_free_request()` - Obtiene solicitud pendiente del usuario
+- `container.subscription.create_free_request()` - Crea nueva solicitud en la BD
+- `container.config.get_wait_time()` - Obtiene tiempo de espera configurado
 
-Solicitudes de acceso Free.
+### Cancelaci√≥n de Flujos
 
-**Atributos:**
+#### Callback Query: `user:cancel`
 
-```python
-id: int                             # Primary key
-user_id: int                        # User ID
-request_date: datetime              # Timestamp solicitud
-processed: bool                     # Si fue procesada
-processed_at: Optional[datetime]    # Timestamp procesamiento
-```
+**Descripci√≥n:** Cancela el flujo actual y limpia estado FSM.
 
-**M√©todos:**
+**Flujo de ejecuci√≥n:**
+1. Usuario selecciona opci√≥n de cancelar
+2. Bot recibe callback `user:cancel`
+3. Bot limpia estado FSM
+4. Bot env√≠a mensaje de confirmaci√≥n
 
+**Implementaci√≥n:**
 ```python
-def minutes_since_request(self) -> int:
-    """Retorna minutos desde solicitud"""
+@user_router.callback_query(F.data == "user:cancel")
+async def callback_cancel(
+    callback: CallbackQuery,
+    state: FSMContext
+):
+    """
+    Cancela el flujo actual y limpia estado FSM.
 
-def is_ready(self, wait_time_minutes: int) -> bool:
-    """Verifica si cumpli√≥ tiempo espera"""
+    Args:
+        callback: Callback query
+        state: FSM context
+    """
+    await state.clear()
 
-def __repr__(self) -> str:
-    """Representaci√≥n string"""
+    try:
+        await callback.message.edit_text(
+            "‚ùå Operaci√≥n cancelada.\n\n"
+            "Usa /start para volver al men√∫ principal.",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje: {e}")
+
+    await callback.answer()
 ```
 
-**√çndices:**
+**API Calls:**
+- `state.clear()` - Limpia el estado FSM
+- `callback.message.edit_text()` - Edita mensaje con confirmaci√≥n de cancelaci√≥n
+- `callback.answer()` - Responde al callback
 
-```
-idx_user_date: (user_id, request_date)
-idx_processed_date: (processed, request_date)
-```
+## Validaciones y Seguridad
+
+### Validaci√≥n de Reenv√≠os
 
-**Ejemplo de Uso:**
+Para asegurar que los mensajes son reenv√≠os de canales v√°lidos:
 
 ```python
-async with get_session() as session:
-    # Crear solicitud
-    request = FreeChannelRequest(user_id=111111111)
-    session.add(request)
-    await session.commit()
-
-    # Buscar pendientes listas
-    query = select(FreeChannelRequest).where(
-        FreeChannelRequest.processed == False
-    ).order_by(FreeChannelRequest.request_date)
-    result = await session.execute(query)
-    requests = result.scalars().all()
-
-    ready = [
-        r for r in requests
-        if r.is_ready(Config.DEFAULT_WAIT_TIME_MINUTES)
-    ]
-
-    # Procesar
-    for req in ready:
-        await invite_to_free_channel(req.user_id)
-        req.processed = True
-        req.processed_at = datetime.utcnow()
-
-    await session.commit()
+if not message.forward_from_chat:
+    # No es un reenv√≠o, solicitar reenv√≠o
+    return
+
+if forward_chat.type not in ["channel", "supergroup"]:
+    # No es un canal v√°lido, solicitar canal
+    return
 ```
 
-## Servicios (Planeados)
+### Validaci√≥n de N√∫meros
+
+Para asegurar que los tiempos de espera son v√°lidos:
 
-### M√≥dulo: `bot/services/subscription.py`
+```python
+try:
+    minutes = int(message.text)
+except ValueError:
+    # No es un n√∫mero, solicitar n√∫mero v√°lido
+    return
+
+if minutes < 1:
+    # Valor no v√°lido, solicitar valor >= 1
+    return
+```
 
-Ver [SERVICES.md](./SERVICES.md) para referencia completa.
+### Validaci√≥n de Tokens
 
-**M√©todos principales:**
+Para asegurar que los tokens son v√°lidos antes de canjear:
 
 ```python
-class SubscriptionService:
-    async def generate_token(admin_id: int, duration_hours: int) -> str
-    async def validate_token(token: str) -> bool
-    async def redeem_token(user_id: int, token: str) -> VIPSubscriber
-    async def get_active_subscriber(user_id: int) -> Optional[VIPSubscriber]
-    async def renew_subscription(user_id: int, duration_hours: int) -> VIPSubscriber
-    async def list_expiring_subscribers(days: int) -> List[VIPSubscriber]
-    async def cleanup_expired_subscriptions() -> int
-    async def create_free_request(user_id: int) -> FreeChannelRequest
-    async def get_pending_free_requests(ready_only: bool) -> List[FreeChannelRequest]
-    async def process_free_request(request_id: int) -> FreeChannelRequest
-```
+success, msg, subscriber = await container.subscription.redeem_vip_token(
+    token_str=token_str,
+    user_id=user_id
+)
 
-### M√≥dulo: `bot/services/channel.py`
+if not success:
+    # Token inv√°lido, notificar al usuario
+    await message.answer(f"{msg}...")
+    return
+```
 
-Ver [SERVICES.md](./SERVICES.md) para referencia completa.
+### Validaci√≥n de Configuraci√≥n
 
-**M√©todos principales:**
+Para asegurar que los canales est√°n configurados antes de procesar solicitudes:
 
 ```python
-class ChannelService:
-    async def invite_to_vip_channel(user_id: int) -> bool
-    async def invite_to_free_channel(user_id: int) -> bool
-    async def remove_from_channel(channel_id: str, user_id: int) -> bool
-    async def get_channel_info(channel_id: str) -> Optional[dict]
+if not await container.channel.is_vip_channel_configured():
+    await callback.answer(
+        "‚ö†Ô∏è Canal VIP no est√° configurado. Contacta al administrador.",
+        show_alert=True
+    )
+    return
+
+if not await container.channel.is_free_channel_configured():
+    await callback.answer(
+        "‚ö†Ô∏è Canal Free no est√° configurado. Contacta al administrador.",
+        show_alert=True
+    )
+    return
 ```
 
-### M√≥dulo: `bot/services/config.py`
+## Integraci√≥n con APScheduler
 
-Ver [SERVICES.md](./SERVICES.md) para referencia completa.
+El bot utiliza APScheduler para ejecutar tareas programadas que realizan operaciones peri√≥dicas para mantener el sistema funcionando correctamente.
 
-**M√©todos principales:**
+### Configuraci√≥n del Scheduler
 
+**Inicializaci√≥n:**
 ```python
-class ConfigService:
-    async def get_config() -> BotConfig
-    async def set_vip_channel(channel_id: str) -> None
-    async def set_free_channel(channel_id: str) -> None
-    async def set_wait_time(minutes: int) -> None
-    async def set_reactions(vip_reactions: List[str], free_reactions: List[str]) -> None
-    async def set_subscription_fees(monthly: float, yearly: float) -> None
+from apscheduler.schedulers.asyncio import AsyncIOScheduler
+from apscheduler.triggers.interval import IntervalTrigger
+from apscheduler.triggers.cron import CronTrigger
+
+_scheduler: Optional[AsyncIOScheduler] = None
 ```
 
-## Aiogram API (Telegram)
+**Iniciar tareas programadas:**
+```python
+def start_background_tasks(bot: Bot):
+    """
+    Inicia el scheduler con todas las tareas programadas.
+    """
+    global _scheduler
 
-### Bot API
+    if _scheduler is not None:
+        logger.warning("‚ö†Ô∏è Scheduler ya est√° corriendo")
+        return
 
-```python
-from aiogram import Bot
-from aiogram.types import Message, CallbackQuery, InlineKeyboardMarkup
+    logger.info("üöÄ Iniciando background tasks...")
 
-bot = Bot(token=Config.BOT_TOKEN, parse_mode="HTML")
+    _scheduler = AsyncIOScheduler(timezone="UTC")
 
-# Enviar mensaje
-await bot.send_message(
-    chat_id=user_id,
-    text="<b>Mensaje</b>",
-    parse_mode="HTML",
-    reply_markup=teclado
-)
+    # Tarea 1: Expulsi√≥n VIP expirados
+    _scheduler.add_job(
+        expire_and_kick_vip_subscribers,
+        trigger=IntervalTrigger(minutes=Config.CLEANUP_INTERVAL_MINUTES),
+        args=[bot],
+        id="expire_vip",
+        name="Expulsar VIPs expirados",
+        replace_existing=True,
+        max_instances=1
+    )
 
-# Responder mensaje
-await message.answer(
-    "Respuesta",
-    reply_markup=teclado
-)
+    # Tarea 2: Procesamiento cola Free
+    _scheduler.add_job(
+        process_free_queue,
+        trigger=IntervalTrigger(minutes=Config.PROCESS_FREE_QUEUE_MINUTES),
+        args=[bot],
+        id="process_free_queue",
+        name="Procesar cola Free",
+        replace_existing=True,
+        max_instances=1
+    )
 
-# Editar mensaje
-await callback.message.edit_text(
-    "Texto actualizado",
-    reply_markup=new_keyboard
-)
+    # Tarea 3: Limpieza de datos antiguos
+    _scheduler.add_job(
+        cleanup_old_data,
+        trigger=CronTrigger(hour=3, minute=0, timezone="UTC"),
+        args=[bot],
+        id="cleanup_old_data",
+        name="Limpieza de datos antiguos",
+        replace_existing=True,
+        max_instances=1
+    )
 
-# Responder callback
-await callback.answer("Notificaci√≥n", show_alert=False)
+    # Iniciar scheduler
+    _scheduler.start()
+    logger.info("‚úÖ Background tasks iniciados correctamente")
+```
 
-# Invitar a canal
-await bot.add_chat_member(
-    chat_id=channel_id,
-    user_id=user_id
-)
+**Detener tareas programadas:**
+```python
+def stop_background_tasks():
+    """
+    Detiene el scheduler y todas las tareas programadas.
+    """
+    global _scheduler
 
-# Remover de canal
-await bot.ban_chat_member(
-    chat_id=channel_id,
-    user_id=user_id
-)
+    if _scheduler is None:
+        logger.warning("‚ö†Ô∏è Scheduler no est√° corriendo")
+        return
 
-# Obtener info del bot
-bot_info = await bot.get_me()
+    logger.info("üõë Deteniendo background tasks...")
 
-# Obtener info del canal
-chat = await bot.get_chat(channel_id)
-member_count = await bot.get_chat_member_count(channel_id)
+    _scheduler.shutdown(wait=True)
+    _scheduler = None
+
+    logger.info("‚úÖ Background tasks detenidos correctamente")
 ```
 
-### Dispatcher
+### Tareas Programadas
 
-```python
-from aiogram import Dispatcher, Router
-from aiogram.fsm.storage.memory import MemoryStorage
+#### Tarea: Expulsi√≥n de VIPs expirados
 
-# Crear storage y dispatcher
-storage = MemoryStorage()
-dp = Dispatcher(storage=storage)
+**Descripci√≥n:** Marca como expirados y expulsa del canal a los suscriptores VIP cuya fecha pas√≥.
 
-# Registrar router
-router = Router()
-dp.include_router(router)
+**Frecuencia:** Cada 60 minutos (configurable con `CLEANUP_INTERVAL_MINUTES`)
 
-# Registrar handlers
-@router.message.command("comando")
-async def handler(message: Message):
-    await message.answer("Respuesta")
+**Flujo de ejecuci√≥n:**
+1. Se ejecuta la funci√≥n `expire_and_kick_vip_subscribers(bot)`
+2. Verifica si canal VIP est√° configurado
+3. Busca suscriptores VIP con fecha de expiraci√≥n anterior a la actual
+4. Marca como expirados en la base de datos
+5. Expulsa del canal VIP usando la API de Telegram
+6. Registra en logs el n√∫mero de usuarios expulsados
 
-# Registrar middleware
-dp.message.middleware(SomeMiddleware())
+**API Calls:**
+- `container.subscription.expire_vip_subscribers()` - Marca suscriptores como expirados
+- `container.subscription.kick_expired_vip_from_channel()` - Expulsa usuarios del canal
+- `container.channel.get_vip_channel_id()` - Obtiene ID del canal VIP
 
-# Registrar callbacks
-dp.startup.register(on_startup)
-dp.shutdown.register(on_shutdown)
-```
+#### Tarea: Procesamiento de cola Free
 
-### Types
+**Descripci√≥n:** Busca solicitudes que cumplieron el tiempo de espera y env√≠a invite links a los usuarios.
 
-```python
-from aiogram.types import (
-    Message,        # Mensaje de usuario
-    CallbackQuery,  # Click en bot√≥n inline
-    User,          # Informaci√≥n del usuario
-    Chat,          # Informaci√≥n del chat
-    Update,        # Update general de Telegram
-    InlineKeyboardButton,
-    InlineKeyboardMarkup,
-    ReplyKeyboardMarkup,
-)
+**Frecuencia:** Cada 5 minutos (configurable con `PROCESS_FREE_QUEUE_MINUTES`)
 
-# Message
-message.text               # Texto del mensaje
-message.from_user          # Usuario que envi√≥
-message.from_user.id       # User ID
-message.from_user.username # @username
-message.from_user.first_name
-message.chat.id            # Chat ID
-message.message_id         # ID del mensaje
-message.date               # Timestamp
-
-# CallbackQuery
-callback.from_user         # Usuario que presion√≥ bot√≥n
-callback.data              # Datos del bot√≥n presionado
-callback.message           # Mensaje del bot√≥n
-callback.answer()          # Responder (notificaci√≥n)
-
-# Crear teclado
-keyboard = InlineKeyboardMarkup(inline_keyboard=[
-    [
-        InlineKeyboardButton(text="Bot√≥n 1", callback_data="btn1"),
-        InlineKeyboardButton(text="Bot√≥n 2", callback_data="btn2"),
-    ],
-    [
-        InlineKeyboardButton(text="Bot√≥n 3", callback_data="btn3"),
-    ],
-])
-```
+**Flujo de ejecuci√≥n:**
+1. Se ejecuta la funci√≥n `process_free_queue(bot)`
+2. Verifica si canal Free est√° configurado
+3. Busca solicitudes Free que cumplen el tiempo de espera configurado
+4. Para cada solicitud:
+   - Marca como procesada
+   - Crea invite link √∫nico (v√°lido 24 horas, un solo uso)
+   - Env√≠a link al usuario por mensaje privado
+5. Registra en logs el n√∫mero de solicitudes procesadas
 
-### FSM
+**API Calls:**
+- `container.subscription.process_free_queue()` - Procesa solicitudes pendientes
+- `container.subscription.create_invite_link()` - Crea link de invitaci√≥n √∫nico
+- `container.channel.get_free_channel_id()` - Obtiene ID del canal Free
+- `bot.send_message()` - Env√≠a mensaje privado al usuario
 
-```python
-from aiogram.fsm.context import FSMContext
-from aiogram.fsm.state import State, StatesGroup
+#### Tarea: Limpieza de datos antiguos
 
-class MyStates(StatesGroup):
-    state1 = State()
-    state2 = State()
+**Descripci√≥n:** Elimina solicitudes Free procesadas hace m√°s de 30 d√≠as.
 
-# Usar en handler
-async def handler(message: Message, state: FSMContext):
-    # Cambiar estado
-    await state.set_state(MyStates.state1)
+**Frecuencia:** Diariamente a las 3 AM UTC
 
-    # Guardar datos
-    await state.update_data(valor="datos")
+**Flujo de ejecuci√≥n:**
+1. Se ejecuta la funci√≥n `cleanup_old_data(bot)`
+2. Busca solicitudes Free procesadas hace m√°s de 30 d√≠as
+3. Elimina los registros antiguos de la base de datos
+4. Registra en logs el n√∫mero de registros eliminados
 
-    # Obtener datos
-    data = await state.get_data()
-    valor = data.get("valor")
+**API Calls:**
+- `container.subscription.cleanup_old_free_requests()` - Elimina solicitudes antiguas
 
-    # Limpiar
-    await state.clear()
-```
+### Variables de Entorno para Configuraci√≥n
 
-## Estructuras de Datos Comunes
+- `CLEANUP_INTERVAL_MINUTES`: Intervalo para expulsi√≥n de VIPs expirados (default: 60)
+- `PROCESS_FREE_QUEUE_MINUTES`: Intervalo para procesamiento de cola Free (default: 5)
 
-### Respuesta de Consulta
+### Manejo de Errores en Tareas
+
+Cada tarea est√° envuelta en try-catch para evitar interrupciones:
 
 ```python
-from sqlalchemy import select
+async def expire_and_kick_vip_subscribers(bot: Bot):
+    logger.info("üîÑ Ejecutando tarea: Expulsi√≥n VIP expirados")
 
-query = select(Model).where(condition)
-result = await session.execute(query)
+    try:
+        # Procesamiento de la tarea
+        async with get_session() as session:
+            container = ServiceContainer(session, bot)
+            # ... l√≥gica de la tarea
+    except Exception as e:
+        logger.error(f"‚ùå Error en tarea de expulsi√≥n VIP: {e}", exc_info=True)
+```
 
-# Un resultado
-obj = result.scalar_one_or_none()  # None si no existe
+### Monitoreo del Scheduler
 
-# M√∫ltiples resultados
-objs = result.scalars().all()       # Lista (vac√≠a si ninguno)
+**Obtener estado del scheduler:**
+```python
+def get_scheduler_status() -> dict:
+    """
+    Obtiene el estado actual del scheduler.
 
-# Con offset/limit
-query = query.offset(10).limit(5)
+    Returns:
+        Dict con informaci√≥n del scheduler:
+        {
+            "running": bool,
+            "jobs_count": int,
+            "jobs": List[dict]
+        }
+    """
+    if _scheduler is None:
+        return {
+            "running": False,
+            "jobs_count": 0,
+            "jobs": []
+        }
+
+    jobs_info = []
+    for job in _scheduler.get_jobs():
+        jobs_info.append({
+            "id": job.id,
+            "name": job.name,
+            "next_run": job.next_run_time.isoformat() if job.next_run_time else None
+        })
+
+    return {
+        "running": True,
+        "jobs_count": len(jobs_info),
+        "jobs": jobs_info
+    }
 ```
 
-### Error Handling
+## Flujo Completo de Configuraci√≥n
 
-```python
-try:
-    # Operaci√≥n
-    pass
-except ValueError as e:
-    # Error de validaci√≥n
-    logger.warning(f"Validaci√≥n: {e}")
-except Exception as e:
-    # Error inesperado
-    logger.error(f"Error: {e}", exc_info=True)
-```
+### Configuraci√≥n de Canal por Reenv√≠o
+
+1. Admin selecciona opci√≥n de configuraci√≥n
+2. Bot entra en estado FSM correspondiente
+3. Bot solicita reenv√≠o de mensaje del canal
+4. Admin reenv√≠a mensaje del canal objetivo
+5. Bot extrae ID del canal del mensaje reenviado
+6. Bot verifica permisos del bot en el canal
+7. Bot guarda configuraci√≥n si todo es v√°lido
+8. Bot limpia estado FSM y actualiza men√∫
 
----
+### Generaci√≥n de Tokens
 
-**√öltima actualizaci√≥n:** 2025-12-11
-**Versi√≥n:** 1.0.0
+1. Admin selecciona "Generar Token"
+2. Bot verifica que canal VIP est√© configurado
+3. Bot genera token √∫nico con duraci√≥n configurable
+4. Bot guarda token en BD
+5. Bot env√≠a token al admin
\ No newline at end of file
diff --git a/docs/ARCHITECTURE.md b/docs/ARCHITECTURE.md
index 8ca67a9..c7fe527 100644
--- a/docs/ARCHITECTURE.md
+++ b/docs/ARCHITECTURE.md
@@ -211,44 +211,1299 @@ async def command_handler(message: Message, session: AsyncSession) -> None:
         await message.answer("Error procesando comando")
 ```
 
+### 4.1 Admin Handler (T12)
+
+**Responsabilidad:** Handler del comando /admin que muestra el men√∫ principal de administraci√≥n con navegaci√≥n, verificaci√≥n de estado de configuraci√≥n y teclado inline
+
+**Componentes:**
+- `bot/handlers/admin/main.py` - Handler principal y callbacks de navegaci√≥n
+
+**Caracter√≠sticas:**
+- **Navegaci√≥n del men√∫ principal:** Permite navegar entre diferentes secciones de administraci√≥n con estado de configuraci√≥n
+- **Aplicaci√≥n de middlewares:** Utiliza AdminAuthMiddleware y DatabaseMiddleware para protecci√≥n y acceso a base de datos
+- **Verificaci√≥n de estado de configuraci√≥n:** Muestra estado actual de configuraci√≥n del bot (completo o incompleto)
+- **Callback handlers:** Implementa manejadores de callback para navegaci√≥n entre men√∫s
+- **Teclado inline:** Proporciona opciones de administraci√≥n a trav√©s de teclado inline
+
+**Flujo principal:**
+1. Usuario ejecuta `/admin` ‚Üí Handler verifica permisos y acceso a BD
+2. Bot verifica estado de configuraci√≥n (canal VIP, canal Free, tiempo de espera)
+3. Bot muestra men√∫ principal con estado actual
+4. Usuario selecciona opci√≥n ‚Üí Bot navega a submen√∫ correspondiente
+5. Usuario selecciona "Volver al Men√∫ Principal" ‚Üí Bot regresa al men√∫ principal
+
+**Estructura de callbacks:**
+- `admin:main` - Callback para volver al men√∫ principal
+- `admin:config` - Callback para ver configuraci√≥n detallada
+- `admin:vip` - Callback para gesti√≥n de canal VIP (futuro)
+- `admin:free` - Callback para gesti√≥n de canal Free (futuro)
+
+**Aplicaci√≥n de middlewares:**
+```python
+# Aplicar middlewares al router de admin (orden correcto)
+admin_router.message.middleware(DatabaseMiddleware())
+admin_router.message.middleware(AdminAuthMiddleware())
+admin_router.callback_query.middleware(DatabaseMiddleware())
+admin_router.callback_query.middleware(AdminAuthMiddleware())
+```
+
+**Flujo de verificaci√≥n de estado de configuraci√≥n:**
+1. Handler llama a `container.config.get_config_status()`
+2. Servicio retorna diccionario con estado de configuraci√≥n
+3. Handler construye mensaje con estado actual
+4. Bot env√≠a mensaje con informaci√≥n de configuraci√≥n completa o incompleta
+
+**Navegaci√≥n entre men√∫s usando callbacks:**
+```python
+# Callback para volver al men√∫ principal
+@admin_router.callback_query(F.data == "admin:main")
+async def callback_admin_main(callback: CallbackQuery, session: AsyncSession):
+    # Crear container de services
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫ (mismo que cmd_admin)
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    # Editar mensaje existente (no enviar nuevo)
+    await callback.message.edit_text(
+        text=text,
+        reply_markup=admin_main_menu_keyboard(),
+        parse_mode="HTML"
+    )
+
+    # Responder al callback (quitar "loading" del bot√≥n)
+    await callback.answer()
+```
+
+**Uso del ServiceContainer en los handlers:**
+```python
+# Crear container de servicios con sesi√≥n de BD y bot
+container = ServiceContainer(session, message.bot)
+
+# Acceder a servicios espec√≠ficos
+config_status = await container.config.get_config_status()
+```
+
+**Interacci√≥n con teclados inline:**
+- `admin_main_menu_keyboard()` - Teclado con opciones principales de administraci√≥n
+- `back_to_main_menu_keyboard()` - Teclado con bot√≥n para volver al men√∫ principal
+- `yes_no_keyboard()` - Teclado para confirmaciones (usado en operaciones futuras)
+
+**Ejemplo completo de handler:**
+```python
+@admin_router.message(Command("admin"))
+async def cmd_admin(message: Message, session: AsyncSession):
+    """
+    Handler del comando /admin.
+
+    Muestra el men√∫ principal de administraci√≥n con estado de configuraci√≥n.
+    """
+    logger.info(f"üìã Admin panel abierto por user {message.from_user.id}")
+
+    # Crear container de services
+    container = ServiceContainer(session, message.bot)
+
+    # Verificar estado de configuraci√≥n
+    config_status = await container.config.get_config_status()
+
+    # Construir texto del men√∫
+    if config_status["is_configured"]:
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            "‚úÖ Bot configurado correctamente\n\n"
+            "Selecciona una opci√≥n:"
+        )
+    else:
+        missing_items = ", ".join(config_status["missing"])
+        text = (
+            "ü§ñ <b>Panel de Administraci√≥n</b>\n\n"
+            f"‚ö†Ô∏è <b>Configuraci√≥n incompleta</b>\n"
+            f"Faltante: {missing_items}\n\n"
+            "Selecciona una opci√≥n para configurar:"
+        )
+
+    await message.answer(
+        text=text,
+        reply_markup=admin_main_menu_keyboard(),
+        parse_mode="HTML"
+    )
+```
+
 ### 5. Middlewares
 
 **Responsabilidad:** Interceptar y procesar updates antes de handlers
 
-**Middlewares Planeados:**
-- `AdminAuthMiddleware` - Validar que usuario es admin
-- `DatabaseMiddleware` - Inyectar AsyncSession en contexto
+**Middlewares Implementados:**
+
+#### AdminAuthMiddleware (T10)
+
+**Responsabilidad:** Validar que el usuario tenga permisos de administrador antes de ejecutar handlers protegidos
+
+**Caracter√≠sticas:**
+- **Validaci√≥n autom√°tica:** Verifica si el user_id est√° en la lista de `Config.ADMIN_USER_IDS`
+- **Manejo de eventos:** Soporta tanto `Message` como `CallbackQuery` de Telegram
+- **Mensajes de error:** Env√≠a mensajes apropiados cuando el acceso es denegado
+- **Logging:** Registra intentos de acceso no autorizados con nivel de advertencia
+- **Interrupci√≥n de flujo:** Si el usuario no es admin, no ejecuta el handler original
+
+**Flujo de operaci√≥n:**
+1. Middleware intercepta el evento (Message o CallbackQuery)
+2. Extrae el user_id del evento
+3. Verifica si el user_id est√° en la lista de administradores
+4. Si es admin: ejecuta el handler original
+5. Si no es admin: env√≠a mensaje de error y retorna None (no ejecuta handler)
+
+**Ejemplo de aplicaci√≥n:**
+```python
+# En un router de administraci√≥n
+admin_router = Router()
+admin_router.message.middleware(AdminAuthMiddleware())
+admin_router.callback_query.middleware(AdminAuthMiddleware())
+
+# Handler protegido por middleware
+@admin_router.message(Command("admin_panel"))
+async def admin_panel_handler(message: Message, session: AsyncSession):
+    # Este handler solo se ejecuta si el usuario es admin
+    await message.answer("Panel de administraci√≥n")
+```
+
+**Tipos de respuesta seg√∫n evento:**
+- Para `Message`: Env√≠a respuesta con `event.answer()` en formato HTML
+- Para `CallbackQuery`: Env√≠a respuesta con `event.answer(show_alert=True)` como alerta
+
+#### DatabaseMiddleware (T10)
 
-**Patr√≥n (Fase 1.4):**
+**Responsabilidad:** Inyectar autom√°ticamente una sesi√≥n de base de datos en cada handler que lo requiera
+
+**Caracter√≠sticas:**
+- **Inyecci√≥n autom√°tica:** Coloca una instancia de `AsyncSession` en el diccionario `data`
+- **Context manager:** Utiliza `async with get_session()` para manejo autom√°tico de recursos
+- **Commit autom√°tico:** Realiza commit si no hay excepciones
+- **Rollback autom√°tico:** Realiza rollback si ocurre una excepci√≥n
+- **Cierre autom√°tico:** Cierra la sesi√≥n al salir del contexto
+- **Logging de errores:** Registra errores ocurridos durante la ejecuci√≥n del handler
+
+**Flujo de operaci√≥n:**
+1. Middleware crea una nueva sesi√≥n de base de datos
+2. Inyecta la sesi√≥n en `data["session"]`
+3. Ejecuta el handler original con la sesi√≥n disponible
+4. Si no hay excepciones: realiza commit autom√°tico
+5. Si hay excepci√≥n: realiza rollback y propaga la excepci√≥n
+6. Cierra la sesi√≥n al finalizar
+
+**Ejemplo de aplicaci√≥n:**
+```python
+# Aplicar al dispatcher para que todos los handlers tengan acceso a la sesi√≥n
+dispatcher.update.middleware(DatabaseMiddleware())
+
+# Handler que recibe la sesi√≥n autom√°ticamente
+async def user_data_handler(message: Message, session: AsyncSession):
+    # La sesi√≥n est√° disponible autom√°ticamente gracias al middleware
+    result = await session.execute(select(User).where(User.id == message.from_user.id))
+    user = result.scalar_one_or_none()
+
+    if user:
+        await message.answer(f"Datos del usuario: {user.name}")
+    else:
+        await message.answer("Usuario no encontrado")
+```
+
+**Patr√≥n de implementaci√≥n:**
 ```python
 class DatabaseMiddleware(BaseMiddleware):
-    async def __call__(self, handler, event, data):
+    async def __call__(
+        self,
+        handler: Callable[[TelegramObject, Dict[str, Any]], Awaitable[Any]],
+        event: TelegramObject,
+        data: Dict[str, Any]
+    ) -> Any:
         async with get_session() as session:
             data["session"] = session
-            return await handler(event, data)
+
+            try:
+                return await handler(event, data)
+            except Exception as e:
+                logger.error(f"‚ùå Error en handler con sesi√≥n DB: {e}", exc_info=True)
+                raise
 ```
 
+#### Aplicaci√≥n combinada de ambos middlewares
+
+Cuando ambos middlewares se aplican juntos, se forma una cadena de procesamiento:
+
+```
+1. Evento entrante (Message/CallbackQuery)
+   ‚Üì
+2. AdminAuthMiddleware: Valida permisos de admin
+   ‚Üì (si es admin, contin√∫a; si no, interrumpe)
+3. DatabaseMiddleware: Inyecta sesi√≥n de base de datos
+   ‚Üì
+4. Handler: Recibe evento + sesi√≥n, ejecuta l√≥gica
+```
+
+**Ejemplo completo de uso combinado:**
+```python
+from aiogram import Router
+from aiogram.types import Message
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares.admin_auth import AdminAuthMiddleware
+from bot.middlewares.database import DatabaseMiddleware
+
+# Router para comandos de administrador
+admin_router = Router()
+
+# Aplicar ambos middlewares
+admin_router.message.middleware(AdminAuthMiddleware())      # Valida permisos
+admin_router.callback_query.middleware(AdminAuthMiddleware())  # Valida permisos
+# La sesi√≥n se inyectar√° autom√°ticamente gracias al DatabaseMiddleware
+# aplicado al dispatcher.update.middleware(DatabaseMiddleware())
+
+@admin_router.message(Command("admin_stats"))
+async def admin_stats_handler(message: Message, session: AsyncSession):
+    # Este handler solo se ejecuta si:
+    # 1. El usuario es admin (validado por AdminAuthMiddleware)
+    # 2. Tiene acceso a la sesi√≥n de BD (inyectada por DatabaseMiddleware)
+
+    # Usar la sesi√≥n para obtener estad√≠sticas
+    stats = await get_statistics_from_db(session)
+
+    await message.answer(
+        f"üìä Estad√≠sticas del bot:\n{stats}",
+        parse_mode="HTML"
+    )
+```
+
+**Beneficios de la arquitectura de middlewares:**
+- **Separaci√≥n de preocupaciones:** L√≥gica de autenticaci√≥n y base de datos separada de la l√≥gica de negocio
+- **Reutilizaci√≥n:** Los mismos middlewares se pueden aplicar a m√∫ltples routers/handlers
+- **Facilidad de mantenimiento:** Cambios en la autenticaci√≥n o manejo de BD se hacen en un solo lugar
+- **Consistencia:** Todos los handlers protegidos y con acceso a BD siguen el mismo patr√≥n
+- **Seguridad:** Prevenci√≥n autom√°tica de accesos no autorizados
+- **Gesti√≥n de recursos:** Manejo autom√°tico de sesiones de base de datos
+
 ### 6. States (FSM)
 
 **Responsabilidad:** Gestionar estado de conversaci√≥n de usuarios
 
 **Storage:** MemoryStorage (ligero para Termux)
 
-**Estados Planeados:**
+**Estados Implementados:**
+
+#### ChannelSetupStates
+Estados para configurar canales VIP y Free.
+
+**Flujo t√≠pico:**
+1. Admin selecciona "Configurar Canal VIP"
+2. Bot entra en estado waiting_for_vip_channel
+3. Admin reenv√≠a mensaje del canal
+4. Bot extrae ID del canal y configura
+5. Bot sale del estado (clear state)
+
+**Extracci√≥n de ID:**
+- Usuario reenv√≠a mensaje del canal ‚Üí Bot extrae forward_from_chat.id
+- ID extra√≠do es negativo y empieza con -100
+- Si no es forward o no es de canal ‚Üí Error claro
+
+**Estados disponibles:**
+- `waiting_for_vip_channel` - Esperando que admin reenv√≠e mensaje del canal VIP
+- `waiting_for_free_channel` - Esperando que admin reenv√≠e mensaje del canal Free
+
+**Ejemplo de uso:**
+```python
+from aiogram.fsm.context import FSMContext
+from bot.states.admin import ChannelSetupStates
+
+@admin_router.message(Command("setup_vip_channel"))
+async def setup_vip_channel_start(message: Message, state: FSMContext):
+    await message.answer("Por favor, reenv√≠a un mensaje del canal VIP para extraer su ID:")
+    await state.set_state(ChannelSetupStates.waiting_for_vip_channel)
+
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel, F.forward_from_chat)
+async def process_vip_channel(message: Message, state: FSMContext):
+    channel_id = str(message.forward_from_chat.id)
+
+    # Validar que sea un canal y no un grupo
+    if int(channel_id) < 0 and channel_id.startswith('-100'):
+        # Procesar configuraci√≥n del canal VIP
+        success, msg = await container.channel.setup_vip_channel(channel_id)
+        if success:
+            await message.answer(f"‚úÖ Canal VIP configurado exitosamente: {channel_id}")
+        else:
+            await message.answer(f"‚ùå Error: {msg}")
+    else:
+        await message.answer("‚ùå El ID no corresponde a un canal v√°lido. Int√©ntalo de nuevo:")
+        return  # Mantener estado para reintentar
+
+    await state.clear()  # Salir del estado FSM
+
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def invalid_vip_channel(message: Message):
+    await message.answer("‚ö†Ô∏è Por favor, reenv√≠a un mensaje del canal VIP (no un mensaje normal).")
+```
+
+#### WaitTimeSetupStates
+Estados para configurar tiempo de espera del canal Free.
+
+**Flujo:**
+1. Admin selecciona "Configurar Tiempo de Espera"
+2. Bot entra en estado waiting_for_minutes
+3. Admin env√≠a n√∫mero de minutos
+4. Bot valida y guarda
+5. Bot sale del estado
+
+**Validaci√≥n de Minutos:**
+- Usuario env√≠a texto ‚Üí Bot intenta convertir a int
+- Valor debe ser >= 1
+- Si no es n√∫mero o es inv√°lido ‚Üí Error y mantener estado
+
+**Estados disponibles:**
+- `waiting_for_minutes` - Esperando que admin env√≠e n√∫mero de minutos
+
+**Ejemplo de uso:**
+```python
+from bot.states.admin import WaitTimeSetupStates
+
+@admin_router.message(Command("set_wait_time"))
+async def set_wait_time_start(message: Message, state: FSMContext):
+    current_time = await container.config.get_wait_time()
+    await message.answer(
+        f"‚è∞ Tiempo actual de espera: {current_time} minutos\n\n"
+        "Ingresa el nuevo tiempo de espera en minutos (m√≠nimo 1):"
+    )
+    await state.set_state(WaitTimeSetupStates.waiting_for_minutes)
+
+@admin_router.message(WaitTimeSetupStates.waiting_for_minutes)
+async def process_wait_time(message: Message, state: FSMContext):
+    try:
+        minutes = int(message.text.strip())
+        if minutes < 1:
+            await message.answer("‚ùå El tiempo debe ser al menos 1 minuto. Int√©ntalo de nuevo:")
+            return  # Mantener estado para reintentar
+
+        await container.config.set_wait_time(minutes)
+        await message.answer(f"‚úÖ Tiempo de espera actualizado a {minutes} minutos.")
+        await state.clear()
+
+    except ValueError:
+        await message.answer("‚ùå Por favor, ingresa un n√∫mero v√°lido de minutos:")
+```
+
+#### BroadcastStates
+Estados para env√≠o de publicaciones a canales.
+
+**Flujo:**
+1. Admin selecciona "Enviar a Canal VIP"
+2. Bot entra en estado waiting_for_content
+3. Admin env√≠a mensaje (texto, foto o video)
+4. Bot pide confirmaci√≥n (opcional)
+5. Bot env√≠a al canal y sale del estado
+
+**Tipos de Contenido:**
+- Soportar: texto, foto, video
+- Estado waiting_for_content acepta cualquiera
+- Estado waiting_for_confirmation es opcional (puede omitirse)
+
+**Estados disponibles:**
+- `waiting_for_content` - Esperando contenido del mensaje a enviar
+- `waiting_for_confirmation` - Esperando confirmaci√≥n de env√≠o (opcional)
+
+**Ejemplo de uso:**
+```python
+from bot.states.admin import BroadcastStates
+
+@admin_router.message(Command("broadcast_vip"))
+async def broadcast_vip_start(message: Message, state: FSMContext):
+    await message.answer("üì§ Por favor, env√≠a el contenido que deseas publicar en el canal VIP:")
+    await state.set_state(BroadcastStates.waiting_for_content)
+
+@admin_router.message(BroadcastStates.waiting_for_content)
+async def process_broadcast_content(message: Message, state: FSMContext):
+    # Almacenar el contenido del mensaje en el estado
+    content_data = {
+        'text': getattr(message, 'text', getattr(message, 'caption', '')),
+        'photo': getattr(message, 'photo', None),
+        'video': getattr(message, 'video', None),
+        'document': getattr(message, 'document', None)
+    }
+
+    # Guardar contenido en el estado para uso posterior
+    await state.update_data(content=content_data)
+
+    # Confirmar antes de enviar
+    await message.answer("üìã ¬øDeseas enviar este contenido al canal VIP ahora?\n\n"
+                        "Responde 'S√≠' para confirmar o 'No' para cancelar:")
+    await state.set_state(BroadcastStates.waiting_for_confirmation)
+
+@admin_router.message(BroadcastStates.waiting_for_confirmation, F.text.lower() == "s√≠")
+async def confirm_broadcast(message: Message, state: FSMContext):
+    data = await state.get_data()
+    content = data.get('content', {})
+
+    channel_id = await container.channel.get_vip_channel_id()
+    if not channel_id:
+        await message.answer("‚ùå Canal VIP no configurado. Config√∫ralo primero.")
+        await state.clear()
+        return
+
+    # Enviar contenido al canal
+    success, result, sent_msg = await container.channel.send_to_channel(
+        channel_id=channel_id,
+        text=content['text'],
+        photo=content.get('photo'),
+        video=content.get('video')
+    )
+
+    if success:
+        await message.answer("‚úÖ Contenido enviado exitosamente al canal VIP.")
+    else:
+        await message.answer(f"‚ùå Error al enviar contenido: {result}")
+
+    await state.clear()
+
+@admin_router.message(BroadcastStates.waiting_for_confirmation, F.text.lower() == "no")
+async def cancel_broadcast(message: Message, state: FSMContext):
+    await message.answer("‚ùå Env√≠o cancelado.")
+    await state.clear()
+```
+
+#### TokenRedemptionStates
+Estados para canje de tokens VIP.
 
-**AdminStates:**
-- `admin_menu` - Men√∫ principal
-- `selecting_token_type` - Eligiendo tipo de token
-- `entering_token_duration` - Ingresando duraci√≥n
-- `confirming_token_creation` - Confirmando creaci√≥n
-- `viewing_token_list` - Visualizando tokens
-- etc.
+**Flujo:**
+1. Usuario env√≠a /start
+2. Bot pregunta por token
+3. Bot entra en estado waiting_for_token
+4. Usuario env√≠a token
+5. Bot valida y canjea
+6. Bot sale del estado
 
-**UserStates:**
-- `user_menu` - Men√∫ principal
-- `entering_vip_token` - Ingresando token VIP
-- `requesting_free_access` - Solicitando acceso Free
-- etc.
+**Validaci√≥n de Token:**
+- Usuario env√≠a texto ‚Üí Bot valida formato y existe en BD
+- Token debe estar vigente (no expirado)
+- Token debe no estar ya canjeado
+- Si token es inv√°lido ‚Üí Error claro y mantener estado
+
+**Estados disponibles:**
+- `waiting_for_token` - Esperando que usuario env√≠e token
+
+**Ejemplo de uso:**
+```python
+from bot.states.user import TokenRedemptionStates
+
+@user_router.message(Command("vip"))
+async def request_vip_token(message: Message, state: FSMContext):
+    await message.answer("üîê Ingresa tu token VIP para canjear acceso:")
+    await state.set_state(TokenRedemptionStates.waiting_for_token)
+
+@user_router.message(TokenRedemptionStates.waiting_for_token)
+async def process_vip_token(message: Message, state: FSMContext, session: AsyncSession):
+    token_str = message.text.strip()
+
+    # Validar token
+    is_valid, validation_msg, token_obj = await container.subscription.validate_token(token_str)
+
+    if not is_valid:
+        await message.answer(f"‚ùå {validation_msg}\n\nIntenta de nuevo:")
+        return  # Mantener estado para reintentar
+
+    # Canjear token
+    success, redeem_msg, subscriber = await container.subscription.redeem_vip_token(
+        token_str=token_str,
+        user_id=message.from_user.id
+    )
+
+    if success:
+        # Crear enlace de invitaci√≥n
+        invite_link = await container.subscription.create_invite_link(
+            channel_id=await container.channel.get_vip_channel_id(),
+            user_id=message.from_user.id,
+            expire_hours=token_obj.duration_hours
+        )
+
+        await message.answer(
+            f"‚úÖ ¬°Acceso VIP concedido!\n\n"
+            f"{redeem_msg}\n"
+            f"Enlace de acceso: {invite_link}"
+        )
+    else:
+        await message.answer(f"‚ùå Error al canjear token: {redeem_msg}")
+
+    await state.clear()
+```
+
+#### FreeAccessStates
+Estados para solicitud de acceso Free.
+
+**Flujo:**
+1. Usuario solicita acceso Free
+2. Bot crea solicitud
+3. Bot puede usar estado para tracking (opcional)
+
+**Nota:** Este flujo es mayormente autom√°tico (background task),
+pero el estado se puede usar para prevenir spam de solicitudes.
+
+**Estados disponibles:**
+- `waiting_for_approval` - Usuario tiene solicitud pendiente
+
+**Ejemplo de uso:**
+```python
+from bot.states.user import FreeAccessStates
+
+@user_router.message(Command("free"))
+async def request_free_access(message: Message, state: FSMContext, session: AsyncSession):
+    user_id = message.from_user.id
+
+    # Verificar si ya tiene solicitud pendiente
+    existing_request = await container.subscription.get_pending_free_request(user_id)
+    if existing_request:
+        remaining_minutes = await container.subscription.get_remaining_wait_time(
+            existing_request,
+            await container.config.get_wait_time()
+        )
+        await message.answer(
+            f"‚è≥ Ya tienes una solicitud pendiente de acceso Free.\n"
+            f"Tiempo restante: {remaining_minutes} minutos."
+        )
+        return
+
+    # Crear nueva solicitud
+    request = await container.subscription.create_free_request(user_id)
+
+    # Poner usuario en estado de espera
+    await state.set_state(FreeAccessStates.waiting_for_approval)
+
+    # Informar tiempo de espera
+    wait_time = await container.config.get_wait_time()
+    await message.answer(
+        f"‚úÖ Solicitud de acceso Free registrada.\n"
+        f"‚è∞ Tiempo de espera estimado: {wait_time} minutos.\n\n"
+        f"Ser√°s notificado cuando est√© listo."
+    )
+
+    # El proceso de aprobaci√≥n ocurre en background
+    # No se limpia el estado hasta que se procese la solicitud
+```
+
+### 4.2 VIP Handler (T13)
+
+**Responsabilidad:** Handlers del submen√∫ VIP que gestionan el canal VIP con generaci√≥n de tokens de invitaci√≥n, configuraci√≥n del canal VIP por reenv√≠o de mensajes y generaci√≥n de tokens VIP con duraci√≥n configurable
+
+**Componentes:**
+- `bot/handlers/admin/vip.py` - Handlers principales y callbacks de navegaci√≥n para el canal VIP
+
+**Caracter√≠sticas:**
+- **Submen√∫ VIP:** Gesti√≥n del canal VIP con generaci√≥n de tokens de invitaci√≥n
+- **Configuraci√≥n del canal VIP:** Configuraci√≥n del canal VIP por reenv√≠o de mensajes
+- **Generaci√≥n de tokens de invitaci√≥n:** Creaci√≥n de tokens VIP con duraci√≥n configurable
+- **Uso de FSM:** Utiliza ChannelSetupStates para el flujo de configuraci√≥n del canal
+- **Interacci√≥n con teclados inline:** Proporciona opciones de administraci√≥n a trav√©s de teclado inline
+- **Verificaci√≥n de configuraci√≥n:** Verifica que el canal VIP est√© configurado antes de permitir ciertas operaciones
+
+**Flujo principal:**
+1. Usuario admin ejecuta callback `admin:vip` ‚Üí Handler verifica permisos y acceso a BD
+2. Bot verifica estado de configuraci√≥n del canal VIP
+3. Bot muestra men√∫ VIP con estado actual del canal
+4. Usuario selecciona opci√≥n (generar token o configurar canal)
+5. Usuario selecciona "Volver al Men√∫ Principal" ‚Üí Bot regresa al men√∫ principal
+
+**Estructura de callbacks:**
+- `admin:vip` - Callback para mostrar el men√∫ VIP
+- `vip:setup` - Callback para iniciar configuraci√≥n del canal VIP
+- `vip:generate_token` - Callback para generar token VIP
+
+**Aplicaci√≥n de FSM:**
+```python
+# Aplicar estados FSM para configuraci√≥n del canal VIP
+@admin_router.message(ChannelSetupStates.waiting_for_vip_channel)
+async def process_vip_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal VIP.
+
+    Extrae el ID del canal del forward y lo configura.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Verificar que es un forward de un canal
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal VIP.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    # Verificar que es un canal (no grupo ni usuario)
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal VIP.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal VIP: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_vip_channel(channel_id)
+
+    if success:
+        # Configuraci√≥n exitosa
+        await message.answer(
+            f"‚úÖ <b>Canal VIP Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Ya puedes generar tokens de invitaci√≥n.",
+            parse_mode="HTML",
+            reply_markup=vip_menu_keyboard(True)
+        )
+
+        # Limpiar estado FSM
+        await state.clear()
+    else:
+        # Error en configuraci√≥n
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica que:\n"
+            f"‚Ä¢ El bot es administrador del canal\n"
+            f"‚Ä¢ El bot tiene permiso para invitar usuarios\n\n"
+            f"Intenta nuevamente reenviando un mensaje del canal.",
+            parse_mode="HTML"
+        )
+        # Mantener estado FSM para reintentar
+```
+
+**Flujo de generaci√≥n de tokens VIP:**
+1. Usuario admin selecciona "Generar Token de Invitaci√≥n"
+2. Bot verifica que canal VIP est√° configurado
+3. Bot genera token √∫nico con duraci√≥n configurable
+4. Bot responde con el token y su informaci√≥n
+
+**Ejemplo de generaci√≥n de token:**
+```python
+@admin_router.callback_query(F.data == "vip:generate_token")
+async def callback_generate_vip_token(
+    callback: CallbackQuery,
+    session: AsyncSession
+):
+    """
+    Genera un token de invitaci√≥n VIP.
+
+    Token v√°lido por 24 horas, un solo uso.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+    """
+    logger.info(f"üéüÔ∏è Usuario {callback.from_user.id} generando token VIP")
+
+    container = ServiceContainer(session, callback.bot)
+
+    # Verificar que canal VIP est√° configurado
+    if not await container.channel.is_vip_channel_configured():
+        await callback.answer(
+            "‚ùå Debes configurar el canal VIP primero",
+            show_alert=True
+        )
+        return
+
+    try:
+        # Generar token (24 horas por defecto)
+        token = await container.subscription.generate_vip_token(
+            generated_by=callback.from_user.id,
+            duration_hours=Config.DEFAULT_TOKEN_DURATION_HOURS
+        )
+
+        # Crear mensaje con el token
+        token_message = (
+            f"üéüÔ∏è <b>Token VIP Generado</b>\n\n"
+            f"Token: <code>{token.token}</code>\n\n"
+            f"‚è±Ô∏è V√°lido por: {token.duration_hours} horas\n"
+            f"üìÖ Expira: {token.created_at.strftime('%Y-%m-%d %H:%M')} UTC\n\n"
+            f"üëâ Comparte este token con el usuario.\n"
+            f"El usuario debe enviarlo al bot para canjear acceso VIP."
+        )
+
+        await callback.message.answer(
+            text=token_message,
+            parse_mode="HTML"
+        )
+
+        await callback.answer("‚úÖ Token generado")
+
+    except Exception as e:
+        logger.error(f"Error generando token VIP: {e}", exc_info=True)
+        await callback.answer(
+            "‚ùå Error al generar token. Intenta nuevamente.",
+            show_alert=True
+        )
+```
+
+**Uso del ServiceContainer en los handlers VIP:**
+```python
+# Crear container de servicios con sesi√≥n de BD y bot
+container = ServiceContainer(session, callback.bot)
+
+# Acceder a servicios espec√≠ficos
+is_configured = await container.channel.is_vip_channel_configured()
+token = await container.subscription.generate_vip_token(...)
+```
+
+**Interacci√≥n con teclados inline VIP:**
+```python
+def vip_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ VIP.
+
+    Args:
+        is_configured: Si el canal VIP est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones VIP
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "üéüÔ∏è Generar Token de Invitaci√≥n", "callback_data": "vip:generate_token"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "vip:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal VIP", "callback_data": "vip:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+```
+
+### 4.3 Free Handler (T13)
+
+**Responsabilidad:** Handlers del submen√∫ Free que gestionan el canal Free con configuraci√≥n de tiempo de espera, configuraci√≥n del canal Free por reenv√≠o de mensajes y configuraci√≥n de tiempo de espera para acceso Free
+
+### 4.4 User Handler (T14)
+
+**Responsabilidad:** Handler del comando /start que detecta el rol del usuario y proporciona flujos para canje de tokens VIP y solicitud de acceso Free
+
+**Componentes:**
+- `bot/handlers/user/start.py` - Handler principal del comando /start
+- `bot/handlers/user/vip_flow.py` - Flujo de canje de tokens VIP
+- `bot/handlers/user/free_flow.py` - Flujo de solicitud de acceso Free
+
+**Caracter√≠sticas:**
+- **Handler /start:** Punto de entrada para usuarios con detecci√≥n de rol (admin/VIP/usuario)
+- **Flujo VIP:** Canje de tokens VIP con validaci√≥n y generaci√≥n de invite links
+- **Flujo Free:** Solicitud de acceso Free con tiempo de espera y notificaciones autom√°ticas
+- **Middleware de base de datos:** Inyecci√≥n de sesiones sin autenticaci√≥n de admin
+- **FSM para validaci√≥n de tokens:** Estados para manejo de entrada de tokens
+- **Validaci√≥n de configuraci√≥n:** Verificaci√≥n de canales configurados antes de procesar
+
+**Flujo principal:**
+1. Usuario ejecuta `/start` ‚Üí Handler verifica acceso a BD
+2. Bot detecta rol del usuario (admin, VIP, usuario normal)
+3. Si es admin: redirige a `/admin`
+4. Si es VIP: muestra mensaje de bienvenida con d√≠as restantes
+5. Si es usuario normal: muestra men√∫ con opciones VIP/Free
+6. Usuario selecciona opci√≥n ‚Üí Bot inicia flujo correspondiente
+
+**Estructura de callbacks:**
+- `user:redeem_token` - Callback para iniciar flujo de canje de token VIP
+- `user:request_free` - Callback para iniciar flujo de solicitud Free
+- `user:cancel` - Callback para cancelar flujo actual
+
+**Aplicaci√≥n de FSM:**
+```python
+# Aplicar estados FSM para canje de tokens VIP
+@user_router.message(TokenRedemptionStates.waiting_for_token)
+async def process_token_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el token enviado por el usuario.
+
+    Valida el token, lo canjea y env√≠a invite link.
+
+    Args:
+        message: Mensaje con el token
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    user_id = message.from_user.id
+    token_str = message.text.strip()
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar canjear token
+    success, msg, subscriber = await container.subscription.redeem_vip_token(
+        token_str=token_str,
+        user_id=user_id
+    )
+
+    if not success:
+        # Token inv√°lido
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica el token e intenta nuevamente.\n\n"
+            f"Si el problema persiste, contacta al administrador.",
+            parse_mode="HTML"
+        )
+        # Mantener estado para reintentar
+        return
+
+    # Token v√°lido: crear invite link
+    vip_channel_id = await container.channel.get_vip_channel_id()
+
+    try:
+        invite_link = await container.subscription.create_invite_link(
+            channel_id=vip_channel_id,
+            user_id=user_id,
+            expire_hours=1  # Link expira en 1 hora
+        )
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"‚úÖ <b>Token Canjeado Exitosamente!</b>\n\n"
+            f"üéâ Tu acceso VIP est√° activo\n"
+            f"‚è±Ô∏è Duraci√≥n: <b>{days_remaining} d√≠as</b>\n\n"
+            f"üëá Usa este link para unirte al canal VIP:\n"
+            f"{invite_link.invite_link}\n\n"
+            f"‚ö†Ô∏è <b>Importante:</b>\n"
+            f"‚Ä¢ El link expira en 1 hora\n"
+            f"‚Ä¢ Solo puedes usarlo 1 vez\n"
+            f"‚Ä¢ No lo compartas con otros\n\n"
+            f"Disfruta del contenido exclusivo! üöÄ",
+            parse_mode="HTML"
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error creando invite link para user {user_id}: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al crear el link de invitaci√≥n.\n\n"
+            "Tu token fue canjeado correctamente, pero hubo un problema t√©cnico.\n"
+            "Contacta al administrador.",
+            parse_mode="HTML"
+        )
+        await state.clear()
+```
+
+**Flujo de detecci√≥n de rol:**
+1. Usuario env√≠a `/start`
+2. Bot verifica si es admin usando `Config.is_admin()`
+3. Si es admin: redirige a panel de administraci√≥n
+4. Si no es admin: verifica si es VIP activo
+5. Si es VIP: muestra d√≠as restantes de suscripci√≥n
+6. Si no es VIP: muestra opciones de acceso (VIP/Free)
+
+**Ejemplo de detecci√≥n de rol:**
+```python
+@user_router.message(Command("start"))
+async def cmd_start(message: Message, session: AsyncSession):
+    """
+    Handler del comando /start para usuarios.
+
+    Comportamiento:
+    - Si es admin ‚Üí Redirige a /admin
+    - Si es VIP activo ‚Üí Muestra mensaje de bienvenida con d√≠as restantes
+    - Si no es admin ‚Üí Muestra men√∫ de usuario (VIP/Free)
+    """
+    user_id = message.from_user.id
+    user_name = message.from_user.first_name or "Usuario"
+
+    # Verificar si es admin
+    if Config.is_admin(user_id):
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"Eres administrador. Usa /admin para gestionar los canales.",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario normal: verificar si es VIP activo
+    container = ServiceContainer(session, message.bot)
+
+    is_vip = await container.subscription.is_vip_active(user_id)
+
+    if is_vip:
+        # Usuario ya tiene acceso VIP
+        subscriber = await container.subscription.get_vip_subscriber(user_id)
+
+        # Calcular d√≠as restantes
+        if subscriber and hasattr(subscriber, 'expiry_date') and subscriber.expiry_date:
+            from datetime import datetime, timezone
+            days_remaining = max(0, (subscriber.expiry_date - datetime.now(timezone.utc)).days)
+        else:
+            days_remaining = 0
+
+        await message.answer(
+            f"üëã Hola <b>{user_name}</b>!\n\n"
+            f"‚úÖ Tienes acceso VIP activo\n"
+            f"‚è±Ô∏è D√≠as restantes: <b>{days_remaining}</b>\n\n"
+            f"Disfruta del contenido exclusivo! üéâ",
+            parse_mode="HTML"
+        )
+        return
+
+    # Usuario no es VIP: mostrar opciones
+    keyboard = create_inline_keyboard([
+        [{"text": "üéüÔ∏è Canjear Token VIP", "callback_data": "user:redeem_token"}],
+        [{"text": "üì∫ Solicitar Acceso Free", "callback_data": "user:request_free"}],
+    ])
+
+    await message.answer(
+        f"üëã Hola <b>{user_name}</b>!\n\n"
+        f"Bienvenido al bot de acceso a canales.\n\n"
+        f"<b>Opciones disponibles:</b>\n\n"
+        f"üéüÔ∏è <b>Canjear Token VIP</b>\n"
+        f"Si tienes un token de invitaci√≥n, canj√©alo para acceso VIP.\n\n"
+        f"üì∫ <b>Solicitar Acceso Free</b>\n"
+        f"Solicita acceso al canal gratuito (con tiempo de espera).\n\n"
+        f"üëâ Selecciona una opci√≥n:",
+        reply_markup=keyboard,
+        parse_mode="HTML"
+    )
+```
+
+**Uso del ServiceContainer en los handlers User:**
+```python
+# Crear container de servicios con sesi√≥n de BD y bot
+container = ServiceContainer(session, message.bot)
+
+# Acceder a servicios espec√≠ficos
+is_vip = await container.subscription.is_vip_active(user_id)
+subscriber = await container.subscription.get_vip_subscriber(user_id)
+success, msg, subscriber = await container.subscription.redeem_vip_token(token_str, user_id)
+is_configured = await container.channel.is_vip_channel_configured()
+wait_time = await container.config.get_wait_time()
+```
+
+**Interacci√≥n con teclados inline User:**
+```python
+# Teclado para opciones de usuario
+keyboard = create_inline_keyboard([
+    [{"text": "üéüÔ∏è Canjear Token VIP", "callback_data": "user:redeem_token"}],
+    [{"text": "üì∫ Solicitar Acceso Free", "callback_data": "user:request_free"}],
+])
+
+# Teclado para cancelar flujo
+cancel_keyboard = create_inline_keyboard([
+    [{"text": "‚ùå Cancelar", "callback_data": "user:cancel"}]
+])
+```
+
+**Flujo de canje de tokens VIP:**
+1. Usuario selecciona "Canjear Token VIP"
+2. Bot verifica que canal VIP est√© configurado
+3. Bot entra en estado FSM `waiting_for_token`
+4. Usuario env√≠a token
+5. Bot valida y canjea token
+6. Bot genera invite link √∫nico y lo env√≠a al usuario
+7. Bot limpia estado FSM
+
+**Flujo de solicitud Free:**
+1. Usuario selecciona "Solicitar Acceso Free"
+2. Bot verifica que canal Free est√© configurado
+3. Bot verifica si usuario ya tiene solicitud pendiente
+4. Si no tiene solicitud: crea nueva solicitud y notifica tiempo de espera
+5. Si ya tiene solicitud: muestra tiempo restante
+6. Proceso autom√°tico en background procesa solicitudes cuando cumplen tiempo
+
+**Validaci√≥n de configuraci√≥n:**
+- `is_vip_channel_configured()` - Verifica que canal VIP est√© configurado antes de permitir canje de tokens
+- `is_free_channel_configured()` - Verifica que canal Free est√© configurado antes de permitir solicitudes
+- `get_wait_time()` - Obtiene tiempo de espera configurado para solicitudes Free
+```
+
+### 4.5 Free Handler (T13)
+
+**Responsabilidad:** Handlers del submen√∫ Free que gestionan el canal Free con configuraci√≥n de tiempo de espera, configuraci√≥n del canal Free por reenv√≠o de mensajes y configuraci√≥n de tiempo de espera para acceso Free
+
+**Componentes:**
+- `bot/handlers/admin/free.py` - Handlers principales y callbacks de navegaci√≥n para el canal Free
+
+**Caracter√≠sticas:**
+- **Submen√∫ Free:** Gesti√≥n del canal Free con configuraci√≥n de tiempo de espera
+- **Configuraci√≥n del canal Free:** Configuraci√≥n del canal Free por reenv√≠o de mensajes
+- **Configuraci√≥n de tiempo de espera:** Configuraci√≥n de tiempo de espera para acceso Free
+- **Uso de FSM:** Utiliza ChannelSetupStates y WaitTimeSetupStates para flujos de configuraci√≥n
+- **Interacci√≥n con teclados inline:** Proporciona opciones de administraci√≥n a trav√©s de teclado inline
+- **Verificaci√≥n de configuraci√≥n:** Verifica que el canal Free est√© configurado antes de permitir ciertas operaciones
+
+**Flujo principal:**
+1. Usuario admin ejecuta callback `admin:free` ‚Üí Handler verifica permisos y acceso a BD
+2. Bot verifica estado de configuraci√≥n del canal Free y tiempo de espera
+3. Bot muestra men√∫ Free con estado actual del canal y tiempo de espera
+4. Usuario selecciona opci√≥n (configurar tiempo de espera o configurar canal)
+5. Usuario selecciona "Volver al Men√∫ Principal" ‚Üí Bot regresa al men√∫ principal
+
+**Estructura de callbacks:**
+- `admin:free` - Callback para mostrar el men√∫ Free
+- `free:setup` - Callback para iniciar configuraci√≥n del canal Free
+- `free:set_wait_time` - Callback para configurar tiempo de espera
+
+**Aplicaci√≥n de FSM:**
+```python
+# Aplicar estados FSM para configuraci√≥n del canal Free
+@admin_router.message(ChannelSetupStates.waiting_for_free_channel)
+async def process_free_channel_forward(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el mensaje reenviado para configurar el canal Free.
+
+    Args:
+        message: Mensaje reenviado del canal
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Validaciones id√©nticas a VIP
+    if not message.forward_from_chat:
+        await message.answer(
+            "‚ùå Debes <b>reenviar</b> un mensaje del canal Free.\n\n"
+            "No me env√≠es el ID manualmente, reenv√≠a un mensaje.",
+            parse_mode="HTML"
+        )
+        return
+
+    forward_chat = message.forward_from_chat
+
+    if forward_chat.type not in ["channel", "supergroup"]:
+        await message.answer(
+            "‚ùå El mensaje debe ser de un <b>canal</b> o <b>supergrupo</b>.\n\n"
+            "Reenv√≠a un mensaje del canal Free.",
+            parse_mode="HTML"
+        )
+        return
+
+    channel_id = str(forward_chat.id)
+    channel_title = forward_chat.title
+
+    logger.info(f"üì∫ Configurando canal Free: {channel_id} ({channel_title})")
+
+    container = ServiceContainer(session, message.bot)
+
+    # Intentar configurar el canal
+    success, msg = await container.channel.setup_free_channel(channel_id)
+
+    if success:
+        await message.answer(
+            f"‚úÖ <b>Canal Free Configurado</b>\n\n"
+            f"Canal: <b>{channel_title}</b>\n"
+            f"ID: <code>{channel_id}</code>\n\n"
+            f"Los usuarios ya pueden solicitar acceso.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        await state.clear()
+    else:
+        await message.answer(
+            f"{msg}\n\n"
+            f"Verifica permisos del bot e intenta nuevamente.",
+            parse_mode="HTML"
+        )
+```
+
+**Flujo de configuraci√≥n de tiempo de espera:**
+1. Usuario admin selecciona "Configurar Tiempo de Espera"
+2. Bot entra en estado FSM `waiting_for_minutes`
+3. Usuario env√≠a n√∫mero de minutos
+4. Bot valida y guarda el tiempo de espera
+5. Bot actualiza configuraci√≥n y sale del estado
+
+**Ejemplo de configuraci√≥n de tiempo de espera:**
+```python
+@admin_router.callback_query(F.data == "free:set_wait_time")
+async def callback_set_wait_time(
+    callback: CallbackQuery,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Inicia configuraci√≥n de tiempo de espera.
+
+    Args:
+        callback: Callback query
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    logger.info(f"‚è±Ô∏è Usuario {callback.from_user.id} configurando wait time")
+
+    container = ServiceContainer(session, callback.bot)
+    current_wait_time = await container.config.get_wait_time()
+
+    # Entrar en estado FSM
+    await state.set_state(WaitTimeSetupStates.waiting_for_minutes)
+
+    text = (
+        f"‚è±Ô∏è <b>Configurar Tiempo de Espera</b>\n\n"
+        f"Tiempo actual: <b>{current_wait_time} minutos</b>\n\n"
+        f"Env√≠a el nuevo tiempo de espera en minutos.\n"
+        f"Ejemplo: <code>5</code>\n\n"
+        f"El tiempo debe ser mayor o igual a 1 minuto."
+    )
+
+    try:
+        await callback.message.edit_text(
+            text=text,
+            reply_markup=create_inline_keyboard([
+                [{"text": "‚ùå Cancelar", "callback_data": "admin:free"}]
+            ]),
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        if "message is not modified" not in str(e):
+            logger.error(f"Error editando mensaje wait time: {e}")
+
+    await callback.answer()
+
+@admin_router.message(WaitTimeSetupStates.waiting_for_minutes)
+async def process_wait_time_input(
+    message: Message,
+    session: AsyncSession,
+    state: FSMContext
+):
+    """
+    Procesa el input de tiempo de espera.
+
+    Args:
+        message: Mensaje con los minutos
+        session: Sesi√≥n de BD
+        state: FSM context
+    """
+    # Intentar convertir a n√∫mero
+    try:
+        minutes = int(message.text)
+    except ValueError:
+        await message.answer(
+            "‚ùå Debes enviar un n√∫mero v√°lido.\n\n"
+            "Ejemplo: <code>5</code>",
+            parse_mode="HTML"
+        )
+        return
+
+    # Validar rango
+    if minutes < 1:
+        await message.answer(
+            "‚ùå El tiempo debe ser al menos 1 minuto.\n\n"
+            "Env√≠a un n√∫mero mayor o igual a 1.",
+            parse_mode="HTML"
+        )
+        return
+
+    container = ServiceContainer(session, message.bot)
+
+    try:
+        # Actualizar configuraci√≥n
+        await container.config.set_wait_time(minutes)
+
+        await message.answer(
+            f"‚úÖ <b>Tiempo de Espera Actualizado</b>\n\n"
+            f"Nuevo tiempo: <b>{minutes} minutos</b>\n\n"
+            f"Las nuevas solicitudes esperar√°n {minutes} minutos antes de procesarse.",
+            parse_mode="HTML",
+            reply_markup=free_menu_keyboard(True)
+        )
+
+        # Limpiar estado
+        await state.clear()
+
+    except Exception as e:
+        logger.error(f"Error actualizando wait time: {e}", exc_info=True)
+        await message.answer(
+            "‚ùå Error al actualizar el tiempo de espera.\n\n"
+            "Intenta nuevamente.",
+            parse_mode="HTML"
+        )
+```
+
+**Uso del ServiceContainer en los handlers Free:**
+```python
+# Crear container de servicios con sesi√≥n de BD y bot
+container = ServiceContainer(session, callback.bot)
+
+# Acceder a servicios espec√≠ficos
+is_configured = await container.channel.is_free_channel_configured()
+wait_time = await container.config.get_wait_time()
+await container.config.set_wait_time(minutes)
+```
+
+**Interacci√≥n con teclados inline Free:**
+```python
+def free_menu_keyboard(is_configured: bool) -> "InlineKeyboardMarkup":
+    """
+    Keyboard del submen√∫ Free.
+
+    Args:
+        is_configured: Si el canal Free est√° configurado
+
+    Returns:
+        InlineKeyboardMarkup con opciones Free
+    """
+    buttons = []
+
+    if is_configured:
+        buttons.extend([
+            [{"text": "‚è±Ô∏è Configurar Tiempo de Espera", "callback_data": "free:set_wait_time"}],
+            [{"text": "üîß Reconfigurar Canal", "callback_data": "free:setup"}],
+        ])
+    else:
+        buttons.append([{"text": "‚öôÔ∏è Configurar Canal Free", "callback_data": "free:setup"}])
+
+    buttons.append([{"text": "üîô Volver", "callback_data": "admin:main"}])
+
+    return create_inline_keyboard(buttons)
+```
+
+**Flujo de configuraci√≥n por reenv√≠o de mensajes:**
+1. Admin selecciona "Configurar Canal VIP" o "Configurar Canal Free"
+2. Bot entra en estado FSM correspondiente
+3. Admin reenv√≠a mensaje del canal objetivo
+4. Bot extrae ID del canal del mensaje reenviado
+5. Bot verifica permisos del bot en el canal
+6. Bot guarda configuraci√≥n si todo es v√°lido
+7. Bot limpia estado FSM y actualiza men√∫
 
 ### 7. Services
 
@@ -624,22 +1879,206 @@ print(summary)
 await container.config.reset_to_defaults()
 ```
 
-### 8. Background Tasks
+### 8. Background Tasks (T15)
 
-**Responsabilidad:** Tareas programadas asincr√≥nicas
+**Responsabilidad:** Tareas programadas asincr√≥nicas que realizan operaciones peri√≥dicas para mantener el sistema funcionando correctamente
 
-**Tareas Planeadas:**
-- `cleanup_expired_subscriptions()` - Marcar VIPs como expirados
-- `process_free_queue()` - Procesar cola de Free requests
-- `cleanup_expired_tokens()` - Eliminar tokens expirados
+**Tareas Implementadas:**
+- `expire_and_kick_vip_subscribers()` - Marcar VIPs expirados y expulsarlos del canal
+- `process_free_queue()` - Procesar cola de solicitudes Free que cumplieron tiempo de espera
+- `cleanup_old_data()` - Eliminar solicitudes Free procesadas hace m√°s de 30 d√≠as
 
-**Patr√≥n:**
+**Componentes:**
+```
+background/
+‚îú‚îÄ‚îÄ __init__.py
+‚îú‚îÄ‚îÄ tasks.py          # Tareas programadas y scheduler
+```
+
+**Arquitectura:**
 ```python
-@scheduler.scheduled_job('interval', minutes=60)
-async def cleanup_task():
-    async with get_session() as session:
-        # Procesar
-        pass
+import logging
+from typing import Optional
+from aiogram import Bot
+from apscheduler.schedulers.asyncio import AsyncIOScheduler
+from apscheduler.triggers.interval import IntervalTrigger
+from apscheduler.triggers.cron import CronTrigger
+
+# Scheduler global
+_scheduler: Optional[AsyncIOScheduler] = None
+
+async def expire_and_kick_vip_subscribers(bot: Bot):
+    """
+    Tarea: Expulsar suscriptores VIP expirados del canal.
+    """
+    logger.info("üîÑ Ejecutando tarea: Expulsi√≥n VIP expirados")
+
+    try:
+        async with get_session() as session:
+            container = ServiceContainer(session, bot)
+
+            # Verificar que canal VIP est√° configurado
+            vip_channel_id = await container.channel.get_vip_channel_id()
+
+            if not vip_channel_id:
+                logger.warning("‚ö†Ô∏è Canal VIP no configurado, saltando expulsi√≥n")
+                return
+
+            # Marcar como expirados
+            expired_count = await container.subscription.expire_vip_subscribers()
+
+            if expired_count > 0:
+                logger.info(f"‚è±Ô∏è {expired_count} suscriptor(es) VIP expirados")
+
+                # Expulsar del canal
+                kicked_count = await container.subscription.kick_expired_vip_from_channel(
+                    vip_channel_id
+                )
+
+                logger.info(f"‚úÖ {kicked_count} usuario(s) expulsados del canal VIP")
+            else:
+                logger.debug("‚úì No hay VIPs expirados")
+
+    except Exception as e:
+        logger.error(f"‚ùå Error en tarea de expulsi√≥n VIP: {e}", exc_info=True)
+
+def start_background_tasks(bot: Bot):
+    """
+    Inicia el scheduler con todas las tareas programadas.
+    """
+    global _scheduler
+
+    if _scheduler is not None:
+        logger.warning("‚ö†Ô∏è Scheduler ya est√° corriendo")
+        return
+
+    logger.info("üöÄ Iniciando background tasks...")
+
+    _scheduler = AsyncIOScheduler(timezone="UTC")
+
+    # Tarea 1: Expulsi√≥n VIP expirados
+    # Frecuencia: Cada 60 minutos (Config.CLEANUP_INTERVAL_MINUTES)
+    _scheduler.add_job(
+        expire_and_kick_vip_subscribers,
+        trigger=IntervalTrigger(minutes=Config.CLEANUP_INTERVAL_MINUTES),
+        args=[bot],
+        id="expire_vip",
+        name="Expulsar VIPs expirados",
+        replace_existing=True,
+        max_instances=1
+    )
+
+    # Tarea 2: Procesamiento cola Free
+    # Frecuencia: Cada 5 minutos (Config.PROCESS_FREE_QUEUE_MINUTES)
+    _scheduler.add_job(
+        process_free_queue,
+        trigger=IntervalTrigger(minutes=Config.PROCESS_FREE_QUEUE_MINUTES),
+        args=[bot],
+        id="process_free_queue",
+        name="Procesar cola Free",
+        replace_existing=True,
+        max_instances=1
+    )
+
+    # Tarea 3: Limpieza de datos antiguos
+    # Frecuencia: Diaria a las 3 AM UTC
+    _scheduler.add_job(
+        cleanup_old_data,
+        trigger=CronTrigger(hour=3, minute=0, timezone="UTC"),
+        args=[bot],
+        id="cleanup_old_data",
+        name="Limpieza de datos antiguos",
+        replace_existing=True,
+        max_instances=1
+    )
+
+    # Iniciar scheduler
+    _scheduler.start()
+    logger.info("‚úÖ Background tasks iniciados correctamente")
+
+def stop_background_tasks():
+    """
+    Detiene el scheduler y todas las tareas programadas.
+    """
+    global _scheduler
+
+    if _scheduler is None:
+        logger.warning("‚ö†Ô∏è Scheduler no est√° corriendo")
+        return
+
+    logger.info("üõë Deteniendo background tasks...")
+
+    _scheduler.shutdown(wait=True)
+    _scheduler = None
+
+    logger.info("‚úÖ Background tasks detenidos correctamente")
+```
+
+**Flujos Implementados:**
+
+**VIP Expiration Flow:**
+```
+1. [Cada 60 minutos] Tarea expire_and_kick_vip_subscribers() se ejecuta
+   ‚îú‚Üí Verifica si canal VIP est√° configurado
+   ‚îú‚Üí Busca suscriptores VIP con expiry_date < datetime.now()
+   ‚îú‚Üí Marca como expirados (status = "expired")
+   ‚îú‚Üí Expulsa del canal VIP usando Telegram API
+   ‚îî‚Üí Log de resultados
+```
+
+**Free Queue Processing Flow:**
+```
+1. [Cada 5 minutos] Tarea process_free_queue() se ejecuta
+   ‚îú‚Üí Verifica si canal Free est√° configurado
+   ‚îú‚Üí Busca solicitudes Free con (request_date + wait_time) < datetime.now()
+   ‚îú‚Üí Para cada solicitud:
+   ‚îÇ  ‚îú‚Üí Marca como procesada
+   ‚îÇ  ‚îú‚Üí Crea invite link √∫nico (member_limit=1, expire_hours=24)
+   ‚îÇ  ‚îú‚Üí Env√≠a link al usuario por mensaje privado
+   ‚îÇ  ‚îî‚Üí Log de √©xito/error
+   ‚îî‚Üí Log de resultados
+```
+
+**Data Cleanup Flow:**
+```
+1. [Diariamente a las 3 AM UTC] Tarea cleanup_old_data() se ejecuta
+   ‚îú‚Üí Busca solicitudes Free con request_date > 30 d√≠as
+   ‚îú‚Üí Elimina registros antiguos
+   ‚îî‚Üí Log de cantidad eliminada
+```
+
+**Configuraci√≥n de Variables de Entorno:**
+- `CLEANUP_INTERVAL_MINUTES` - Intervalo para expulsi√≥n de VIPs expirados (default: 60)
+- `PROCESS_FREE_QUEUE_MINUTES` - Intervalo para procesamiento de cola Free (default: 5)
+
+**Ejemplo de uso en main.py:**
+```python
+from bot.background import start_background_tasks, stop_background_tasks
+
+async def on_startup(bot: Bot, dispatcher: Dispatcher) -> None:
+    # ... otras inicializaciones ...
+
+    # Iniciar background tasks
+    start_background_tasks(bot)
+
+async def on_shutdown(bot: Bot, dispatcher: Dispatcher) -> None:
+    # Detener background tasks
+    stop_background_tasks()
+
+    # ... otras tareas de cierre ...
+```
+
+**Manejo de Errores:**
+- Cada tarea est√° envuelta en try-catch para evitar interrupciones
+- Logging detallado de errores con traceback
+- Continuidad de otras tareas si una falla
+- Validaci√≥n de configuraci√≥n antes de ejecutar tareas
+
+**Monitoreo:**
+- Funci√≥n `get_scheduler_status()` para obtener estado del scheduler
+- Logging detallado de ejecuci√≥n de tareas
+- Conteo de elementos procesados por cada tarea
+- Informaci√≥n de pr√≥xima ejecuci√≥n de tareas
 ```
 
 ### 9. Utilities
@@ -899,36 +2338,37 @@ main.py
 4. **Logging Level** - INFO en producci√≥n, DEBUG solo en desarrollo
 5. **Task Scheduling** - APScheduler con intervalos razonables (no < 5 min)
 
-### √çndices de B√∫squeda
-
-Se implementaron √≠ndices compuestos para queries comunes:
-- Buscar tokens v√°lidos: `(used, created_at)`
-- Buscar suscriptores por estado: `(status, expiry_date)`
-- Buscar requests pendientes: `(processed, request_date)`
-
 ## Seguridad
 
 ### 1. Autenticaci√≥n
 
 - Validaci√≥n de ADMIN_USER_IDS en config.py
 - AdminAuthMiddleware valida permisos antes de handlers
+- Control de acceso basado en roles (admin/no admin)
+- Mensajes de error personalizados para accesos denegados
+- Logging de intentos de acceso no autorizados
 
 ### 2. Base de Datos
 
 - Foreign keys habilitadas
 - SQLite con WAL mode para integridad
 - √çndices en columnas sensibles (user_id, status)
+- Context managers para manejo autom√°tico de transacciones
+- Commit autom√°tico en operaciones exitosas
+- Rollback autom√°tico en caso de errores
 
 ### 3. Tokens
 
 - 16 caracteres alfanum√©ricos (192 bits de entrop√≠a)
 - Duraci√≥n limitada (expiran despu√©s de X horas)
 - Marca de "usado" previene reutilizaci√≥n
+- Validaci√≥n doble: no expirado + no usado
 
 ### 4. Secretos
 
 - BOT_TOKEN en .env (NO commitear)
 - Logging con preview de token (primeros 10 caracteres)
+- Protecci√≥n contra filtrado accidental de credenciales
 
 ## Escalabilidad Futura
 
@@ -940,6 +2380,107 @@ Se implementaron √≠ndices compuestos para queries comunes:
 4. **PostgreSQL** - Reemplazar SQLite para m√∫ltiples conexiones
 5. **Container + Kubernetes** - Deploy en producci√≥n
 
+## Ejemplos de Implementaci√≥n
+
+### Ejemplos de uso de Middlewares
+
+#### Aplicaci√≥n de AdminAuthMiddleware
+
+```python
+# En handlers/admin/main.py
+from aiogram import Router
+from aiogram.types import Message
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from bot.middlewares.admin_auth import AdminAuthMiddleware
+
+admin_router = Router()
+admin_router.message.middleware(AdminAuthMiddleware())
+
+@admin_router.message(Command("admin_panel"))
+async def admin_panel_handler(message: Message, session: AsyncSession):
+    """Handler protegido por middleware de autenticaci√≥n."""
+    await message.answer("_PANEL DE ADMINISTRADOR_\n\n"
+                        "Selecciona una opci√≥n:",
+                        parse_mode="HTML")
+```
+
+#### Aplicaci√≥n de DatabaseMiddleware
+
+```python
+# En main.py
+from bot.middlewares.database import DatabaseMiddleware
+
+# Aplicar a nivel global para que todos los handlers tengan acceso a la BD
+dp.update.middleware(DatabaseMiddleware())
+
+# En cualquier handler
+async def user_info_handler(message: Message, session: AsyncSession):
+    """Handler que recibe la sesi√≥n autom√°ticamente."""
+    # La sesi√≥n est√° disponible gracias al middleware
+    user_id = message.from_user.id
+
+    # Ejemplo de consulta a la base de datos
+    result = await session.execute(
+        select(VIPSubscriber)
+        .where(VIPSubscriber.user_id == user_id)
+        .where(VIPSubscriber.status == "active")
+    )
+    subscriber = result.scalar_one_or_none()
+
+    if subscriber:
+        days_left = subscriber.days_remaining()
+        await message.answer(f"Suscripci√≥n VIP activa. D√≠as restantes: {days_left}")
+    else:
+        await message.answer("No tienes suscripci√≥n VIP activa.")
+```
+
+#### Uso combinado de ambos middlewares
+
+```python
+# Router espec√≠fico para comandos de administrador
+admin_router = Router()
+
+# Aplicar middleware de autenticaci√≥n a nivel de router
+admin_router.message.middleware(AdminAuthMiddleware())
+admin_router.callback_query.middleware(AdminAuthMiddleware())
+
+# La inyecci√≥n de sesi√≥n se hace a nivel global con DatabaseMiddleware
+# aplicado en el dispatcher
+
+@admin_router.message(Command("generate_token"))
+async def generate_token_handler(message: Message, session: AsyncSession):
+    """
+    Handler que requiere:
+    1. Permisos de administrador (verificado por AdminAuthMiddleware)
+    2. Acceso a la base de datos (inyectado por DatabaseMiddleware)
+    """
+    # Solo se llega aqu√≠ si el usuario es admin
+    # La sesi√≥n est√° disponible autom√°ticamente
+
+    container = ServiceContainer(session, bot_instance)
+
+    try:
+        # Generar token usando el servicio de suscripciones
+        token = await container.subscription.generate_vip_token(
+            generated_by=message.from_user.id,
+            duration_hours=24
+        )
+
+        await message.answer(
+            f"‚úÖ Token VIP generado:\n\n"
+            f"<code>{token.token}</code>\n\n"
+            f"V√°lido por 24 horas.\n"
+            f"Generado por: {message.from_user.full_name}",
+            parse_mode="HTML"
+        )
+    except Exception as e:
+        logger.error(f"Error generando token: {e}")
+        await message.answer("‚ùå Error al generar token. Intenta nuevamente.")
+
+# Aplicar middleware global de base de datos en el dispatcher
+dp.update.middleware(DatabaseMiddleware())
+
 ---
 
 **√öltima actualizaci√≥n:** 2025-12-11
diff --git a/docs/COMMANDS.md b/docs/COMMANDS.md
index 2f2675a..a79f2e7 100644
--- a/docs/COMMANDS.md
+++ b/docs/COMMANDS.md
@@ -1,640 +1,411 @@
-# Documentaci√≥n de Comandos
+# Comandos del Bot VIP/Free
 
-Referencia completa de comandos disponibles en el bot, funcionalidades y ejemplos de uso.
+Documentaci√≥n completa de los comandos disponibles en el bot de administraci√≥n de canales VIP y Free.
 
-## Estado Actual de Comandos
+## Comandos de Administraci√≥n
 
-En ONDA 1 Fase 1.1 (MVP B√°sico), la mayor√≠a de comandos est√°n **pendientes de implementar** en fases posteriores.
+### `/admin` - Panel de Administraci√≥n Principal
 
-| Fase | Estado | Comandos |
-|------|--------|----------|
-| 1.1 (Actual) | Completada | - |
-| 1.2 (Pr√≥xima) | Pendiente | Admin: /admin, /generar_token, /config |
-| 1.3 (Pr√≥xima) | Pendiente | User: /start, /vip, /free |
-| 1.4+ | Pendiente | Avanzados |
+**Descripci√≥n:** Abre el panel de administraci√≥n principal con acceso a todas las funciones de gesti√≥n.
 
-## Comandos Planeados (ONDA 1+)
+**Permisos:** Solo administradores (definidos en `ADMIN_USER_IDS`)
 
-### Comandos de Usuario
+**Flujo de uso:**
+1. El administrador env√≠a `/admin`
+2. El bot verifica permisos y muestra el men√∫ principal
+3. Opciones disponibles:
+   - Gesti√≥n Canal VIP
+   - Gesti√≥n Canal Free
+   - Configuraci√≥n
 
-#### /start
-Comando de bienvenida y men√∫ principal del bot.
+**Ejemplo:**
+```
+/admin
+ü§ñ Panel de Administraci√≥n
+‚úÖ Bot configurado correctamente
 
+Selecciona una opci√≥n:
+- üì∫ Gesti√≥n Canal VIP
+- üì∫ Gesti√≥n Canal Free
+- ‚öôÔ∏è Configuraci√≥n
 ```
-Descripci√≥n:
-  Env√≠a mensaje de bienvenida y muestra opciones disponibles para usuarios
 
-Sintaxis:
-  /start
+## Submen√∫ VIP
 
-Permisos:
-  Ninguno (cualquier usuario)
+### `Gesti√≥n Canal VIP` - Opci√≥n del men√∫ admin
 
-Respuesta:
-  [Men√∫ inline con botones:]
-  - Acceso VIP (Canjear Token)
-  - Acceso Free (Cola de Espera)
-  - Ayuda
+**Descripci√≥n:** Accede al submen√∫ de gesti√≥n del canal VIP.
 
-Ejemplo:
-  Usuario: /start
-  Bot: ¬°Hola! Bienvenido al bot...
-```
+**Permisos:** Solo administradores
 
-Implementaci√≥n planeada en Fase 1.3:
-```python
-@router.message.command("start")
-async def start_handler(message: Message) -> None:
-    """Manejador del comando /start"""
-    # Enviar mensaje de bienvenida
-    # Mostrar teclado inline con opciones
-    # No requiere DB para MVP
-```
+**Funcionalidades:**
+- Verificar estado de configuraci√≥n del canal VIP
+- Generar tokens de invitaci√≥n VIP
+- Configurar o reconfigurar el canal VIP
 
-#### /vip
-Acceso al canal VIP mediante token de invitaci√≥n.
+**Flujo de uso:**
+1. Seleccionar "Gesti√≥n Canal VIP" en el men√∫ principal
+2. El bot muestra estado actual del canal VIP
+3. Opciones disponibles dependiendo del estado:
+   - Si est√° configurado: "üéüÔ∏è Generar Token de Invitaci√≥n", "üîß Reconfigurar Canal"
+   - Si no est√° configurado: "‚öôÔ∏è Configurar Canal VIP"
 
-```
-Descripci√≥n:
-  Inicia flujo de canje de token VIP
-  Usuario ingresa token y obtiene acceso
-
-Sintaxis:
-  /vip
-
-Permisos:
-  Ninguno (cualquier usuario)
-
-Estados FSM:
-  waiting_for_vip_token ‚Üí Esperando que usuario ingrese token
-
-Flujo:
-  1. Usuario env√≠a /vip
-  2. Bot responde: "Ingresa tu token VIP:"
-  3. Usuario env√≠a token (ej: ABC123XYZ456789)
-  4. Bot valida:
-     - Token existe
-     - No fue usado antes
-     - No expir√≥
-  5. Si v√°lido:
-     - Crear VIPSubscriber en BD
-     - Marcar token como usado
-     - Invitar a canal VIP
-     - "Bienvenido! Acceso VIP v√°lido por 24h"
-  6. Si inv√°lido:
-     - "Token inv√°lido o expirado"
-
-Ejemplo:
-  Usuario: /vip
-  Bot: Ingresa tu token VIP:
-  Usuario: ABC123XYZ456789
-  Bot: ‚úÖ Bienvenido al canal VIP!
-       Tu acceso es v√°lido hasta 2025-12-12 11:30
-       D√≠as restantes: 1
-```
+### `Configurar Canal VIP` - Configuraci√≥n del canal VIP
 
-Implementaci√≥n planeada en Fase 1.3:
-```python
-@router.message.command("vip")
-async def vip_handler(message: Message, state: FSMContext) -> None:
-    """Inicia flujo de canje de token VIP"""
-    await message.answer("Ingresa tu token VIP:")
-    await state.set_state(UserStates.waiting_for_vip_token)
-
-@router.message(UserStates.waiting_for_vip_token)
-async def vip_token_handler(message: Message, state: FSMContext, session: AsyncSession) -> None:
-    """Procesa token VIP ingresado"""
-    token_str = message.text.strip()
-    # Validar token
-    # Crear suscriptor
-    # Invitar a canal
-    await state.clear()
-```
+**Descripci√≥n:** Configura el canal VIP por reenv√≠o de mensajes.
 
-#### /free
-Solicitar acceso al canal Free con tiempo de espera.
+**Permisos:** Solo administradores
 
+**Flujo de uso:**
+1. Seleccionar "‚öôÔ∏è Configurar Canal VIP"
+2. El bot solicita reenviar un mensaje del canal VIP
+3. El administrador va al canal VIP y reenv√≠a cualquier mensaje al bot
+4. El bot extrae autom√°ticamente el ID del canal
+5. El bot verifica permisos y configura el canal
+6. El bot actualiza el men√∫ con el canal configurado
+
+**Requisitos:**
+- El bot debe ser administrador del canal VIP
+- El bot debe tener permiso para invitar usuarios
+
+**Ejemplo de interacci√≥n:**
 ```
-Descripci√≥n:
-  Solicita acceso al canal Free
-  El bot invita despu√©s de esperar DEFAULT_WAIT_TIME_MINUTES
-
-Sintaxis:
-  /free
-
-Permisos:
-  Ninguno (cualquier usuario)
-
-Flujo:
-  1. Usuario env√≠a /free
-  2. Bot:
-     - Verifica si ya tiene solicitud pendiente
-     - Si NO: Crea FreeChannelRequest
-     - Si S√ç: "Ya tienes una solicitud pendiente"
-  3. Bot responde: "Tu solicitud fue registrada"
-                   "Espera 5 minutos..."
-  4. [Background Task ejecuta cada 5 min]
-     - Busca FreeChannelRequest listas (cumplieron espera)
-     - Invita usuarios a canal Free
-     - Marca como processed
-  5. Usuario recibe invitaci√≥n al canal
-
-Ejemplo:
-  Usuario: /free
-  Bot: ‚úÖ Solicitud registrada
-       Ser√°s invitado en 5 minutos
-       [Despu√©s de 5 min...]
-       ¬°Bienvenido al canal Free!
-       Tu acceso es permanente mientras el bot est√© activo
-```
+üëâ Reenv√≠a un mensaje del canal ahora...
 
-Implementaci√≥n planeada en Fase 1.3:
-```python
-@router.message.command("free")
-async def free_handler(message: Message, session: AsyncSession) -> None:
-    """Solicita acceso al canal Free"""
-    # Verificar solicitud pendiente
-    # Crear FreeChannelRequest
-    # Background task procesa cada 5 min
+(Administrador reenv√≠a un mensaje del canal VIP)
+‚úÖ Canal VIP Configurado
+Canal: Mi Canal VIP
+ID: -1001234567890
+Ya puedes generar tokens de invitaci√≥n.
 ```
 
-### Comandos de Administrador
+### `Generar Token de Invitaci√≥n` - Creaci√≥n de tokens VIP
 
-#### /admin
-Men√∫ principal de administraci√≥n (requiere permisos admin).
+**Descripci√≥n:** Genera un token de invitaci√≥n para acceso VIP.
 
-```
-Descripci√≥n:
-  Acceso al panel de administraci√≥n
-  Solo disponible para admins configurados en ADMIN_USER_IDS
-
-Sintaxis:
-  /admin
-
-Permisos:
-  Admin (verificado por AdminAuthMiddleware)
-
-Respuesta:
-  [Men√∫ inline con botones:]
-  - Gestionar VIP
-    - Generar Token
-    - Ver Tokens
-    - Ver Suscriptores
-    - Renovar Suscripci√≥n
-  - Gestionar Free
-    - Ver Cola de Espera
-    - Procesar Manual
-  - Configuraci√≥n
-    - Canales
-    - Tiempo Espera
-    - Reacciones
-
-Ejemplo:
-  Admin: /admin
-  Bot: Panel de Administraci√≥n
-       [Botones para gesti√≥n]
-```
+**Permisos:** Solo administradores
 
-Implementaci√≥n planeada en Fase 1.2:
-```python
-@router.message.command("admin")
-async def admin_handler(message: Message) -> None:
-    """Panel principal de admin"""
-    # Verificar permisos (AdminAuthMiddleware)
-    # Enviar teclado con opciones de admin
-```
+**Flujo de uso:**
+1. Asegurarse de que el canal VIP est√© configurado
+2. Seleccionar "üéüÔ∏è Generar Token de Invitaci√≥n"
+3. El bot genera un token √∫nico con duraci√≥n configurable
+4. El bot env√≠a el token al administrador
+5. El administrador comparte el token con el usuario
 
-#### /generar_token
-Generar nuevo token VIP (admin).
+**Caracter√≠sticas del token:**
+- 16 caracteres alfanum√©ricos
+- V√°lido por 24 horas (por defecto)
+- Un solo uso
+- Se marca como usado despu√©s del primer canje
 
+**Ejemplo de token generado:**
 ```
-Descripci√≥n:
-  Genera token √∫nico para invitar usuarios a VIP
-  Incluye selecci√≥n de duraci√≥n
-
-Sintaxis:
-  /generar_token
-
-Permisos:
-  Admin
-
-Estados FSM:
-  admin_generating_token ‚Üí Seleccionando duraci√≥n
-
-Flujo:
-  1. Admin: /generar_token
-  2. Bot: "Selecciona duraci√≥n del token:"
-          [Botones:]
-          - 24 horas
-          - 7 d√≠as
-          - 30 d√≠as
-          - Duraci√≥n personalizada
-  3. Admin selecciona opci√≥n
-  4. Si "Personalizada": Bot pide horas
-  5. Bot:
-     - Genera token √∫nico de 16 caracteres
-     - Guarda en BD: InvitationToken
-     - Responde: "Token generado:
-                  ABC123XYZ456789
-                  V√°lido por: 24 horas
-                  Generado por: @admin_username
-                  Crea un enlace de invitaci√≥n"
-
-Ejemplo:
-  Admin: /generar_token
-  Bot: Selecciona duraci√≥n:
-       [24h] [7d] [30d] [Custom]
-  Admin: Presiona [24h]
-  Bot: ‚úÖ Token generado: ABC123XYZ456789
-       V√°lido por 24 horas
-       Comparte este token para invitar usuarios VIP
-```
+üéüÔ∏è Token VIP Generado
+
+Token: ABCD1234EFGH5678
+‚è±Ô∏è V√°lido por: 24 horas
+üìÖ Expira: 2025-12-12 10:30 UTC
 
-Implementaci√≥n planeada en Fase 1.2:
-```python
-@router.message.command("generar_token")
-async def generar_token_handler(message: Message, state: FSMContext) -> None:
-    """Inicia flujo de generaci√≥n de token"""
-    # Mostrar opciones de duraci√≥n
-    # Usar callbackquery para selecci√≥n
-    # Generar token con secrets
-    # Guardar en BD
+üëâ Comparte este token con el usuario.
+El usuario debe enviarlo al bot para canjear acceso VIP.
 ```
 
-#### /ver_tokens
-Ver lista de tokens generados (admin).
+## Submen√∫ Free
 
-```
-Descripci√≥n:
-  Lista todos los tokens con su estado
-  Puedes filtrar por: v√°lidos, usados, expirados
-
-Sintaxis:
-  /ver_tokens [filtro]
-
-Filtros:
-  todos    - Todos los tokens (default)
-  validos  - Tokens sin usar y no expirados
-  usados   - Tokens ya canjeados
-  expirados - Tokens expirados
-
-Respuesta:
-  Tabla con:
-  - Token (primeros 8 caracteres)
-  - Estado (v√°lido/usado/expirado)
-  - Generado por
-  - Creado hace X tiempo
-  - Canjeado por (si aplica)
-
-Ejemplo:
-  Admin: /ver_tokens validos
-  Bot: üìã Tokens v√°lidos (3):
-
-       1. ABC123XY... [V√ÅLIDO]
-          Creado hace 2 horas
-          Expira en 22 horas
-
-       2. DEF456UV... [V√ÅLIDO]
-          Creado hace 5 horas
-          Expira en 19 horas
-
-       3. GHI789ST... [V√ÅLIDO]
-          Creado hace 1 d√≠a
-          Expira en 10 horas
-```
+### `Gesti√≥n Canal Free` - Opci√≥n del men√∫ admin
 
-Implementaci√≥n planeada en Fase 1.2:
-```python
-@router.message.command("ver_tokens")
-async def ver_tokens_handler(message: Message, command: CommandObject, session: AsyncSession) -> None:
-    """Muestra lista de tokens"""
-    filtro = command.args or "todos"
-    # Consultar tokens seg√∫n filtro
-    # Formatear tabla
-    # Enviar respuesta
-```
+**Descripci√≥n:** Accede al submen√∫ de gesti√≥n del canal Free.
 
-#### /suscriptores
-Ver suscriptores VIP (admin).
+**Permisos:** Solo administradores
 
-```
-Descripci√≥n:
-  Lista usuarios con suscripci√≥n VIP activa
-  Incluye informaci√≥n de expiraci√≥n
-
-Sintaxis:
-  /suscriptores [filtro]
-
-Filtros:
-  activos   - Suscripci√≥n a√∫n v√°lida (default)
-  proximos  - Expiran en pr√≥ximos 7 d√≠as
-  expirados - Suscripci√≥n ya expirada
-  todos     - Todos los suscriptores
-
-Respuesta:
-  Tabla con:
-  - User ID
-  - D√≠as restantes
-  - Fecha expiraci√≥n
-  - Token usado
-  - Acciones (renovar, eliminar)
-
-Ejemplo:
-  Admin: /suscriptores proximos
-  Bot: üìä Suscriptores pr√≥ximos a expirar (2):
-
-       1. User 987654321
-          Expira en 2 d√≠as (2025-12-13 11:30)
-          Token: ABC123XY...
-          [Renovar] [Eliminar]
-
-       2. User 555555555
-          Expira en 5 d√≠as (2025-12-16 11:30)
-          Token: DEF456UV...
-          [Renovar] [Eliminar]
-```
+**Funcionalidades:**
+- Verificar estado de configuraci√≥n del canal Free
+- Configurar o reconfigurar el canal Free
+- Configurar tiempo de espera para acceso Free
 
-Implementaci√≥n planeada en Fase 1.2:
-```python
-@router.message.command("suscriptores")
-async def suscriptores_handler(message: Message, command: CommandObject, session: AsyncSession) -> None:
-    """Muestra suscriptores VIP"""
-    filtro = command.args or "activos"
-    # Consultar suscriptores
-    # Formatear tabla
-    # Enviar con botones de acci√≥n
-```
+**Flujo de uso:**
+1. Seleccionar "Gesti√≥n Canal Free" en el men√∫ principal
+2. El bot muestra estado actual del canal Free y tiempo de espera
+3. Opciones disponibles dependiendo del estado:
+   - Si est√° configurado: "‚è±Ô∏è Configurar Tiempo de Espera", "üîß Reconfigurar Canal"
+   - Si no est√° configurado: "‚öôÔ∏è Configurar Canal Free"
+
+### `Configurar Canal Free` - Configuraci√≥n del canal Free
+
+**Descripci√≥n:** Configura el canal Free por reenv√≠o de mensajes.
 
-#### /config
-Configuraci√≥n del bot (admin).
+**Permisos:** Solo administradores
 
+**Flujo de uso:**
+1. Seleccionar "‚öôÔ∏è Configurar Canal Free"
+2. El bot solicita reenviar un mensaje del canal Free
+3. El administrador va al canal Free y reenv√≠a cualquier mensaje al bot
+4. El bot extrae autom√°ticamente el ID del canal
+5. El bot verifica permisos y configura el canal
+6. El bot actualiza el men√∫ con el canal configurado
+
+**Requisitos:**
+- El bot debe ser administrador del canal Free
+- El bot debe tener permiso para invitar usuarios
+
+**Ejemplo de interacci√≥n:**
 ```
-Descripci√≥n:
-  Accede a panel de configuraci√≥n
-  Permite cambiar canales, tiempos, reacciones
-
-Sintaxis:
-  /config
-
-Permisos:
-  Admin
-
-Men√∫:
-  - Canales
-    - Ver Canal VIP
-    - Configurar Canal VIP
-    - Ver Canal Free
-    - Configurar Canal Free
-  - Tiempos
-    - Ver Tiempo de Espera Free
-    - Cambiar Tiempo de Espera
-  - Reacciones
-    - Ver Reacciones VIP
-    - Configurar Reacciones VIP
-    - Ver Reacciones Free
-    - Configurar Reacciones Free
-  - Tarifas
-    - Ver Tarifas
-    - Cambiar Tarifas
-
-Ejemplo:
-  Admin: /config
-  Bot: ‚öôÔ∏è Configuraci√≥n del Bot
-
-       [Canales]
-       [Tiempos]
-       [Reacciones]
-       [Tarifas]
+üëâ Reenv√≠a un mensaje del canal ahora...
+
+(Administrador reenv√≠a un mensaje del canal Free)
+‚úÖ Canal Free Configurado
+Canal: Mi Canal Free
+ID: -1000987654321
+Los usuarios ya pueden solicitar acceso.
 ```
 
-Implementaci√≥n planeada en Fase 1.4:
-```python
-@router.message.command("config")
-async def config_handler(message: Message, state: FSMContext) -> None:
-    """Panel de configuraci√≥n"""
-    # Mostrar men√∫ de opciones
-    # Usar callbackquery para navegar
-    # Actualizar BotConfig en BD
+### `Configurar Tiempo de Espera` - Configuraci√≥n del tiempo de espera
+
+**Descripci√≥n:** Configura el tiempo de espera para acceso al canal Free.
+
+**Permisos:** Solo administradores
+
+**Flujo de uso:**
+1. Asegurarse de que el canal Free est√© configurado
+2. Seleccionar "‚è±Ô∏è Configurar Tiempo de Espera"
+3. El bot solicita ingresar el nuevo tiempo en minutos
+4. El administrador env√≠a el n√∫mero de minutos
+5. El bot valida y actualiza la configuraci√≥n
+6. El bot actualiza el men√∫ con el nuevo tiempo
+
+**Requisitos:**
+- El tiempo debe ser al menos 1 minuto
+- Solo se aceptan valores num√©ricos
+
+**Ejemplo de interacci√≥n:**
 ```
+‚è±Ô∏è Configurar Tiempo de Espera
+
+Tiempo actual: 10 minutos
 
-#### /stats
-Estad√≠sticas del bot (admin).
+Env√≠a el nuevo tiempo de espera en minutos.
+Ejemplo: 5
 
+El tiempo debe ser mayor o igual a 1 minuto.
+
+(Administrador env√≠a: 15)
+‚úÖ Tiempo de Espera Actualizado
+Nuevo tiempo: 15 minutos
+Las nuevas solicitudes esperar√°n 15 minutos antes de procesarse.
 ```
-Descripci√≥n:
-  Muestra estad√≠sticas generales
-  Usuarios VIP, Free, tokens, etc.
 
-Sintaxis:
-  /stats
+## Comandos de Usuario
 
-Permisos:
-  Admin
+### `/start` - Bienvenida y men√∫ principal de usuario
 
-Respuesta:
-  üìä Estad√≠sticas del Bot:
+**Descripci√≥n:** Punto de entrada para usuarios que detecta el rol (admin/VIP/usuario) y proporciona las opciones correspondientes.
 
-  üë• Usuarios VIP: 42 (3 pr√≥ximos a expirar)
-  üìã Tokens generados: 50
-     - V√°lidos: 8
-     - Usados: 40
-     - Expirados: 2
+**Permisos:** Todos los usuarios
 
-  üì∫ Canal Free:
-     - Solicitudes en cola: 15
-     - Procesadas hoy: 23
+**Flujo de uso:**
+1. El usuario env√≠a `/start`
+2. El bot detecta el rol del usuario (admin, VIP o normal)
+3. Si es admin: redirige al panel de administraci√≥n
+4. Si es VIP: muestra mensaje de bienvenida con d√≠as restantes de suscripci√≥n
+5. Si es usuario normal: muestra men√∫ con opciones VIP/Free
 
-  üíæ Base de datos: 125 KB
-  ‚è±Ô∏è Tiempo de espera Free: 5 minutos
-  üîß Versi√≥n: ONDA 1 (MVP)
-```
+**Opciones disponibles para usuarios normales:**
+- Canjear Token VIP: Iniciar flujo de canje de tokens VIP
+- Solicitar Acceso Free: Iniciar flujo de solicitud de acceso Free
 
-Implementaci√≥n planeada en Fase 1.5:
-```python
-@router.message.command("stats")
-async def stats_handler(message: Message, session: AsyncSession) -> None:
-    """Muestra estad√≠sticas"""
-    # Contar usuarios VIP
-    # Contar tokens
-    # Contar requests Free
-    # Formatear respuesta
+**Ejemplo:**
 ```
+/start
+üëã Hola Usuario!
 
-### Comandos Especiales
+Bienvenido al bot de acceso a canales.
 
-#### /help
-Ayuda general del bot.
+Opciones disponibles:
 
+üéüÔ∏è Canjear Token VIP
+Si tienes un token de invitaci√≥n, canj√©alo para acceso VIP.
+
+üì∫ Solicitar Acceso Free
+Solicita acceso al canal gratuito (con tiempo de espera).
+
+üëâ Selecciona una opci√≥n:
 ```
-Descripci√≥n:
-  Muestra informaci√≥n de ayuda
-  Diferentes para usuarios y admins
 
-Sintaxis:
-  /help
+### `/vip` - Canje de token VIP (Futuro)
 
-Respuesta (Usuario normal):
-  ‚ÑπÔ∏è Ayuda del Bot VIP/Free
+**Descripci√≥n:** Solicitar acceso VIP ingresando un token. (Funcionalidad movida al flujo de `/start`)
 
-  /start - Men√∫ principal
-  /vip - Acceso al canal VIP (necesitas token)
-  /free - Solicitar acceso Free
-  /help - Esta ayuda
+**Permisos:** Usuarios normales
 
-  Problemas? Contacta con @admin_username
+**Flujo de uso:**
+1. El usuario env√≠a `/vip`
+2. El bot solicita ingresar el token VIP
+3. El bot valida y procesa el token
+4. El bot env√≠a link de invitaci√≥n al canal VIP
 
-Respuesta (Admin):
-  ‚ÑπÔ∏è Ayuda de Administraci√≥n
+### `/free` - Solicitud de acceso Free (Futuro)
 
-  /admin - Panel de administraci√≥n
-  /generar_token - Crear nuevo token VIP
-  /ver_tokens - Ver tokens
-  /suscriptores - Ver suscriptores
-  /config - Configuraci√≥n del bot
-  /stats - Estad√≠sticas
-  /help - Esta ayuda
+**Descripci√≥n:** Solicitar acceso al canal Free. (Funcionalidad movida al flujo de `/start`)
 
-  Para usuarios:
-  /start - Men√∫ principal
-```
+**Permisos:** Usuarios normales
 
-Implementaci√≥n planeada en Fase 1.3:
-```python
-@router.message.command("help")
-async def help_handler(message: Message) -> None:
-    """Muestra ayuda seg√∫n el tipo de usuario"""
-    if Config.is_admin(message.from_user.id):
-        # Mostrar ayuda admin
-    else:
-        # Mostrar ayuda usuario
+**Flujo de uso:**
+1. El usuario env√≠a `/free`
+2. El bot registra la solicitud en la cola
+3. El bot notifica el tiempo de espera
+4. El bot env√≠a link de invitaci√≥n cuando se cumple el tiempo
 ```
 
-## Manejo de Errores en Comandos
+## Flujos de Usuario
 
-### Errores Comunes
+### Flujo VIP - Canje de Tokens
 
-**Usuario no autorizado:**
-```
-Admin: /admin
-Bot: ‚ùå No tienes permisos para usar este comando
-     Por favor contacta con el administrador
-```
+**Descripci√≥n:** Proceso para que usuarios canjeen tokens VIP y reciban acceso al canal VIP.
 
-**Configuraci√≥n incompleta:**
-```
-Admin: /config
-Bot: ‚ö†Ô∏è Error: Canal VIP no configurado
-     Configura los canales primero: /config
-```
+**Flujo de uso:**
+1. Usuario selecciona "Canjear Token VIP" en el men√∫ de `/start`
+2. Bot verifica que canal VIP est√© configurado
+3. Bot entra en estado FSM `waiting_for_token`
+4. Usuario env√≠a token de invitaci√≥n
+5. Bot valida token (formato, vigencia, no usado)
+6. Bot genera invite link √∫nico para el usuario
+7. Bot env√≠a link de acceso al canal VIP
 
-**Token inv√°lido:**
-```
-Usuario: /vip
-Bot: Ingresa tu token VIP:
-Usuario: INVALID123
-Bot: ‚ùå Token inv√°lido
-     Verifica que est√© bien escrito
-     Token debe tener 16 caracteres
-```
+**Caracter√≠sticas del invite link:**
+- V√°lido por 1 hora
+- Solo puede usarse 1 vez
+- No se comparte con otros usuarios
 
-**Solicitud duplicada:**
-```
-Usuario: /free
-Bot: ‚ö†Ô∏è Ya tienes una solicitud pendiente
-     Ser√°s invitado en X minutos
-     Espera a que se complete
+**Ejemplo de interacci√≥n:**
 ```
+üëâ Copia y pega tu token aqu√≠...
+(Usuario env√≠a: ABCD1234EFGH5678)
+‚úÖ Token Canjeado Exitosamente!
 
-## Validaciones de Comandos
+üéâ Tu acceso VIP est√° activo
+‚è±Ô∏è Duraci√≥n: 30 d√≠as
 
-### Token VIP
-- Longitud: exactamente 16 caracteres
-- Caracteres v√°lidos: a-z, A-Z, 0-9
-- Formato: case-sensitive
-- No debe estar usado previamente
-- No debe haber expirado
+üëá Usa este link para unirte al canal VIP:
+https://t.me/+abc123def456
 
-### User ID
-- Debe ser n√∫mero v√°lido
-- Rango: enteros positivos de 32-64 bits
-- Identificador √∫nico por usuario
+‚ö†Ô∏è Importante:
+‚Ä¢ El link expira en 1 hora
+‚Ä¢ Solo puedes usarlo 1 vez
+‚Ä¢ No lo compartas con otros
 
-### Canal ID
-- Formato: -100XXXXXXXXXXX (negativo de 13-15 d√≠gitos)
-- Alternativa: @nombre_canal
+Disfruta del contenido exclusivo! üöÄ
+```
 
-### Tiempo de Espera
-- M√≠nimo: 1 minuto
-- M√°ximo: 10080 minutos (7 d√≠as)
-- Valor por defecto: 5 minutos
+### Flujo Free - Solicitud de Acceso
 
-## Flujos de Comandos (FSM)
+**Descripci√≥n:** Proceso para que usuarios soliciten acceso al canal Free con tiempo de espera.
 
-### Flujo de Usuario Normal
+**Flujo de uso:**
+1. Usuario selecciona "Solicitar Acceso Free" en el men√∫ de `/start`
+2. Bot verifica que canal Free est√© configurado
+3. Bot verifica si usuario ya tiene solicitud pendiente
+4. Si no tiene solicitud: crea nueva solicitud y notifica tiempo de espera
+5. Si ya tiene solicitud: muestra tiempo restante
+6. Proceso autom√°tico procesa solicitudes cuando cumplen tiempo de espera
+7. Bot env√≠a notificaci√≥n con invite link al usuario
 
+**Caracter√≠sticas del tiempo de espera:**
+- Configurable por administrador (m√≠nimo 1 minuto)
+- Procesamiento autom√°tico en background
+- Notificaci√≥n al usuario cuando est√© listo
+
+**Ejemplo de interacci√≥n:**
 ```
-[Inicio]
-   ‚îÇ
-   ‚ñº
-/start ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚Üí /vip ‚îÄ‚îÄ‚Üí [waiting_for_vip_token] ‚îÄ‚îÄ‚Üí [VIP]
-   ‚îÇ        ‚îÇ
-   ‚îÇ        ‚îî‚îÄ‚îÄ‚Üí /free ‚îÄ‚îÄ‚Üí [waiting_confirmation] ‚îÄ‚îÄ‚Üí [Free Queue]
-   ‚îÇ
-   ‚îî‚îÄ‚îÄ‚Üí /help ‚îÄ‚îÄ‚Üí [Informaci√≥n]
-```
+‚úÖ Solicitud Recibida
 
-### Flujo de Administrador
+Tu solicitud de acceso al canal Free ha sido registrada.
 
+‚è±Ô∏è Tiempo de espera: 10 minutos
+
+üì® Recibir√°s un mensaje con el link de invitaci√≥n cuando el tiempo se cumpla.
+
+üí° No necesitas hacer nada m√°s, el proceso es autom√°tico.
+
+Puedes cerrar este chat, te notificar√© cuando est√© listo! üîî
 ```
-[Inicio]
-   ‚îÇ
-   ‚ñº
-/admin ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚Üí /generar_token ‚îÄ‚îÄ‚Üí [selecting_duration] ‚îÄ‚îÄ‚Üí [Token Creado]
-   ‚îÇ        ‚îÇ
-   ‚îÇ        ‚îú‚îÄ‚îÄ‚Üí /ver_tokens ‚îÄ‚îÄ‚Üí [List Tokens]
-   ‚îÇ        ‚îÇ
-   ‚îÇ        ‚îú‚îÄ‚îÄ‚Üí /suscriptores ‚îÄ‚îÄ‚Üí [List Subscribers]
-   ‚îÇ        ‚îÇ
-   ‚îÇ        ‚îî‚îÄ‚îÄ‚Üí /config ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚Üí [configure_vip_channel]
-   ‚îÇ                           ‚îÇ
-   ‚îÇ                           ‚îú‚îÄ‚Üí [configure_free_channel]
-   ‚îÇ                           ‚îÇ
-   ‚îÇ                           ‚îî‚îÄ‚Üí [configure_wait_time]
-   ‚îÇ
-   ‚îî‚îÄ‚îÄ‚Üí /stats ‚îÄ‚îÄ‚Üí [Estad√≠sticas]
-
-   ‚îî‚îÄ‚îÄ‚Üí /help ‚îÄ‚îÄ‚Üí [Admin Help]
-```
 
-## Mensajes de Estado
+## Ejemplos de Flujos Completos
+
+### Flujo de Configuraci√≥n VIP Completo
+
+1. Administrador env√≠a `/admin`
+2. Selecciona "Gesti√≥n Canal VIP"
+3. Selecciona "‚öôÔ∏è Configurar Canal VIP"
+4. Reenv√≠a mensaje del canal VIP
+5. Bot configura el canal
+6. Selecciona "üéüÔ∏è Generar Token de Invitaci√≥n"
+7. Bot genera y env√≠a token VIP
+
+### Flujo de Configuraci√≥n Free Completo
+
+1. Administrador env√≠a `/admin`
+2. Selecciona "Gesti√≥n Canal Free"
+3. Selecciona "‚öôÔ∏è Configurar Canal Free"
+4. Reenv√≠a mensaje del canal Free
+5. Bot configura el canal
+6. Selecciona "‚è±Ô∏è Configurar Tiempo de Espera"
+7. Ingresa nuevo tiempo (por ejemplo: 20)
+8. Bot actualiza tiempo de espera
+
+## Errores Comunes y Soluciones
+
+### Error de permisos en configuraci√≥n de canal
+- **Problema:** El bot no puede configurar un canal
+- **Causa:** El bot no es administrador o no tiene permisos suficientes
+- **Soluci√≥n:** Asegurarse de que el bot sea administrador con permiso para invitar usuarios
+
+### Error de formato en tiempo de espera
+- **Problema:** El bot no acepta el tiempo de espera ingresado
+- **Causa:** No es un n√∫mero o es menor a 1
+- **Soluci√≥n:** Ingresar un n√∫mero entero mayor o igual a 1
 
-El bot utiliza emojis para indicar estado:
+### Error de token inv√°lido
+- **Problema:** El token no se puede canjear
+- **Causas posibles:**
+  - El token ya fue usado
+  - El token ha expirado
+  - El token no existe
+  - El canal VIP no est√° configurado
 
-- ‚úÖ Operaci√≥n exitosa
-- ‚ùå Error o validaci√≥n fallida
-- ‚ö†Ô∏è Advertencia
-- ‚ÑπÔ∏è Informaci√≥n
-- üìã Lista o tabla
-- üìä Estad√≠sticas
-- ‚è±Ô∏è Tiempo
-- üì∫ Canal
-- üë• Usuarios
-- üíæ Base de datos
-- üîß Configuraci√≥n
+## Tareas Programadas (Background Tasks)
 
-## Futuras Mejoras
+El bot ejecuta autom√°ticamente tareas programadas que realizan operaciones peri√≥dicas para mantener el sistema funcionando correctamente:
 
-En ONDA 2+:
+### Tarea: Expulsi√≥n de VIPs expirados
+- **Frecuencia:** Cada 60 minutos (configurable con `CLEANUP_INTERVAL_MINUTES`)
+- **Funcionalidad:** Marca como expirados y expulsa del canal a los suscriptores VIP cuya fecha pas√≥
+- **Proceso:**
+  1. Busca suscriptores VIP con fecha de expiraci√≥n anterior a la actual
+  2. Marca como expirados en la base de datos
+  3. Expulsa del canal VIP usando la API de Telegram
+  4. Registra en logs el n√∫mero de usuarios expulsados
 
-- [ ] Comandos de paginaci√≥n (/prev, /next)
-- [ ] Autocomplete en argumentos
-- [ ] Comandos de b√∫squeda (/buscar_usuario)
-- [ ] Comandos de reporte (/reporte)
-- [ ] Comandos de backup (/backup)
-- [ ] Comandos de moderaci√≥n (/ban, /unban)
+### Tarea: Procesamiento de cola Free
+- **Frecuencia:** Cada 5 minutos (configurable con `PROCESS_FREE_QUEUE_MINUTES`)
+- **Funcionalidad:** Busca solicitudes que cumplieron el tiempo de espera y env√≠a invite links a los usuarios
+- **Proceso:**
+  1. Busca solicitudes Free que cumplen el tiempo de espera configurado
+  2. Para cada solicitud:
+     - Marca como procesada
+     - Crea un invite link √∫nico (v√°lido 24 horas, un solo uso)
+     - Env√≠a el link al usuario por mensaje privado
+  3. Registra en logs el n√∫mero de solicitudes procesadas
 
----
+### Tarea: Limpieza de datos antiguos
+- **Frecuencia:** Diariamente a las 3 AM UTC
+- **Funcionalidad:** Elimina solicitudes Free procesadas hace m√°s de 30 d√≠as
+- **Proceso:**
+  1. Busca solicitudes Free procesadas hace m√°s de 30 d√≠as
+  2. Elimina los registros antiguos de la base de datos
+  3. Registra en logs el n√∫mero de registros eliminados
+
+**Configuraci√≥n de intervalos:**
+- `CLEANUP_INTERVAL_MINUTES`: Intervalo para expulsi√≥n de VIPs expirados (default: 60)
+- `PROCESS_FREE_QUEUE_MINUTES`: Intervalo para procesamiento de cola Free (default: 5)
 
-**√öltima actualizaci√≥n:** 2025-12-11
-**Versi√≥n:** 1.0.0
-**Estado:** Documentaci√≥n de comandos planeados (implementaci√≥n en fases posteriores)
+Estas tareas se ejecutan autom√°ticamente sin intervenci√≥n del usuario y ayudan a mantener el sistema limpio y funcional.
\ No newline at end of file
diff --git a/main.py b/main.py
index b2467f9..fb49abf 100644
--- a/main.py
+++ b/main.py
@@ -10,6 +10,7 @@
 
 from config import Config
 from bot.database import init_db, close_db
+from bot.background import start_background_tasks, stop_background_tasks
 
 # Configurar logging
 logger = logging.getLogger(__name__)
@@ -54,6 +55,9 @@ async def on_startup(bot: Bot, dispatcher: Dispatcher) -> None:
     # dispatcher.update.middleware(DatabaseMiddleware())
     # dispatcher.message.middleware(AdminAuthMiddleware())
 
+    # Iniciar background tasks
+    start_background_tasks(bot)
+
     # Notificar a admins que el bot est√° online
     bot_info = await bot.get_me()
     startup_message = (
@@ -94,6 +98,9 @@ async def on_shutdown(bot: Bot, dispatcher: Dispatcher) -> None:
     """
     logger.info("üõë Cerrando bot...")
 
+    # Detener background tasks
+    stop_background_tasks()
+
     # Notificar a admins
     shutdown_message = "üõë Bot detenido correctamente"
 
@@ -106,10 +113,6 @@ async def on_shutdown(bot: Bot, dispatcher: Dispatcher) -> None:
         except Exception as e:
             logger.warning(f"‚ö†Ô∏è No se pudo notificar shutdown a admin {admin_id}: {e}")
 
-    # TODO: Detener background tasks (ONDA 1 - Fase 1.4)
-    # from bot.background.tasks import stop_background_tasks
-    # await stop_background_tasks()
-
     # Cerrar base de datos
     await close_db()
 
diff --git a/requirements.txt b/requirements.txt
index 1c0647b..45debcf 100644
--- a/requirements.txt
+++ b/requirements.txt
@@ -11,6 +11,6 @@ APScheduler==3.10.4
 # Configuration
 python-dotenv==1.0.0
 
-# Development & Testing (opcional, comentados por defecto)
-# pytest==7.4.3
-# pytest-asyncio==0.21.1
+# Development & Testing
+pytest==7.4.3
+pytest-asyncio==0.21.1
diff --git a/scripts/run_tests.sh b/scripts/run_tests.sh
new file mode 100755
index 0000000..fdcbbc4
--- /dev/null
+++ b/scripts/run_tests.sh
@@ -0,0 +1,32 @@
+#!/bin/bash
+# Script helper para ejecutar tests
+
+set -e
+
+echo "üß™ Ejecutando suite de tests..."
+echo ""
+
+# Verificar que pytest esta instalado
+if ! command -v pytest &> /dev/null; then
+    echo "‚ùå pytest no esta instalado"
+    echo "   Instala con: pip install pytest pytest-asyncio --break-system-packages"
+    exit 1
+fi
+
+# Limpiar base de datos de prueba
+echo "üóëÔ∏è  Limpiando BD de prueba anterior..."
+rm -f bot.db bot.db-shm bot.db-wal
+
+# Ejecutar tests
+echo "‚ñ∂Ô∏è  Ejecutando tests..."
+echo ""
+pytest tests/ -v --tb=short
+
+# Resultado
+echo ""
+if [ $? -eq 0 ]; then
+    echo "‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON"
+else
+    echo "‚ùå ALGUNOS TESTS FALLARON"
+    exit 1
+fi
diff --git a/test_admin_handler.py b/test_admin_handler.py
new file mode 100644
index 0000000..1ff2c0b
--- /dev/null
+++ b/test_admin_handler.py
@@ -0,0 +1,93 @@
+"""
+Tests b√°sicos para el handler /admin (bot/handlers/admin/main.py).
+
+Nota: Tests limitados sin bot corriendo. Tests completos requieren bot en ejecuci√≥n.
+"""
+import asyncio
+from bot.handlers.admin import admin_router
+
+
+def test_admin_router():
+    """Test que el router est√° correctamente configurado"""
+    print("\n" + "=" * 60)
+    print("TEST: Admin Router")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Router existe y tiene nombre")
+    assert admin_router is not None, "admin_router es None"
+    assert admin_router.name == "admin", f"Nombre incorrecto: {admin_router.name}"
+    print("‚úÖ Router OK")
+    print(f"   Nombre: {admin_router.name}")
+
+    print("\nüß™ Test 2: Router tiene handlers registrados")
+    # Verificar que el router tiene handlers (esto es impl√≠cito en aiogram)
+    assert hasattr(admin_router, "message"), "Router no tiene atributo 'message'"
+    assert hasattr(admin_router, "callback_query"), "Router no tiene atributo 'callback_query'"
+    print("‚úÖ Handlers registrados OK")
+
+    print("\n‚úÖ ROUTER TEST PASADO")
+
+
+async def test_imports():
+    """Test que todos los imports funcionan correctamente"""
+    print("\n" + "=" * 60)
+    print("TEST: Imports")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Importar admin_router")
+    from bot.handlers.admin import admin_router as router
+    assert router is not None
+    print("‚úÖ admin_router importado OK")
+
+    print("\nüß™ Test 2: Importar keyboards")
+    from bot.utils.keyboards import (
+        create_inline_keyboard,
+        admin_main_menu_keyboard,
+        back_to_main_menu_keyboard,
+        yes_no_keyboard
+    )
+    assert create_inline_keyboard is not None
+    assert admin_main_menu_keyboard is not None
+    assert back_to_main_menu_keyboard is not None
+    assert yes_no_keyboard is not None
+    print("‚úÖ Keyboards importadas OK")
+
+    print("\nüß™ Test 3: Importar handler module")
+    from bot.handlers.admin.main import cmd_admin, callback_admin_main, callback_admin_config
+    assert cmd_admin is not None
+    assert callback_admin_main is not None
+    assert callback_admin_config is not None
+    print("‚úÖ Handlers importados OK")
+
+    print("\n‚úÖ IMPORTS TEST PASADO")
+
+
+def run_all_tests():
+    """Ejecuta todos los tests"""
+    print("\n" + "=" * 60)
+    print("EJECUTANDO TESTS - ADMIN HANDLER")
+    print("=" * 60)
+
+    try:
+        test_admin_router()
+        asyncio.run(test_imports())
+
+        print("\n" + "=" * 60)
+        print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
+        print("=" * 60)
+        print("\nResumen:")
+        print("- ‚úÖ Router 'admin' configurado")
+        print("- ‚úÖ Handlers registrados (message, callback_query)")
+        print("- ‚úÖ Imports: admin_router, keyboards, handlers")
+        print("\nNota: Para tests completos de funcionalidad, ejecutar bot y probar manualmente")
+        print("\n")
+
+    except Exception as e:
+        print(f"\n‚ùå TEST FALLIDO: {e}")
+        import traceback
+        traceback.print_exc()
+        raise
+
+
+if __name__ == "__main__":
+    run_all_tests()
diff --git a/test_keyboards.py b/test_keyboards.py
new file mode 100644
index 0000000..f13addf
--- /dev/null
+++ b/test_keyboards.py
@@ -0,0 +1,163 @@
+"""
+Tests para el keyboard factory (bot/utils/keyboards.py).
+"""
+from bot.utils.keyboards import (
+    create_inline_keyboard,
+    admin_main_menu_keyboard,
+    back_to_main_menu_keyboard,
+    yes_no_keyboard
+)
+
+
+def test_create_inline_keyboard():
+    """Test la funci√≥n base create_inline_keyboard"""
+    print("\n" + "=" * 60)
+    print("TEST: create_inline_keyboard")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Single button")
+    keyboard = create_inline_keyboard([
+        [{"text": "Bot√≥n 1", "callback_data": "btn1"}]
+    ])
+    assert keyboard is not None
+    assert len(keyboard.inline_keyboard) == 1
+    assert len(keyboard.inline_keyboard[0]) == 1
+    assert keyboard.inline_keyboard[0][0].text == "Bot√≥n 1"
+    assert keyboard.inline_keyboard[0][0].callback_data == "btn1"
+    print("‚úÖ Single button OK")
+
+    print("\nüß™ Test 2: Multiple rows and columns")
+    keyboard = create_inline_keyboard([
+        [{"text": "Bot√≥n 1", "callback_data": "btn1"}],
+        [
+            {"text": "Bot√≥n 2", "callback_data": "btn2"},
+            {"text": "Bot√≥n 3", "callback_data": "btn3"}
+        ],
+        [
+            {"text": "Bot√≥n 4", "callback_data": "btn4"},
+            {"text": "Bot√≥n 5", "callback_data": "btn5"},
+            {"text": "Bot√≥n 6", "callback_data": "btn6"}
+        ]
+    ])
+    assert len(keyboard.inline_keyboard) == 3
+    assert len(keyboard.inline_keyboard[0]) == 1
+    assert len(keyboard.inline_keyboard[1]) == 2
+    assert len(keyboard.inline_keyboard[2]) == 3
+    print("‚úÖ Multiple rows and columns OK")
+
+
+def test_admin_main_menu_keyboard():
+    """Test la funci√≥n admin_main_menu_keyboard"""
+    print("\n" + "=" * 60)
+    print("TEST: admin_main_menu_keyboard")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Estructura del men√∫ principal")
+    menu = admin_main_menu_keyboard()
+
+    assert menu is not None
+    assert len(menu.inline_keyboard) == 3  # VIP, Free, Config
+    assert len(menu.inline_keyboard[0]) == 1  # VIP row
+    assert len(menu.inline_keyboard[1]) == 1  # Free row
+    assert len(menu.inline_keyboard[2]) == 1  # Config row
+    print("‚úÖ Estructura OK (3 filas, 1 bot√≥n cada una)")
+
+    print("\nüß™ Test 2: Textos y callbacks")
+    assert menu.inline_keyboard[0][0].text == "üì∫ Gesti√≥n Canal VIP"
+    assert menu.inline_keyboard[0][0].callback_data == "admin:vip"
+    print(f"   VIP: {menu.inline_keyboard[0][0].text} ‚Üí {menu.inline_keyboard[0][0].callback_data}")
+
+    assert menu.inline_keyboard[1][0].text == "üì∫ Gesti√≥n Canal Free"
+    assert menu.inline_keyboard[1][0].callback_data == "admin:free"
+    print(f"   Free: {menu.inline_keyboard[1][0].text} ‚Üí {menu.inline_keyboard[1][0].callback_data}")
+
+    assert menu.inline_keyboard[2][0].text == "‚öôÔ∏è Configuraci√≥n"
+    assert menu.inline_keyboard[2][0].callback_data == "admin:config"
+    print(f"   Config: {menu.inline_keyboard[2][0].text} ‚Üí {menu.inline_keyboard[2][0].callback_data}")
+
+    print("‚úÖ Textos y callbacks OK")
+
+
+def test_back_to_main_menu_keyboard():
+    """Test la funci√≥n back_to_main_menu_keyboard"""
+    print("\n" + "=" * 60)
+    print("TEST: back_to_main_menu_keyboard")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Estructura del bot√≥n volver")
+    back_menu = back_to_main_menu_keyboard()
+
+    assert back_menu is not None
+    assert len(back_menu.inline_keyboard) == 1
+    assert len(back_menu.inline_keyboard[0]) == 1
+    print("‚úÖ Estructura OK (1 fila, 1 bot√≥n)")
+
+    print("\nüß™ Test 2: Texto y callback")
+    assert "Volver" in back_menu.inline_keyboard[0][0].text
+    assert back_menu.inline_keyboard[0][0].callback_data == "admin:main"
+    print(f"   Bot√≥n: {back_menu.inline_keyboard[0][0].text} ‚Üí {back_menu.inline_keyboard[0][0].callback_data}")
+
+    print("‚úÖ Texto y callback OK")
+
+
+def test_yes_no_keyboard():
+    """Test la funci√≥n yes_no_keyboard"""
+    print("\n" + "=" * 60)
+    print("TEST: yes_no_keyboard")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Estructura b√°sica")
+    yn = yes_no_keyboard("callback_yes", "callback_no")
+
+    assert yn is not None
+    assert len(yn.inline_keyboard) == 1  # 1 fila
+    assert len(yn.inline_keyboard[0]) == 2  # 2 botones (S√≠ y No)
+    print("‚úÖ Estructura OK (1 fila, 2 botones)")
+
+    print("\nüß™ Test 2: Textos y callbacks")
+    assert yn.inline_keyboard[0][0].text == "‚úÖ S√≠"
+    assert yn.inline_keyboard[0][0].callback_data == "callback_yes"
+    print(f"   S√≠: {yn.inline_keyboard[0][0].text} ‚Üí {yn.inline_keyboard[0][0].callback_data}")
+
+    assert yn.inline_keyboard[0][1].text == "‚ùå No"
+    assert yn.inline_keyboard[0][1].callback_data == "callback_no"
+    print(f"   No: {yn.inline_keyboard[0][1].text} ‚Üí {yn.inline_keyboard[0][1].callback_data}")
+
+    print("‚úÖ Textos y callbacks OK")
+
+    print("\nüß™ Test 3: Callbacks personalizados")
+    yn2 = yes_no_keyboard("confirm:delete", "cancel:delete")
+    assert yn2.inline_keyboard[0][0].callback_data == "confirm:delete"
+    assert yn2.inline_keyboard[0][1].callback_data == "cancel:delete"
+    print("‚úÖ Callbacks personalizados OK")
+
+
+def run_all_tests():
+    """Ejecuta todos los tests"""
+    print("\n" + "=" * 60)
+    print("EJECUTANDO TESTS - KEYBOARD FACTORY")
+    print("=" * 60)
+
+    try:
+        test_create_inline_keyboard()
+        test_admin_main_menu_keyboard()
+        test_back_to_main_menu_keyboard()
+        test_yes_no_keyboard()
+
+        print("\n" + "=" * 60)
+        print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
+        print("=" * 60)
+        print("\nResumen:")
+        print("- ‚úÖ create_inline_keyboard (funci√≥n base)")
+        print("- ‚úÖ admin_main_menu_keyboard (3 opciones)")
+        print("- ‚úÖ back_to_main_menu_keyboard (1 bot√≥n volver)")
+        print("- ‚úÖ yes_no_keyboard (confirmaci√≥n S√≠/No)")
+        print("\n")
+
+    except AssertionError as e:
+        print(f"\n‚ùå TEST FALLIDO: {e}")
+        raise
+
+
+if __name__ == "__main__":
+    run_all_tests()
diff --git a/test_middlewares.py b/test_middlewares.py
new file mode 100644
index 0000000..7a8659e
--- /dev/null
+++ b/test_middlewares.py
@@ -0,0 +1,274 @@
+"""
+Tests para los middlewares de AdminAuth y Database.
+"""
+import asyncio
+import logging
+from unittest.mock import Mock, AsyncMock, patch
+
+import pytest
+from aiogram.types import Message, User, CallbackQuery
+from sqlalchemy.ext.asyncio import AsyncSession
+
+from config import Config
+from bot.middlewares import AdminAuthMiddleware, DatabaseMiddleware
+from bot.database import init_db, close_db
+
+logger = logging.getLogger(__name__)
+
+
+class TestAdminAuthMiddleware:
+    """Tests para AdminAuthMiddleware"""
+
+    @pytest.mark.asyncio
+    async def test_admin_user_passes(self):
+        """Test que un usuario admin pasa el middleware"""
+        middleware = AdminAuthMiddleware()
+
+        # Mock handler
+        handler = AsyncMock(return_value="handler_result")
+
+        # Crear mock de mensaje de admin
+        admin_id = Config.ADMIN_USER_IDS[0] if Config.ADMIN_USER_IDS else 123456
+        admin_user = User(id=admin_id, is_bot=False, first_name="Admin")
+        admin_message = Mock(spec=Message)
+        admin_message.from_user = admin_user
+
+        data = {}
+        result = await middleware(handler, admin_message, data)
+
+        assert result == "handler_result"
+        assert handler.called
+        assert handler.call_count == 1
+
+    @pytest.mark.asyncio
+    async def test_non_admin_user_blocked(self):
+        """Test que un usuario no-admin es bloqueado"""
+        middleware = AdminAuthMiddleware()
+
+        # Mock handler
+        handler = AsyncMock(return_value="handler_result")
+
+        # Crear mock de mensaje de non-admin
+        non_admin_user = User(id=999999, is_bot=False, first_name="NonAdmin", username="nonadmin")
+        non_admin_message = Mock(spec=Message)
+        non_admin_message.from_user = non_admin_user
+        non_admin_message.answer = AsyncMock()
+
+        data = {}
+        result = await middleware(handler, non_admin_message, data)
+
+        assert result is None
+        assert not handler.called
+        assert non_admin_message.answer.called
+
+    @pytest.mark.asyncio
+    async def test_callback_query_admin(self):
+        """Test que un usuario admin en CallbackQuery pasa"""
+        middleware = AdminAuthMiddleware()
+
+        # Mock handler
+        handler = AsyncMock(return_value="handler_result")
+
+        # Crear mock de CallbackQuery de admin
+        admin_id = Config.ADMIN_USER_IDS[0] if Config.ADMIN_USER_IDS else 123456
+        admin_user = User(id=admin_id, is_bot=False, first_name="Admin")
+        callback = Mock(spec=CallbackQuery)
+        callback.from_user = admin_user
+
+        data = {}
+        result = await middleware(handler, callback, data)
+
+        assert result == "handler_result"
+        assert handler.called
+
+    @pytest.mark.asyncio
+    async def test_callback_query_non_admin_blocked(self):
+        """Test que un usuario no-admin en CallbackQuery es bloqueado"""
+        middleware = AdminAuthMiddleware()
+
+        # Mock handler
+        handler = AsyncMock(return_value="handler_result")
+
+        # Crear mock de CallbackQuery de non-admin
+        non_admin_user = User(id=999999, is_bot=False, first_name="NonAdmin", username="nonadmin")
+        callback = Mock(spec=CallbackQuery)
+        callback.from_user = non_admin_user
+        callback.answer = AsyncMock()
+
+        data = {}
+        result = await middleware(handler, callback, data)
+
+        assert result is None
+        assert not handler.called
+        assert callback.answer.called
+
+    @pytest.mark.asyncio
+    async def test_message_without_user(self):
+        """Test que un mensaje sin usuario se deja pasar"""
+        middleware = AdminAuthMiddleware()
+
+        # Mock handler
+        handler = AsyncMock(return_value="handler_result")
+
+        # Crear mock de mensaje sin usuario
+        message = Mock(spec=Message)
+        message.from_user = None
+
+        data = {}
+        result = await middleware(handler, message, data)
+
+        # Debe permitir que pase (confiar en que es v√°lido)
+        assert result == "handler_result"
+        assert handler.called
+
+
+class TestDatabaseMiddleware:
+    """Tests para DatabaseMiddleware"""
+
+    @pytest.mark.asyncio
+    async def test_session_injection(self):
+        """Test que la sesi√≥n se inyecta correctamente"""
+        # Inicializar DB para el test
+        await init_db()
+
+        try:
+            middleware = DatabaseMiddleware()
+
+            # Mock handler que usa sesi√≥n
+            async def mock_handler(event, data):
+                assert "session" in data
+                assert data["session"] is not None
+                assert isinstance(data["session"], AsyncSession)
+                return "success"
+
+            mock_event = Mock()
+            data = {}
+
+            result = await middleware(mock_handler, mock_event, data)
+
+            assert result == "success"
+        finally:
+            await close_db()
+
+    @pytest.mark.asyncio
+    async def test_session_context_management(self):
+        """Test que el context manager maneja la sesi√≥n correctamente"""
+        await init_db()
+
+        try:
+            middleware = DatabaseMiddleware()
+
+            # Flag para verificar que la sesi√≥n se cierra
+            session_closed = False
+
+            async def mock_handler(event, data):
+                session = data["session"]
+                # Verificar que la sesi√≥n est√° abierta
+                assert session is not None
+                return "success"
+
+            mock_event = Mock()
+            data = {}
+
+            result = await middleware(mock_handler, mock_event, data)
+
+            assert result == "success"
+        finally:
+            await close_db()
+
+    @pytest.mark.asyncio
+    async def test_error_handling_in_handler(self):
+        """Test que los errores en el handler se propagan"""
+        await init_db()
+
+        try:
+            middleware = DatabaseMiddleware()
+
+            async def mock_handler(event, data):
+                raise ValueError("Test error")
+
+            mock_event = Mock()
+            data = {}
+
+            with pytest.raises(ValueError, match="Test error"):
+                await middleware(mock_handler, mock_event, data)
+        finally:
+            await close_db()
+
+
+# ===== TESTS FUNCIONALES =====
+async def run_functional_tests():
+    """Tests funcionales que se pueden ejecutar sin pytest"""
+    print("\n" + "=" * 60)
+    print("TESTS FUNCIONALES - AdminAuthMiddleware")
+    print("=" * 60)
+
+    middleware = AdminAuthMiddleware()
+
+    # Test 1: Usuario admin pasa
+    print("\nüß™ Test 1: Usuario admin (deber√≠a pasar)")
+    handler = AsyncMock(return_value="handler_result")
+    admin_id = Config.ADMIN_USER_IDS[0] if Config.ADMIN_USER_IDS else 123456
+    admin_user = User(id=admin_id, is_bot=False, first_name="Admin")
+    admin_message = Mock(spec=Message)
+    admin_message.from_user = admin_user
+
+    data = {}
+    result = await middleware(handler, admin_message, data)
+
+    assert result == "handler_result"
+    assert handler.called
+    print("‚úÖ Admin pas√≥, handler ejecutado")
+
+    # Test 2: Usuario no-admin es bloqueado
+    print("\nüß™ Test 2: Usuario no-admin (deber√≠a bloquear)")
+    handler = AsyncMock(return_value="handler_result")
+    non_admin_user = User(id=999999, is_bot=False, first_name="NonAdmin", username="nonadmin")
+    non_admin_message = Mock(spec=Message)
+    non_admin_message.from_user = non_admin_user
+    non_admin_message.answer = AsyncMock()
+
+    data = {}
+    result = await middleware(handler, non_admin_message, data)
+
+    assert result is None
+    assert not handler.called
+    assert non_admin_message.answer.called
+    print("‚úÖ No-admin bloqueado, mensaje enviado")
+
+    print("\n" + "=" * 60)
+    print("TESTS FUNCIONALES - DatabaseMiddleware")
+    print("=" * 60)
+
+    # Inicializar DB
+    await init_db()
+
+    try:
+        middleware = DatabaseMiddleware()
+
+        # Test 3: Inyecci√≥n de sesi√≥n
+        print("\nüß™ Test 3: Inyecci√≥n de sesi√≥n")
+
+        async def mock_handler(event, data):
+            assert "session" in data
+            assert data["session"] is not None
+            return "success"
+
+        mock_event = Mock()
+        data = {}
+
+        result = await middleware(mock_handler, mock_event, data)
+
+        assert result == "success"
+        print("‚úÖ Sesi√≥n inyectada correctamente")
+
+    finally:
+        await close_db()
+
+    print("\n" + "=" * 60)
+    print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON")
+    print("=" * 60)
+
+
+if __name__ == "__main__":
+    asyncio.run(run_functional_tests())
diff --git a/test_states.py b/test_states.py
new file mode 100644
index 0000000..dcd098f
--- /dev/null
+++ b/test_states.py
@@ -0,0 +1,180 @@
+"""
+Tests para los estados FSM de admin y user.
+"""
+from aiogram.fsm.state import State, StatesGroup
+from bot.states import (
+    ChannelSetupStates,
+    WaitTimeSetupStates,
+    BroadcastStates,
+    TokenRedemptionStates,
+    FreeAccessStates
+)
+
+
+def test_admin_states():
+    """Test que los estados de admin existen y son correctos"""
+    print("\n" + "=" * 60)
+    print("TEST: Admin States")
+    print("=" * 60)
+
+    # Test ChannelSetupStates
+    print("\nüß™ Test 1: ChannelSetupStates")
+    assert hasattr(ChannelSetupStates, 'waiting_for_vip_channel'), \
+        "ChannelSetupStates no tiene waiting_for_vip_channel"
+    assert hasattr(ChannelSetupStates, 'waiting_for_free_channel'), \
+        "ChannelSetupStates no tiene waiting_for_free_channel"
+    assert issubclass(ChannelSetupStates, StatesGroup), \
+        "ChannelSetupStates no hereda de StatesGroup"
+    assert isinstance(ChannelSetupStates.waiting_for_vip_channel, State), \
+        "waiting_for_vip_channel no es State"
+    assert isinstance(ChannelSetupStates.waiting_for_free_channel, State), \
+        "waiting_for_free_channel no es State"
+    print("‚úÖ ChannelSetupStates OK")
+    print(f"   - waiting_for_vip_channel: {ChannelSetupStates.waiting_for_vip_channel}")
+    print(f"   - waiting_for_free_channel: {ChannelSetupStates.waiting_for_free_channel}")
+
+    # Test WaitTimeSetupStates
+    print("\nüß™ Test 2: WaitTimeSetupStates")
+    assert hasattr(WaitTimeSetupStates, 'waiting_for_minutes'), \
+        "WaitTimeSetupStates no tiene waiting_for_minutes"
+    assert issubclass(WaitTimeSetupStates, StatesGroup), \
+        "WaitTimeSetupStates no hereda de StatesGroup"
+    assert isinstance(WaitTimeSetupStates.waiting_for_minutes, State), \
+        "waiting_for_minutes no es State"
+    print("‚úÖ WaitTimeSetupStates OK")
+    print(f"   - waiting_for_minutes: {WaitTimeSetupStates.waiting_for_minutes}")
+
+    # Test BroadcastStates
+    print("\nüß™ Test 3: BroadcastStates")
+    assert hasattr(BroadcastStates, 'waiting_for_content'), \
+        "BroadcastStates no tiene waiting_for_content"
+    assert hasattr(BroadcastStates, 'waiting_for_confirmation'), \
+        "BroadcastStates no tiene waiting_for_confirmation"
+    assert issubclass(BroadcastStates, StatesGroup), \
+        "BroadcastStates no hereda de StatesGroup"
+    assert isinstance(BroadcastStates.waiting_for_content, State), \
+        "waiting_for_content no es State"
+    assert isinstance(BroadcastStates.waiting_for_confirmation, State), \
+        "waiting_for_confirmation no es State"
+    print("‚úÖ BroadcastStates OK")
+    print(f"   - waiting_for_content: {BroadcastStates.waiting_for_content}")
+    print(f"   - waiting_for_confirmation: {BroadcastStates.waiting_for_confirmation}")
+
+    print("\n‚úÖ TODOS LOS TESTS DE ADMIN STATES PASARON")
+
+
+def test_user_states():
+    """Test que los estados de usuario existen y son correctos"""
+    print("\n" + "=" * 60)
+    print("TEST: User States")
+    print("=" * 60)
+
+    # Test TokenRedemptionStates
+    print("\nüß™ Test 1: TokenRedemptionStates")
+    assert hasattr(TokenRedemptionStates, 'waiting_for_token'), \
+        "TokenRedemptionStates no tiene waiting_for_token"
+    assert issubclass(TokenRedemptionStates, StatesGroup), \
+        "TokenRedemptionStates no hereda de StatesGroup"
+    assert isinstance(TokenRedemptionStates.waiting_for_token, State), \
+        "waiting_for_token no es State"
+    print("‚úÖ TokenRedemptionStates OK")
+    print(f"   - waiting_for_token: {TokenRedemptionStates.waiting_for_token}")
+
+    # Test FreeAccessStates
+    print("\nüß™ Test 2: FreeAccessStates")
+    assert hasattr(FreeAccessStates, 'waiting_for_approval'), \
+        "FreeAccessStates no tiene waiting_for_approval"
+    assert issubclass(FreeAccessStates, StatesGroup), \
+        "FreeAccessStates no hereda de StatesGroup"
+    assert isinstance(FreeAccessStates.waiting_for_approval, State), \
+        "waiting_for_approval no es State"
+    print("‚úÖ FreeAccessStates OK")
+    print(f"   - waiting_for_approval: {FreeAccessStates.waiting_for_approval}")
+
+    print("\n‚úÖ TODOS LOS TESTS DE USER STATES PASARON")
+
+
+def test_exports():
+    """Test que los estados se exportan correctamente desde __init__"""
+    print("\n" + "=" * 60)
+    print("TEST: Exports en __init__.py")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Todas las clases est√°n exportadas")
+    from bot.states import (
+        ChannelSetupStates,
+        WaitTimeSetupStates,
+        BroadcastStates,
+        TokenRedemptionStates,
+        FreeAccessStates
+    )
+
+    assert ChannelSetupStates is not None
+    assert WaitTimeSetupStates is not None
+    assert BroadcastStates is not None
+    assert TokenRedemptionStates is not None
+    assert FreeAccessStates is not None
+
+    print("‚úÖ Todas las clases est√°n correctamente exportadas")
+
+    print("\n‚úÖ TODOS LOS TESTS DE EXPORTS PASARON")
+
+
+def test_state_strings():
+    """Test que los strings de estados son correctos"""
+    print("\n" + "=" * 60)
+    print("TEST: State Strings")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Verificar nombres de estados")
+
+    # Admin states
+    print(f"ChannelSetupStates.waiting_for_vip_channel state: {ChannelSetupStates.waiting_for_vip_channel.state}")
+    print(f"ChannelSetupStates.waiting_for_free_channel state: {ChannelSetupStates.waiting_for_free_channel.state}")
+    print(f"WaitTimeSetupStates.waiting_for_minutes state: {WaitTimeSetupStates.waiting_for_minutes.state}")
+    print(f"BroadcastStates.waiting_for_content state: {BroadcastStates.waiting_for_content.state}")
+    print(f"BroadcastStates.waiting_for_confirmation state: {BroadcastStates.waiting_for_confirmation.state}")
+
+    # User states
+    print(f"TokenRedemptionStates.waiting_for_token state: {TokenRedemptionStates.waiting_for_token.state}")
+    print(f"FreeAccessStates.waiting_for_approval state: {FreeAccessStates.waiting_for_approval.state}")
+
+    # Verificar que los nombres contienen el grupo
+    assert "ChannelSetupStates" in ChannelSetupStates.waiting_for_vip_channel.state
+    assert "WaitTimeSetupStates" in WaitTimeSetupStates.waiting_for_minutes.state
+    assert "TokenRedemptionStates" in TokenRedemptionStates.waiting_for_token.state
+
+    print("\n‚úÖ TODOS LOS NOMBRES DE ESTADOS SON CORRECTOS")
+
+
+def run_all_tests():
+    """Ejecuta todos los tests"""
+    print("\n" + "=" * 60)
+    print("EJECUTANDO TESTS FSM STATES")
+    print("=" * 60)
+
+    try:
+        test_admin_states()
+        test_user_states()
+        test_exports()
+        test_state_strings()
+
+        print("\n" + "=" * 60)
+        print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
+        print("=" * 60)
+        print("\nResumen:")
+        print("- ‚úÖ ChannelSetupStates (2 estados)")
+        print("- ‚úÖ WaitTimeSetupStates (1 estado)")
+        print("- ‚úÖ BroadcastStates (2 estados)")
+        print("- ‚úÖ TokenRedemptionStates (1 estado)")
+        print("- ‚úÖ FreeAccessStates (1 estado)")
+        print("- ‚úÖ Total: 5 StatesGroup, 7 States")
+        print("\n")
+
+    except AssertionError as e:
+        print(f"\n‚ùå TEST FALLIDO: {e}")
+        raise
+
+
+if __name__ == "__main__":
+    run_all_tests()
diff --git a/test_user_handlers.py b/test_user_handlers.py
new file mode 100644
index 0000000..a491365
--- /dev/null
+++ b/test_user_handlers.py
@@ -0,0 +1,176 @@
+"""
+Tests b√°sicos para handlers de usuario.
+
+Tests limitados sin bot corriendo. Tests completos requieren bot en ejecuci√≥n.
+"""
+from bot.handlers.user import user_router
+from bot.handlers.user import start, vip_flow, free_flow
+
+
+def test_user_router():
+    """Test que el router de usuario est√° configurado"""
+    print("\n" + "=" * 60)
+    print("TEST: User Router")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Router existe y tiene nombre")
+    assert user_router is not None, "user_router es None"
+    assert user_router.name == "user", f"Nombre incorrecto: {user_router.name}"
+    print("‚úÖ Router OK")
+    print(f"   Nombre: {user_router.name}")
+
+    print("\nüß™ Test 2: Router tiene handlers registrados")
+    assert hasattr(user_router, "message"), "Router no tiene atributo 'message'"
+    assert hasattr(user_router, "callback_query"), "Router no tiene atributo 'callback_query'"
+    print("‚úÖ Handlers registrados OK")
+
+
+def test_start_handler():
+    """Test que el handler /start existe y es accesible"""
+    print("\n" + "=" * 60)
+    print("TEST: Start Handler")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: cmd_start existe")
+    assert hasattr(start, 'cmd_start'), "Handler cmd_start no existe"
+    assert callable(start.cmd_start), "cmd_start no es callable"
+    print("‚úÖ cmd_start OK")
+
+    print("\nüß™ Test 2: user_router en start")
+    assert start.user_router is not None
+    assert start.user_router.name == "user"
+    print("‚úÖ user_router compartido OK")
+
+
+def test_vip_flow_handlers():
+    """Test que los handlers VIP existen"""
+    print("\n" + "=" * 60)
+    print("TEST: VIP Flow Handlers")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: VIP flow callbacks")
+    assert hasattr(vip_flow, 'callback_redeem_token'), "callback_redeem_token no existe"
+    assert hasattr(vip_flow, 'process_token_input'), "process_token_input no existe"
+    assert hasattr(vip_flow, 'callback_cancel'), "callback_cancel no existe"
+    print("‚úÖ VIP callbacks OK")
+
+    print("\nüß™ Test 2: VIP flow callables")
+    assert callable(vip_flow.callback_redeem_token)
+    assert callable(vip_flow.process_token_input)
+    assert callable(vip_flow.callback_cancel)
+    print("‚úÖ VIP callables OK")
+
+
+def test_free_flow_handlers():
+    """Test que los handlers Free existen"""
+    print("\n" + "=" * 60)
+    print("TEST: Free Flow Handlers")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Free flow callback")
+    assert hasattr(free_flow, 'callback_request_free'), "callback_request_free no existe"
+    assert callable(free_flow.callback_request_free)
+    print("‚úÖ Free callback OK")
+
+
+def test_callback_data():
+    """Test que los callback_data son correctos"""
+    print("\n" + "=" * 60)
+    print("TEST: Callback Data")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Verificar prefijos de callbacks")
+    # Los callbacks est√°n registrados con F.data == "user:..."
+    # Verificamos que el c√≥digo los menciona correctamente
+
+    import inspect
+
+    # Check vip_flow
+    vip_source = inspect.getsource(vip_flow.callback_redeem_token)
+    assert '"user:redeem_token"' in vip_source or "'user:redeem_token'" in vip_source
+    print("‚úÖ VIP callback data: user:redeem_token")
+
+    # Check free_flow
+    free_source = inspect.getsource(free_flow.callback_request_free)
+    assert '"user:request_free"' in free_source or "'user:request_free'" in free_source
+    print("‚úÖ Free callback data: user:request_free")
+
+    # Check cancel
+    cancel_source = inspect.getsource(vip_flow.callback_cancel)
+    assert '"user:cancel"' in cancel_source or "'user:cancel'" in cancel_source
+    print("‚úÖ Cancel callback data: user:cancel")
+
+
+def test_states_imported():
+    """Test que los estados FSM se importan correctamente"""
+    print("\n" + "=" * 60)
+    print("TEST: FSM States")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Verificar que TokenRedemptionStates est√° disponible")
+    from bot.states.user import TokenRedemptionStates, FreeAccessStates
+    assert TokenRedemptionStates is not None
+    assert FreeAccessStates is not None
+    print("‚úÖ User states importados OK")
+
+    print("\nüß™ Test 2: Estados disponibles")
+    assert hasattr(TokenRedemptionStates, 'waiting_for_token')
+    assert hasattr(FreeAccessStates, 'waiting_for_approval')
+    print("‚úÖ Token y Free states disponibles")
+
+
+def test_imports():
+    """Test que todos los imports funcionan"""
+    print("\n" + "=" * 60)
+    print("TEST: Imports")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Importar user_router")
+    from bot.handlers.user import user_router as router
+    assert router is not None
+    print("‚úÖ user_router importado OK")
+
+    print("\nüß™ Test 2: Verificar que user_router es el mismo en todos los m√≥dulos")
+    assert start.user_router is vip_flow.user_router
+    assert vip_flow.user_router is free_flow.user_router
+    print("‚úÖ user_router compartido en todos los m√≥dulos")
+
+
+def run_all_tests():
+    """Ejecuta todos los tests"""
+    print("\n" + "=" * 60)
+    print("EJECUTANDO TESTS - USER HANDLERS")
+    print("=" * 60)
+
+    try:
+        test_user_router()
+        test_start_handler()
+        test_vip_flow_handlers()
+        test_free_flow_handlers()
+        test_callback_data()
+        test_states_imported()
+        test_imports()
+
+        print("\n" + "=" * 60)
+        print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
+        print("=" * 60)
+        print("\nResumen:")
+        print("- ‚úÖ Router 'user' configurado")
+        print("- ‚úÖ Handler /start implementado")
+        print("- ‚úÖ VIP flow: redeem_token, process_input, cancel")
+        print("- ‚úÖ Free flow: request_free")
+        print("- ‚úÖ Callback data correctos: user:*")
+        print("- ‚úÖ FSM States importables")
+        print("- ‚úÖ user_router compartido")
+        print("\nNota: Tests funcionales requieren bot ejecut√°ndose")
+        print("\n")
+
+    except AssertionError as e:
+        print(f"\n‚ùå TEST FALLIDO: {e}")
+        import traceback
+        traceback.print_exc()
+        raise
+
+
+if __name__ == "__main__":
+    run_all_tests()
diff --git a/test_vip_free_handlers.py b/test_vip_free_handlers.py
new file mode 100644
index 0000000..261f845
--- /dev/null
+++ b/test_vip_free_handlers.py
@@ -0,0 +1,160 @@
+"""
+Tests b√°sicos para handlers VIP y Free.
+
+Tests limitados sin bot corriendo. Tests completos requieren bot en ejecuci√≥n.
+"""
+import asyncio
+from bot.handlers.admin import vip, free
+from bot.utils.keyboards import create_inline_keyboard
+
+
+def test_keyboards():
+    """Test que los keyboards se crean correctamente"""
+    print("\n" + "=" * 60)
+    print("TEST: Keyboards VIP y Free")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: vip_menu_keyboard - No configurado")
+    keyboard = vip.vip_menu_keyboard(is_configured=False)
+    assert keyboard is not None
+    assert len(keyboard.inline_keyboard) >= 2  # Setup + Volver
+    print(f"‚úÖ VIP keyboard (no config): {len(keyboard.inline_keyboard)} filas")
+
+    print("\nüß™ Test 2: vip_menu_keyboard - Configurado")
+    keyboard = vip.vip_menu_keyboard(is_configured=True)
+    assert keyboard is not None
+    assert len(keyboard.inline_keyboard) >= 3  # Token + Reconfig + Volver
+    assert "üéüÔ∏è" in keyboard.inline_keyboard[0][0].text
+    print(f"‚úÖ VIP keyboard (configurado): {len(keyboard.inline_keyboard)} filas")
+    print(f"   Botones: {[btn[0].text for btn in keyboard.inline_keyboard]}")
+
+    print("\nüß™ Test 3: free_menu_keyboard - No configurado")
+    keyboard = free.free_menu_keyboard(is_configured=False)
+    assert keyboard is not None
+    assert len(keyboard.inline_keyboard) >= 2  # Setup + Volver
+    print(f"‚úÖ Free keyboard (no config): {len(keyboard.inline_keyboard)} filas")
+
+    print("\nüß™ Test 4: free_menu_keyboard - Configurado")
+    keyboard = free.free_menu_keyboard(is_configured=True)
+    assert keyboard is not None
+    assert len(keyboard.inline_keyboard) >= 3  # WaitTime + Reconfig + Volver
+    assert "‚è±Ô∏è" in keyboard.inline_keyboard[0][0].text
+    print(f"‚úÖ Free keyboard (configurado): {len(keyboard.inline_keyboard)} filas")
+    print(f"   Botones: {[btn[0].text for btn in keyboard.inline_keyboard]}")
+
+
+def test_imports():
+    """Test que los imports funcionan correctamente"""
+    print("\n" + "=" * 60)
+    print("TEST: Imports")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Importar handlers VIP")
+    assert hasattr(vip, 'callback_vip_menu')
+    assert hasattr(vip, 'callback_vip_setup')
+    assert hasattr(vip, 'process_vip_channel_forward')
+    assert hasattr(vip, 'callback_generate_vip_token')
+    assert hasattr(vip, 'vip_menu_keyboard')
+    assert hasattr(vip, 'admin_router')
+    print("‚úÖ VIP handlers importados OK")
+
+    print("\nüß™ Test 2: Importar handlers Free")
+    assert hasattr(free, 'callback_free_menu')
+    assert hasattr(free, 'callback_free_setup')
+    assert hasattr(free, 'process_free_channel_forward')
+    assert hasattr(free, 'callback_set_wait_time')
+    assert hasattr(free, 'process_wait_time_input')
+    assert hasattr(free, 'free_menu_keyboard')
+    assert hasattr(free, 'admin_router')
+    print("‚úÖ Free handlers importados OK")
+
+    print("\nüß™ Test 3: Verificar que admin_router es el mismo")
+    assert vip.admin_router is free.admin_router, "admin_router debe ser el mismo en ambos"
+    print("‚úÖ admin_router es compartido correctamente")
+
+
+def test_callback_data():
+    """Test que los callback_data son correctos"""
+    print("\n" + "=" * 60)
+    print("TEST: Callback Data")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: VIP callbacks")
+    vip_keyboard = vip.vip_menu_keyboard(is_configured=True)
+    callbacks = []
+    for row in vip_keyboard.inline_keyboard:
+        for btn in row:
+            callbacks.append(btn.callback_data)
+
+    assert "vip:generate_token" in callbacks
+    assert "vip:setup" in callbacks or "vip:reconfigurar" in str(callbacks).lower()
+    assert "admin:main" in callbacks
+    print(f"‚úÖ VIP callbacks: {callbacks}")
+
+    print("\nüß™ Test 2: Free callbacks")
+    free_keyboard = free.free_menu_keyboard(is_configured=True)
+    callbacks = []
+    for row in free_keyboard.inline_keyboard:
+        for btn in row:
+            callbacks.append(btn.callback_data)
+
+    assert "free:set_wait_time" in callbacks
+    assert "free:setup" in callbacks or "free:reconfigurar" in str(callbacks).lower()
+    assert "admin:main" in callbacks
+    print(f"‚úÖ Free callbacks: {callbacks}")
+
+
+def test_states_imported():
+    """Test que los estados FSM se importan correctamente"""
+    print("\n" + "=" * 60)
+    print("TEST: FSM States")
+    print("=" * 60)
+
+    print("\nüß™ Test 1: Verificar que ChannelSetupStates est√° disponible")
+    from bot.states.admin import ChannelSetupStates, WaitTimeSetupStates
+    assert ChannelSetupStates is not None
+    assert WaitTimeSetupStates is not None
+    print("‚úÖ States importados OK")
+
+    print("\nüß™ Test 2: Estados VIP y Free disponibles")
+    assert hasattr(ChannelSetupStates, 'waiting_for_vip_channel')
+    assert hasattr(ChannelSetupStates, 'waiting_for_free_channel')
+    print("‚úÖ ChannelSetupStates tiene estados VIP y Free")
+
+    assert hasattr(WaitTimeSetupStates, 'waiting_for_minutes')
+    print("‚úÖ WaitTimeSetupStates tiene estado waiting_for_minutes")
+
+
+def run_all_tests():
+    """Ejecuta todos los tests"""
+    print("\n" + "=" * 60)
+    print("EJECUTANDO TESTS - VIP Y FREE HANDLERS")
+    print("=" * 60)
+
+    try:
+        test_keyboards()
+        test_imports()
+        test_callback_data()
+        test_states_imported()
+
+        print("\n" + "=" * 60)
+        print("‚úÖ‚úÖ‚úÖ TODOS LOS TESTS PASARON EXITOSAMENTE")
+        print("=" * 60)
+        print("\nResumen:")
+        print("- ‚úÖ Keyboards VIP y Free crean correctamente")
+        print("- ‚úÖ Handlers importables (VIP y Free)")
+        print("- ‚úÖ admin_router compartido correctamente")
+        print("- ‚úÖ Callback data correctos")
+        print("- ‚úÖ FSM States importables")
+        print("\nNota: Tests funcionales requieren bot ejecut√°ndose")
+        print("\n")
+
+    except AssertionError as e:
+        print(f"\n‚ùå TEST FALLIDO: {e}")
+        import traceback
+        traceback.print_exc()
+        raise
+
+
+if __name__ == "__main__":
+    run_all_tests()
diff --git a/tests/README.md b/tests/README.md
new file mode 100644
index 0000000..63e6bb2
--- /dev/null
+++ b/tests/README.md
@@ -0,0 +1,234 @@
+# Tests - Bot Telegram VIP/Free
+
+Suite de tests para validar funcionalidad completa del bot.
+
+## Estructura
+
+```
+tests/
+‚îú‚îÄ‚îÄ conftest.py           # Fixtures compartidos
+‚îú‚îÄ‚îÄ test_e2e_flows.py     # Tests end-to-end (flujos completos)
+‚îú‚îÄ‚îÄ test_integration.py   # Tests de integracion
+‚îî‚îÄ‚îÄ __init__.py          # Package marker
+```
+
+## Instalacion de Dependencias
+
+```bash
+# Instalar pytest y pytest-asyncio
+pip install pytest==7.4.3 pytest-asyncio==0.21.1 --break-system-packages
+```
+
+## Ejecutar Tests
+
+### Todos los tests
+```bash
+pytest tests/ -v
+```
+
+### Solo tests E2E
+```bash
+pytest tests/test_e2e_flows.py -v
+```
+
+### Solo tests de integracion
+```bash
+pytest tests/test_integration.py -v
+```
+
+### Test especifico
+```bash
+pytest tests/test_e2e_flows.py::test_vip_flow_complete -v
+```
+
+### Con output detallado (muestra prints)
+```bash
+pytest tests/ -v -s
+```
+
+### Detener en primer fallo
+```bash
+pytest tests/ -x
+```
+
+## Tests E2E Disponibles
+
+### `test_vip_flow_complete`
+Valida flujo VIP completo:
+1. Admin genera token VIP (16 caracteres)
+2. Usuario canjea token (valida token, crea suscripcion)
+3. Usuario obtiene acceso VIP (is_vip_active=True)
+4. Verificacion en BD (token marcado usado, suscriptor activo)
+
+**Validaciones:**
+- Token generado correctamente
+- Suscriptor creado con status='active'
+- Token marcado como used despues del canje
+- dias_remaining() > 0
+
+### `test_free_flow_complete`
+Valida flujo Free completo:
+1. Usuario solicita acceso Free
+2. Solicitud queda pendiente (processed=False)
+3. Tiempo de espera pasa (simular request_date antigua)
+4. Solicitud se procesa (processed=True, processed_at set)
+5. No se procesa dos veces (segunda llamada retorna [])
+
+**Validaciones:**
+- Solicitud creada correctamente
+- No se procesa inmediatamente
+- Se procesa despues del wait_time
+- No hay duplicacion
+
+### `test_vip_expiration`
+Valida expiracion automatica de VIP:
+1. Crear VIP con expiry_date en el pasado
+2. Ejecutar tarea de expiracion (expire_vip_subscribers)
+3. Verificar marcado como expired (status='expired')
+4. Verificar is_vip_active() retorna False
+
+**Validaciones:**
+- is_expired() detecta expiracion
+- expire_vip_subscribers() marca correctamente
+- Status cambio a 'expired'
+- is_vip_active() retorna False
+
+### `test_token_validation_edge_cases`
+Valida casos edge de tokens:
+- Token no existe: validate_token retorna False + "no encontrado"
+- Token usado: validate_token retorna False + "usado"
+- Token expirado: validate_token retorna False + "expirado"
+- Token valido: validate_token retorna True + "valido"
+
+**Validaciones:**
+- Cada caso rechaza/acepta correctamente
+- Mensajes claros y especificos
+
+### `test_duplicate_free_request_prevention`
+Valida prevencion de solicitudes duplicadas:
+1. Usuario crea primera solicitud Free
+2. Intenta crear segunda solicitud
+3. Segunda retorna solicitud existente (no crea duplicada)
+
+**Validaciones:**
+- Primera solicitud creada
+- Segunda retorna existente (mismo id)
+
+## Tests de Integracion Disponibles
+
+### `test_service_container_lazy_loading`
+Valida que ServiceContainer carga services lazy:
+- Container comienza sin services
+- Primer acceso carga el service
+- Acceso posterior reutiliza instancia
+- get_loaded_services() muestra loaded
+
+### `test_config_service_singleton`
+Valida que BotConfig es singleton:
+- BotConfig siempre tiene id=1
+- Cambios persisten en BD
+- Siguiente get_config() ve cambios
+
+### `test_database_session_management`
+Valida manejo de sesiones de BD:
+- Multiples sesiones ven cambios reciprocos
+- No hay conflictos de sesion
+- Transacciones se aplican correctamente
+
+### `test_error_handling_across_services`
+Valida manejo de errores entre servicios:
+- Token invalido rechazado
+- Token inexistente detectado
+- Solicitudes sin errores
+- Mensajes claros
+
+## Estructura de Fixtures
+
+### `setup_database` (function scope)
+```python
+@pytest.fixture(scope="function")
+async def setup_database():
+    await init_db()
+    yield
+    await close_db()
+```
+
+- Inicializa BD antes de cada test
+- Limpia BD despues (garantiza BD limpia)
+- Scope "function" = nueva BD por test
+
+### `mock_bot`
+```python
+@pytest.fixture
+def mock_bot():
+    bot = Mock()
+    bot.get_chat = AsyncMock()
+    bot.send_message = AsyncMock()
+    # ... mas mocks
+```
+
+- Mock del bot de Telegram
+- Todos los metodos retornan AsyncMock
+- No hace llamadas reales a API Telegram
+
+## Debugging Tests
+
+### Ver prints en test
+```bash
+pytest tests/test_e2e_flows.py::test_vip_flow_complete -v -s
+```
+
+La flag `-s` muestra todos los `print()` en tests.
+
+### Ver traceback completo
+```bash
+pytest tests/ --tb=long
+```
+
+Opciones: `short`, `long`, `line`, `no`
+
+### Ejecutar test especifico con pdb
+```bash
+pytest tests/test_e2e_flows.py::test_vip_flow_complete -v -s --pdb
+```
+
+Se abrira debugger en asserts fallidos.
+
+## Limpieza Manual
+
+Si tests dejan BD sucia:
+```bash
+rm bot.db bot.db-shm bot.db-wal
+```
+
+Siguiente test reiniciara BD limpia.
+
+## Expected Output
+
+```
+tests/test_e2e_flows.py::test_vip_flow_complete PASSED        [  16%]
+tests/test_e2e_flows.py::test_free_flow_complete PASSED       [  33%]
+tests/test_e2e_flows.py::test_vip_expiration PASSED           [  50%]
+tests/test_e2e_flows.py::test_token_validation_edge_cases PASSED [  66%]
+tests/test_e2e_flows.py::test_duplicate_free_request_prevention PASSED [  83%]
+tests/test_integration.py::test_service_container_lazy_loading PASSED [100%]
+tests/test_integration.py::test_config_service_singleton PASSED
+tests/test_integration.py::test_database_session_management PASSED
+tests/test_integration.py::test_error_handling_across_services PASSED
+
+========================= 9 passed in X.XXs =========================
+```
+
+## Anti-Patterns a Evitar
+
+- ‚ùå NO compartir estado entre tests (usar fixtures)
+- ‚ùå NO hardcodear valores (usar variables descriptivas)
+- ‚ùå NO tests muy largos (dividir en multiples tests)
+- ‚ùå NO assertions sin mensaje (siempre incluir assert message)
+- ‚ùå NO olvidar fixture en parametros test (test no ve BD limpia)
+
+## Recursos
+
+- [pytest docs](https://docs.pytest.org/)
+- [pytest-asyncio](https://pytest-asyncio.readthedocs.io/)
+- [unittest.mock docs](https://docs.python.org/3/library/unittest.mock.html)
diff --git a/tests/__init__.py b/tests/__init__.py
new file mode 100644
index 0000000..e69de29
diff --git a/tests/conftest.py b/tests/conftest.py
new file mode 100644
index 0000000..a84f1f8
--- /dev/null
+++ b/tests/conftest.py
@@ -0,0 +1,64 @@
+"""
+Pytest Configuration and Shared Fixtures.
+
+Proporciona fixtures comunes para todos los tests:
+- mock_bot: Mock del bot de Telegram
+"""
+import pytest
+import asyncio
+from unittest.mock import AsyncMock, Mock
+
+from bot.database import init_db, close_db
+
+
+@pytest.fixture
+def event_loop():
+    """
+    Fixture: Event loop para tests async.
+    """
+    loop = asyncio.new_event_loop()
+    asyncio.set_event_loop(loop)
+    yield loop
+    loop.close()
+
+
+# Hook para inicializar BD antes de cada test async
+@pytest.fixture(autouse=True)
+def db_setup(event_loop):
+    """
+    Setup BD antes de cada test.
+    """
+    # Ejecutar init_db antes del test
+    event_loop.run_until_complete(init_db())
+
+    yield
+
+    # Limpiar BD despues del test
+    event_loop.run_until_complete(close_db())
+
+
+@pytest.fixture
+def mock_bot():
+    """
+    Fixture: Mock del bot de Telegram.
+
+    Proporciona mock de m√©todos Telegram API necesarios:
+    - get_chat
+    - get_chat_member
+    - create_chat_invite_link
+    - ban_chat_member
+    - unban_chat_member
+    - send_message
+    """
+    bot = Mock()
+    bot.id = 123456789
+
+    # Mock de m√©todos necesarios (retornan AsyncMock)
+    bot.get_chat = AsyncMock()
+    bot.get_chat_member = AsyncMock()
+    bot.create_chat_invite_link = AsyncMock()
+    bot.ban_chat_member = AsyncMock()
+    bot.unban_chat_member = AsyncMock()
+    bot.send_message = AsyncMock()
+
+    return bot
diff --git a/tests/test_e2e_flows.py b/tests/test_e2e_flows.py
new file mode 100644
index 0000000..96501bd
--- /dev/null
+++ b/tests/test_e2e_flows.py
@@ -0,0 +1,339 @@
+"""
+End-to-End Tests - Flujos completos del usuario.
+
+Tests que validan escenarios reales de principio a fin:
+- Flujo VIP completo (generar token -> canjear -> acceso)
+- Flujo Free completo (solicitar -> esperar -> acceso)
+- Expulsion automatica de VIP
+- Validacion de tokens (edge cases)
+"""
+import pytest
+from datetime import datetime, timedelta
+
+from bot.database import get_session
+from bot.database.models import InvitationToken, VIPSubscriber
+from bot.services.container import ServiceContainer
+from sqlalchemy import select
+
+
+@pytest.mark.asyncio
+async def test_vip_flow_complete(mock_bot):
+    """
+    Test E2E: Flujo VIP completo.
+
+    Escenario:
+    1. Admin genera token VIP
+    2. Usuario canjea token
+    3. Usuario recibe suscripcion VIP activa
+    4. Verificar datos en BD
+
+    Expected:
+    - Token generado con 16 caracteres
+    - Token validado como unused
+    - Suscriptor creado con status='active'
+    - Token marcado como used despues del canje
+    """
+    print("\n[TEST] Flujo VIP Completo")
+
+    admin_id = 111111
+    user_id = 222222
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Paso 1: Admin genera token
+        print("  1. Generando token VIP...")
+        token = await container.subscription.generate_vip_token(
+            generated_by=admin_id,
+            duration_hours=24
+        )
+
+        assert token.token is not None
+        assert len(token.token) == 16
+        assert token.used == False
+        print(f"     OK: Token generado: {token.token}")
+
+        # Paso 2: Usuario canjea token
+        print("  2. Canjeando token...")
+        success, msg, subscriber = await container.subscription.redeem_vip_token(
+            token_str=token.token,
+            user_id=user_id
+        )
+
+        assert success == True
+        assert subscriber is not None
+        assert subscriber.user_id == user_id
+        assert subscriber.status == "active"
+        print(f"     OK: Token canjeado")
+
+        # Paso 3: Verificar suscripcion activa
+        print("  3. Verificando suscripcion...")
+        is_vip = await container.subscription.is_vip_active(user_id)
+        assert is_vip == True
+
+        days = subscriber.days_remaining()
+        assert days >= 0  # Puede ser 0 si se cre√≥ hoy
+        print(f"     OK: VIP activo ({days} dias restantes)")
+
+        # Paso 4: Verificar token marcado como usado
+        print("  4. Verificando token usado...")
+        result = await session.execute(
+            select(InvitationToken).where(InvitationToken.token == token.token)
+        )
+        used_token = result.scalar_one()
+
+        assert used_token.used == True
+        assert used_token.used_by == user_id
+        assert used_token.used_at is not None
+        print(f"     OK: Token marcado como usado")
+
+    print("  [PASSED] Flujo VIP Completo\n")
+
+
+@pytest.mark.asyncio
+async def test_free_flow_complete(mock_bot):
+    """
+    Test E2E: Flujo Free completo.
+
+    Escenario:
+    1. Usuario solicita acceso Free
+    2. Solicitud queda pendiente
+    3. Simular paso del tiempo (modificar request_date)
+    4. Procesar cola
+    5. Verificar solicitud procesada
+
+    Expected:
+    - Solicitud creada con processed=False
+    - No se procesa inmediatamente
+    - Se procesa despues del wait_time
+    - No se procesa dos veces
+    """
+    print("\n[TEST] Flujo Free Completo")
+
+    user_id = 333333
+    wait_time = 5
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Configurar tiempo de espera
+        await container.config.set_wait_time(wait_time)
+
+        # Paso 1: Usuario solicita acceso
+        print("  1. Creando solicitud Free...")
+        request = await container.subscription.create_free_request(user_id)
+
+        assert request.user_id == user_id
+        assert request.processed == False
+        print(f"     OK: Solicitud creada (ID: {request.id})")
+
+        # Paso 2: Verificar no se puede procesar inmediatamente
+        print("  2. Verificando solicitud pendiente...")
+        ready = await container.subscription.process_free_queue(wait_time)
+        assert len(ready) == 0
+        print(f"     OK: Solicitud en espera")
+
+        # Paso 3: Simular paso del tiempo
+        print(f"  3. Simulando espera de {wait_time} minutos...")
+        request.request_date = datetime.utcnow() - timedelta(minutes=wait_time + 1)
+        await session.commit()
+        print(f"     OK: Tiempo simulado")
+
+        # Paso 4: Procesar cola
+        print("  4. Procesando cola Free...")
+        ready = await container.subscription.process_free_queue(wait_time)
+
+        assert len(ready) == 1
+        assert ready[0].user_id == user_id
+        assert ready[0].processed == True
+        assert ready[0].processed_at is not None
+        print(f"     OK: Solicitud procesada")
+
+        # Paso 5: Verificar no se procesa dos veces
+        print("  5. Verificando no duplicacion...")
+        ready_again = await container.subscription.process_free_queue(wait_time)
+        assert len(ready_again) == 0
+        print(f"     OK: No se procesa dos veces")
+
+    print("  [PASSED] Flujo Free Completo\n")
+
+
+@pytest.mark.asyncio
+async def test_vip_expiration(mock_bot):
+    """
+    Test E2E: Expiracion automatica de VIP.
+
+    Escenario:
+    1. Crear suscriptor VIP con fecha de expiracion pasada
+    2. Ejecutar tarea de expiracion
+    3. Verificar marcado como expirado
+    4. Verificar ya no es VIP activo
+
+    Expected:
+    - Suscriptor creado con fecha pasada
+    - is_expired() retorna True
+    - expire_vip_subscribers() marca como expired
+    - is_vip_active() retorna False despues
+    """
+    print("\n[TEST] Expiracion VIP")
+
+    user_id = 444444
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Paso 1: Crear suscriptor VIP expirado
+        print("  1. Creando suscriptor VIP expirado...")
+
+        # Crear token primero
+        token = InvitationToken(
+            token="EXPIREDTOKEN123",
+            generated_by=111111,
+            created_at=datetime.utcnow() - timedelta(days=2),
+            duration_hours=24,
+            used=True,
+            used_by=user_id,
+            used_at=datetime.utcnow() - timedelta(days=2)
+        )
+        session.add(token)
+        await session.commit()
+        await session.refresh(token)
+
+        # Crear suscriptor expirado
+        subscriber = VIPSubscriber(
+            user_id=user_id,
+            join_date=datetime.utcnow() - timedelta(days=2),
+            expiry_date=datetime.utcnow() - timedelta(days=1),
+            status="active",
+            token_id=token.id
+        )
+        session.add(subscriber)
+        await session.commit()
+        print(f"     OK: Suscriptor creado (expirado ayer)")
+
+        # Paso 2: Verificar is_expired() funciona
+        print("  2. Verificando deteccion de expiracion...")
+        assert subscriber.is_expired() == True
+        print(f"     OK: Detectado como expirado")
+
+        # Paso 3: Ejecutar tarea de expiracion
+        print("  3. Ejecutando tarea de expiracion...")
+        expired_count = await container.subscription.expire_vip_subscribers()
+        assert expired_count == 1
+        print(f"     OK: {expired_count} suscriptor(es) expirados")
+
+        # Paso 4: Verificar estado actualizado
+        print("  4. Verificando estado actualizado...")
+        await session.refresh(subscriber)
+        assert subscriber.status == "expired"
+        print(f"     OK: Status actualizado a 'expired'")
+
+        # Paso 5: Verificar is_vip_active() retorna False
+        print("  5. Verificando is_vip_active()...")
+        is_vip = await container.subscription.is_vip_active(user_id)
+        assert is_vip == False
+        print(f"     OK: Ya no es VIP activo")
+
+    print("  [PASSED] Expiracion VIP\n")
+
+
+@pytest.mark.asyncio
+async def test_token_validation_edge_cases(mock_bot):
+    """
+    Test E2E: Casos edge de validacion de tokens.
+
+    Casos validados:
+    - Token no existe
+    - Token ya usado
+    - Token expirado
+    - Token valido
+
+    Expected:
+    - Token inexistente: is_valid=False, "no encontrado" en msg
+    - Token usado: is_valid=False, "usado" en msg
+    - Token expirado: is_valid=False, "expirado" en msg
+    - Token valido: is_valid=True, "valido" en msg
+    """
+    print("\n[TEST] Validacion de Tokens (Edge Cases)")
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Caso 1: Token no existe
+        print("  1. Token no existente...")
+        is_valid, msg, _ = await container.subscription.validate_token("NOEXISTE12345678")
+        assert is_valid == False
+        assert "no encontrado" in msg.lower()
+        print(f"     OK: Rechazado - {msg}")
+
+        # Caso 2: Token usado
+        print("  2. Token ya usado...")
+        token_usado = await container.subscription.generate_vip_token(111111, 24)
+        token_usado.used = True
+        token_usado.used_by = 999999
+        await session.commit()
+
+        is_valid, msg, _ = await container.subscription.validate_token(token_usado.token)
+        assert is_valid == False
+        assert "usado" in msg.lower()
+        print(f"     OK: Rechazado - {msg}")
+
+        # Caso 3: Token expirado
+        print("  3. Token expirado...")
+        token_expirado = await container.subscription.generate_vip_token(111111, 1)
+        token_expirado.created_at = datetime.utcnow() - timedelta(hours=2)
+        await session.commit()
+
+        is_valid, msg, _ = await container.subscription.validate_token(token_expirado.token)
+        assert is_valid == False
+        assert "expirado" in msg.lower()
+        print(f"     OK: Rechazado - {msg}")
+
+        # Caso 4: Token valido
+        print("  4. Token valido...")
+        token_valido = await container.subscription.generate_vip_token(111111, 24)
+
+        is_valid, msg, _ = await container.subscription.validate_token(token_valido.token)
+        assert is_valid == True
+        assert "v√°lido" in msg.lower() or "valido" in msg.lower()
+        print(f"     OK: Aceptado - {msg}")
+
+    print("  [PASSED] Validacion de Tokens\n")
+
+
+@pytest.mark.asyncio
+async def test_duplicate_free_request_prevention(mock_bot):
+    """
+    Test E2E: Prevencion de solicitudes Free duplicadas.
+
+    Escenario:
+    1. Usuario crea primera solicitud Free
+    2. Usuario intenta crear segunda solicitud
+    3. Segunda solicitud debe fallar
+
+    Expected:
+    - Primera solicitud: creada exitosamente
+    - Segunda solicitud: retorna error "ya existe"
+    """
+    print("\n[TEST] Prevencion de Solicitudes Duplicadas")
+
+    user_id = 555555
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Paso 1: Crear primera solicitud
+        print("  1. Creando primera solicitud...")
+        request1 = await container.subscription.create_free_request(user_id)
+        assert request1 is not None
+        print(f"     OK: Primera solicitud creada")
+
+        # Paso 2: Intentar crear segunda (debe fallar)
+        print("  2. Intentando crear segunda solicitud...")
+        request2 = await container.subscription.create_free_request(user_id)
+        # Dependiendo de la implementacion, puede retornar existente o None
+        assert request2 is not None
+        assert request2.id == request1.id
+        print(f"     OK: Se retorna solicitud existente (no duplicada)")
+
+    print("  [PASSED] Prevencion de Duplicados\n")
diff --git a/tests/test_integration.py b/tests/test_integration.py
new file mode 100644
index 0000000..1556251
--- /dev/null
+++ b/tests/test_integration.py
@@ -0,0 +1,220 @@
+"""
+Integration Tests - Tests de integracion entre componentes.
+
+Validan que multiplos componentes trabajan juntos correctamente:
+- ServiceContainer lazy loading
+- BotConfig singleton
+- Session lifecycle
+"""
+import pytest
+
+from bot.database import get_session
+from bot.services.container import ServiceContainer
+
+
+@pytest.mark.asyncio
+async def test_service_container_lazy_loading(mock_bot):
+    """
+    Test: ServiceContainer carga services lazy (lazy loading).
+
+    Escenario:
+    1. Crear container vacio
+    2. Acceder a subscription (debe cargarlo)
+    3. Acceder nuevamente (debe reutilizar)
+    4. Verificar servicios cargados
+
+    Expected:
+    - Container comienza sin services cargados
+    - Primer acceso carga el service
+    - Acceso posterior reutiliza misma instancia
+    - get_loaded_services() muestra cual esta cargado
+    """
+    print("\n[TEST] Service Container Lazy Loading")
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Paso 1: Inicialmente vacio
+        print("  1. Verificando container vacio...")
+        loaded = container.get_loaded_services()
+        assert len(loaded) == 0
+        print("     OK: Container sin services cargados")
+
+        # Paso 2: Acceder a subscription
+        print("  2. Accediendo a subscription...")
+        subscription1 = container.subscription
+        loaded = container.get_loaded_services()
+        assert "subscription" in loaded
+        assert len(loaded) == 1
+        print("     OK: Subscription cargado lazy")
+
+        # Paso 3: Acceder nuevamente (debe reutilizar)
+        print("  3. Accediendo nuevamente...")
+        subscription2 = container.subscription
+        assert subscription1 is subscription2  # Misma instancia
+        loaded = container.get_loaded_services()
+        assert len(loaded) == 1  # No se carga otra vez
+        print("     OK: Reutiliza instancia existente")
+
+        # Paso 4: Acceder a otro service
+        print("  4. Accediendo a config...")
+        config = container.config
+        loaded = container.get_loaded_services()
+        assert len(loaded) == 2
+        assert "config" in loaded
+        print("     OK: Config cargado (ahora 2 services)")
+
+    print("  [PASSED] Service Container Lazy Loading\n")
+
+
+@pytest.mark.asyncio
+async def test_config_service_singleton(mock_bot):
+    """
+    Test: BotConfig es singleton.
+
+    Escenario:
+    1. Obtener config dos veces
+    2. Verificar que es el mismo registro (id=1)
+    3. Modificar wait_time
+    4. Obtener config nuevamente
+    5. Verificar cambio persiste
+
+    Expected:
+    - Ambos configs tienen id=1
+    - Modificacion persiste en BD
+    - Cambio visible en siguiente get_config()
+    """
+    print("\n[TEST] BotConfig Singleton")
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Paso 1: Obtener config dos veces
+        print("  1. Obteniendo config x2...")
+        config1 = await container.config.get_config()
+        config2 = await container.config.get_config()
+
+        assert config1.id == config2.id == 1
+        print("     OK: Ambos configs son id=1 (singleton)")
+
+        # Paso 2: Modificar wait_time
+        print("  2. Modificando wait_time...")
+        original_wait = config1.wait_time_minutes
+        await container.config.set_wait_time(15)
+        print(f"     OK: wait_time modificado")
+
+        # Paso 3: Obtener config nuevamente
+        print("  3. Verificando persistencia...")
+        config3 = await container.config.get_config()
+        assert config3.wait_time_minutes == 15
+        print("     OK: Cambio persistio en BD")
+
+        # Paso 4: Restaurar valor original
+        await container.config.set_wait_time(original_wait)
+        print("     OK: Valor restaurado")
+
+    print("  [PASSED] BotConfig Singleton\n")
+
+
+@pytest.mark.asyncio
+async def test_database_session_management(mock_bot):
+    """
+    Test: Manejo correcto de sesiones de BD.
+
+    Escenario:
+    1. Crear objeto en sesion1
+    2. Obtener sesion2 independiente
+    3. Verificar que ve los cambios de sesion1
+    4. Hacer cambio en sesion2
+    5. Verificar que sesion1 ve el cambio
+
+    Expected:
+    - Cambios persist en BD
+    - Multiples sesiones ven cambios reciprocos
+    - No hay conflictos de sesion
+    """
+    print("\n[TEST] Database Session Management")
+
+    async with get_session() as session1:
+        container1 = ServiceContainer(session1, mock_bot)
+
+        # Paso 1: Crear token en sesion1
+        print("  1. Creando token en sesion1...")
+        token1 = await container1.subscription.generate_vip_token(111111, 24)
+        token_str = token1.token
+        print(f"     OK: Token creado: {token_str}")
+
+        # Paso 2: Validar en sesion2 independiente
+        print("  2. Validando en sesion2...")
+        async with get_session() as session2:
+            container2 = ServiceContainer(session2, mock_bot)
+            is_valid, msg, token2 = await container2.subscription.validate_token(token_str)
+
+            assert is_valid == True
+            assert token2 is not None
+            print("     OK: Token visible en sesion2")
+
+        # Paso 3: Modificar en sesion1
+        print("  3. Modificando en sesion1...")
+        token1.used = True
+        token1.used_by = 999999
+        await session1.commit()
+        print("     OK: Token marcado como usado")
+
+        # Paso 4: Verificar en sesion3
+        print("  4. Verificando en sesion3...")
+        async with get_session() as session3:
+            container3 = ServiceContainer(session3, mock_bot)
+            is_valid, msg, token3 = await container3.subscription.validate_token(token_str)
+
+            assert is_valid == False
+            assert "usado" in msg.lower()
+            print("     OK: Cambio visible en sesion3")
+
+    print("  [PASSED] Database Session Management\n")
+
+
+@pytest.mark.asyncio
+async def test_error_handling_across_services(mock_bot):
+    """
+    Test: Manejo de errores entre services.
+
+    Escenario:
+    1. Intentar canjear token invalido
+    2. Intentar crear solicitud para usuario invalido
+    3. Intentar acceder a config vacia
+
+    Expected:
+    - No crashes en servicios
+    - Mensajes de error claros
+    - Estados consistentes en BD
+    """
+    print("\n[TEST] Error Handling Across Services")
+
+    async with get_session() as session:
+        container = ServiceContainer(session, mock_bot)
+
+        # Caso 1: Token invalido
+        print("  1. Intentando canjear token invalido...")
+        success, msg, _ = await container.subscription.redeem_vip_token(
+            token_str="INVALID123456789",
+            user_id=111111
+        )
+        assert success == False
+        assert msg is not None
+        print(f"     OK: Error manejado - {msg}")
+
+        # Caso 2: Validar token que no existe
+        print("  2. Validando token inexistente...")
+        is_valid, msg, _ = await container.subscription.validate_token("NOEXISTS12345678")
+        assert is_valid == False
+        assert "no encontrado" in msg.lower()
+        print(f"     OK: Validacion falld correctamente")
+
+        # Caso 3: Crear solicitud (debe funcionar)
+        print("  3. Creando solicitud Free...")
+        request = await container.subscription.create_free_request(111111)
+        assert request is not None
+        print(f"     OK: Solicitud creada sin errores")
+
+    print("  [PASSED] Error Handling Across Services\n")
