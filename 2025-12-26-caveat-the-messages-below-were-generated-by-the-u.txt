
 * â–â–›â–ˆâ–ˆâ–ˆâ–œâ–Œ *   Claude Code v2.0.76
* â–â–œâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–›â–˜ *  Opus 4.5 Â· Claude Pro
 *  â–˜â–˜ â–â–  *   ~/repos/c1

  A gift for you
  Your rate limits are 2x higher through 12/31. Enjoy the extra room to think!

> /model 
  â¿  Set model to opus (claude-opus-4-5-20251101)

> Quiero que te pongas en modo arquitecto de software especializado en bots 
de Telegram con un enfoque muy pragmÃ¡tico para esta adiciÃ³n que tenemos que 
implementar en este sistema. Actualmente el bot cuenta con dos mÃ³dulos, que 
es el de administraciÃ³n de canales y gamificaciÃ³n. Esos mÃ³dulos estÃ¡n a un 
80% de su desarrollo, tal vez. Si necesitan un poco mÃ¡s. y estÃ¡ todo el 
terreno listo para integrar un nuevo modelo, un nuevo mÃ³dulo que es 
narrativa. El fin y funcionamiento de este mÃ³dulo es crear una experiencia 
narrativa para el usuario dentro del bot. en donde se van a integrar los 
otros dos mÃ³dulos, gamificaciÃ³n, por ejemplo, para otorgar recompensas, 
besitos, que le servirÃ¡n al usuario para avanzar dentro de la historia de la
 narrativa y administraciÃ³n de canales para comprobar el estatus del usuario
 para que pueda acceder a ciertas funciones, siendo VIP, por ejemplo. Esta 
narrativa va a estar basada en la historia que estÃ¡ en el archivo 
@docs/narrativa/narrativo.md Esa es la historia base, pero dentro de la 
narrativa serÃ¡ ramificada. SerÃ¡ un sistema de fragmentos con decisiones, en 
donde cada decisiÃ³n afecta el recorrido de la historia y del usuario. La 
idea es que hay un reconocimiento de arquetipos, pero por ahora quiero que 
sea lo mÃ¡s simple posible, que estÃ© implementado el sistema como tal para 
irle agregando mejoras, pero ya una vez entrada la base firme y funcional 
del mÃ³dulo de narrativa integrado con los otros mÃ³dulos. Revisa todo el 
sistema, documentaciÃ³n, todo lo que sea necesario. Piensa muy bien cÃ³mo 
implementarlo y dame tu propuesta. 
  â¿ Â Read docs/narrativa/narrativo.md (583 lines)

â— Perfecto, voy a analizar el sistema actual en profundidad antes de darte una propuesta arquitectÃ³nica sÃ³lida. DÃ©jame revisar la estructura existente.

â— Explore(Explorar arquitectura actual del bot)
  â¿ Â Done (40 tool uses Â· 84.0k tokens Â· 5m 47s)                           

â— Read(docs/Referencia_RÃ¡pida.md)
  â¿ Â Read 411 lines

â— Read(docs/gamification/SETUP.md)
  â¿ Â Read 222 lines

â— Read(bot/handlers/user/start.py)
  â¿ Â Read 433 lines

â— Read(bot/handlers/user/dynamic_menu.py)
  â¿ Â Read 191 lines

â— Read(bot/middlewares/database.py)
  â¿ Â Read 88 lines

â— Search(pattern: "bot/gamification/**/*.py")
  â¿ Â Error: spawn /data/data/com.termux/files/usr/lib/node_modules/@anthropic-ai/
     claude-code/vendor/ripgrep/arm64-android/rg ENOENT

â— Read(bot/gamification/services/container.py)
  â¿ Â Read 240 lines

â— Bash(ls -la /data/data/com.termux/files/home/repos/c1/bot/gamification/)
  â¿ Â total 44                                           
     drwx------.  9 u0_a347 u0_a347 3440 Dec 24 18:50 .
     drwx------. 13 u0_a347 u0_a347 3440 Dec 24 18:50 ..
     â€¦ +11 lines (ctrl+o to expand)

â— Bash(ls -la
      /data/data/com.termux/files/home/repos/c1/bot/gamification/database/)
  â¿ Â total 47                                           
     drwx------. 3 u0_a347 u0_a347  3440 Dec 26 16:42 .
     drwx------. 9 u0_a347 u0_a347  3440 Dec 24 18:50 ..
     â€¦ +4 lines (ctrl+o to expand)

â— Excelente. Tras analizar exhaustivamente el sistema, tengo una visiÃ³n clara de la arquitectura existente y cÃ³mo debe integrarse el mÃ³dulo de narrativa. AquÃ­ estÃ¡ mi propuesta:

  ---
  ğŸ­ PROPUESTA ARQUITECTÃ“NICA: MÃ“DULO NARRATIVA

  1. ANÃLISIS DEL CONTEXTO

  Lo que ya existe y funciona:

  | MÃ³dulo          | Estado | Puntos de IntegraciÃ³n                                  |
  |-----------------|--------|--------------------------------------------------------|
  | Canales         | ~80%   | VIP check para acceso a "El DivÃ¡n", roles (FREE/VIP)   |
  | GamificaciÃ³n    | ~80%   | Besitos como moneda, recompensas, misiones vinculables |
  | MenÃºs DinÃ¡micos | âœ…     | Entry point desde /start                               |

  Patrones arquitectÃ³nicos que seguiremos:

  1. DI Container (NarrativeContainer) - Lazy loading
  2. Middleware pipeline (ya inyecta session + gamification)
  3. FSM para flujos multi-paso
  4. Modelos SQLAlchemy 2.0 async
  5. SeparaciÃ³n handlers admin/user

  ---
  2. MODELO CONCEPTUAL DE LA NARRATIVA

  Basado en el archivo narrativo.md, la estructura narrativa tiene:

  NARRATIVA (Grafo Dirigido)
      â”‚
      â”œâ”€â”€ CAPÃTULO (ej: "Los Kinkys", "El DivÃ¡n")
      â”‚       â”‚
      â”‚       â””â”€â”€ FRAGMENTO (unidad mÃ­nima de historia)
      â”‚               â”‚
      â”‚               â”œâ”€â”€ Contenido (texto Diana/Lucien)
      â”‚               â”œâ”€â”€ Visual (imagen opcional)
      â”‚               â”œâ”€â”€ DECISIONES[] (botones del usuario)
      â”‚               â”‚       â”‚
      â”‚               â”‚       â””â”€â”€ DecisiÃ³n â†’ siguiente FRAGMENTO
      â”‚               â”‚
      â”‚               â””â”€â”€ CONDICIONES (acceso VIP, besitos mÃ­nimos, arquetipo)
      â”‚
      â””â”€â”€ PROGRESO USUARIO
              â”œâ”€â”€ Fragmento actual
              â”œâ”€â”€ Historial de decisiones
              â””â”€â”€ Arquetipo detectado

  ---
  3. ESTRUCTURA DE DIRECTORIO PROPUESTA

  Siguiendo el patrÃ³n de bot/gamification/:

  bot/narrative/
  â”œâ”€â”€ __init__.py
  â”œâ”€â”€ config.py                    # ConfiguraciÃ³n del mÃ³dulo
  â”‚
  â”œâ”€â”€ database/
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”œâ”€â”€ enums.py                 # NarrativeStatus, ArchetypeType, RequirementType
  â”‚   â””â”€â”€ models.py                # 6 modelos (ver detalle abajo)
  â”‚
  â”œâ”€â”€ services/
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”œâ”€â”€ container.py             # NarrativeContainer (DI + lazy loading)
  â”‚   â”œâ”€â”€ fragment.py              # FragmentService (CRUD fragmentos)
  â”‚   â”œâ”€â”€ progress.py              # ProgressService (avance usuario)
  â”‚   â”œâ”€â”€ decision.py              # DecisionService (procesar elecciones)
  â”‚   â”œâ”€â”€ archetype.py             # ArchetypeService (detecciÃ³n simple)
  â”‚   â””â”€â”€ requirements.py          # RequirementService (validar condiciones)
  â”‚
  â”œâ”€â”€ handlers/
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”œâ”€â”€ admin/
  â”‚   â”‚   â”œâ”€â”€ __init__.py
  â”‚   â”‚   â”œâ”€â”€ main.py              # MenÃº admin narrativa
  â”‚   â”‚   â”œâ”€â”€ fragment_wizard.py   # Wizard crear fragmentos
  â”‚   â”‚   â”œâ”€â”€ chapter_config.py    # Configurar capÃ­tulos
  â”‚   â”‚   â””â”€â”€ stats.py             # EstadÃ­sticas narrativa
  â”‚   â”‚
  â”‚   â””â”€â”€ user/
  â”‚       â”œâ”€â”€ __init__.py
  â”‚       â”œâ”€â”€ story.py             # Handler principal historia
  â”‚       â””â”€â”€ decisions.py         # Procesar decisiones
  â”‚
  â”œâ”€â”€ states/
  â”‚   â”œâ”€â”€ __init__.py
  â”‚   â””â”€â”€ admin.py                 # FSM para wizards
  â”‚
  â””â”€â”€ utils/
      â”œâ”€â”€ __init__.py
      â”œâ”€â”€ formatters.py            # Formato mensajes Diana/Lucien
      â””â”€â”€ validators.py            # Validar estructuras

  ---
  4. MODELOS DE BASE DE DATOS

  Diagrama de Relaciones:

                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ NarrativeChapterâ”‚
                      â”‚ (Los Kinkys,    â”‚
                      â”‚  El DivÃ¡n)      â”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚ 1:N
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ NarrativeFragmentâ”‚â—„â”€â”€â”€â”€â”€â”
                      â”‚ (Escena 1,       â”‚      â”‚ self-reference
                      â”‚  Escena 2A...)   â”‚â”€â”€â”€â”€â”€â”€â”˜ (ramificaciones)
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                               â”‚ 1:N
                â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚              â”‚              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ FragmentDecisionâ”‚ â”‚Fragment   â”‚ â”‚ FragmentRequirementâ”‚
       â”‚ (Botones)       â”‚ â”‚Requirementâ”‚ â”‚ (VIP, besitos...)  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ N:1 (usuario elige)
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ UserNarrative   â”‚
       â”‚ Progress        â”‚
       â”‚ (progreso)      â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚ 1:N
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ UserDecision    â”‚
       â”‚ History         â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  Modelos (CÃ³digo):

  # bot/narrative/database/enums.py

  class ChapterType(str, Enum):
      """Tipo de capÃ­tulo narrativo."""
      FREE = "free"           # Los Kinkys
      VIP = "vip"             # El DivÃ¡n

  class RequirementType(str, Enum):
      """Tipo de requisito para acceder a fragmento."""
      NONE = "none"           # Sin requisitos
      VIP_STATUS = "vip"      # Debe ser VIP
      MIN_BESITOS = "besitos" # Besitos mÃ­nimos
      ARCHETYPE = "archetype" # Arquetipo especÃ­fico
      DECISION = "decision"   # DecisiÃ³n previa tomada

  class ArchetypeType(str, Enum):
      """Arquetipos de usuario (simple inicialmente)."""
      UNKNOWN = "unknown"
      IMPULSIVE = "impulsive"     # Reacciona rÃ¡pido
      CONTEMPLATIVE = "contemplative" # Toma su tiempo
      SILENT = "silent"           # No reacciona

  # bot/narrative/database/models.py

  class NarrativeChapter(Base):
      """CapÃ­tulo narrativo (contenedor de fragmentos)."""
      __tablename__ = "narrative_chapters"

      id: Mapped[int] = mapped_column(primary_key=True)
      name: Mapped[str] = mapped_column(String(100))  # "Los Kinkys"
      slug: Mapped[str] = mapped_column(String(50), unique=True)  # "los-kinkys"
      chapter_type: Mapped[ChapterType] = mapped_column(default=ChapterType.FREE)
      order: Mapped[int] = mapped_column(default=0)
      is_active: Mapped[bool] = mapped_column(default=True)
      description: Mapped[Optional[str]] = mapped_column(Text)

      # Relationships
      fragments: Mapped[List["NarrativeFragment"]] = relationship(back_populates="chapter")


  class NarrativeFragment(Base):
      """Fragmento narrativo (unidad mÃ­nima de historia)."""
      __tablename__ = "narrative_fragments"

      id: Mapped[int] = mapped_column(primary_key=True)
      chapter_id: Mapped[int] = mapped_column(ForeignKey("narrative_chapters.id"))

      # IdentificaciÃ³n
      fragment_key: Mapped[str] = mapped_column(String(50), unique=True)  # "scene_1", "scene_2a"
      title: Mapped[str] = mapped_column(String(200))  # "Bienvenida de Diana"

      # Contenido
      speaker: Mapped[str] = mapped_column(String(50))  # "diana", "lucien", "narrator"
      content: Mapped[str] = mapped_column(Text)  # Texto narrativo con formato
      visual_hint: Mapped[Optional[str]] = mapped_column(String(500))  # DescripciÃ³n imagen
      media_file_id: Mapped[Optional[str]] = mapped_column(String(100))  # Telegram file_id

      # NavegaciÃ³n
      order: Mapped[int] = mapped_column(default=0)
      is_entry_point: Mapped[bool] = mapped_column(default=False)  # Inicio de capÃ­tulo
      is_ending: Mapped[bool] = mapped_column(default=False)  # Fin de capÃ­tulo

      # Estado
      is_active: Mapped[bool] = mapped_column(default=True)

      # Metadata
      created_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)

      # Relationships
      chapter: Mapped["NarrativeChapter"] = relationship(back_populates="fragments")
      decisions: Mapped[List["FragmentDecision"]] = relationship(back_populates="fragment")
      requirements: Mapped[List["FragmentRequirement"]] = relationship(back_populates="fragment")


  class FragmentDecision(Base):
      """DecisiÃ³n/botÃ³n dentro de un fragmento."""
      __tablename__ = "fragment_decisions"

      id: Mapped[int] = mapped_column(primary_key=True)
      fragment_id: Mapped[int] = mapped_column(ForeignKey("narrative_fragments.id"))

      # BotÃ³n
      button_text: Mapped[str] = mapped_column(String(100))  # "ğŸšª Descubrir mÃ¡s"
      button_emoji: Mapped[Optional[str]] = mapped_column(String(10))
      order: Mapped[int] = mapped_column(default=0)

      # Destino
      target_fragment_key: Mapped[str] = mapped_column(String(50))  # "scene_2"

      # Costo opcional (en besitos)
      besitos_cost: Mapped[int] = mapped_column(default=0)

      # Efectos
      grants_besitos: Mapped[int] = mapped_column(default=0)
      affects_archetype: Mapped[Optional[str]] = mapped_column(String(50))  # "impulsive"

      # Estado
      is_active: Mapped[bool] = mapped_column(default=True)

      # Relationship
      fragment: Mapped["NarrativeFragment"] = relationship(back_populates="decisions")


  class FragmentRequirement(Base):
      """Requisito para acceder a un fragmento."""
      __tablename__ = "fragment_requirements"

      id: Mapped[int] = mapped_column(primary_key=True)
      fragment_id: Mapped[int] = mapped_column(ForeignKey("narrative_fragments.id"))

      requirement_type: Mapped[RequirementType] = mapped_column()
      value: Mapped[str] = mapped_column(String(100))  # "100" para besitos, "impulsive" para arquetipo

      # Mensaje si no cumple
      rejection_message: Mapped[Optional[str]] = mapped_column(Text)

      # Relationship
      fragment: Mapped["NarrativeFragment"] = relationship(back_populates="requirements")


  class UserNarrativeProgress(Base):
      """Progreso del usuario en la narrativa."""
      __tablename__ = "user_narrative_progress"

      id: Mapped[int] = mapped_column(primary_key=True)
      user_id: Mapped[int] = mapped_column(BigInteger, index=True)

      # PosiciÃ³n actual
      current_chapter_id: Mapped[Optional[int]] = mapped_column(ForeignKey("narrative_chapters.id"))
      current_fragment_key: Mapped[Optional[str]] = mapped_column(String(50))

      # Arquetipo detectado
      detected_archetype: Mapped[ArchetypeType] = mapped_column(default=ArchetypeType.UNKNOWN)
      archetype_confidence: Mapped[float] = mapped_column(default=0.0)  # 0.0 - 1.0

      # EstadÃ­sticas
      total_decisions: Mapped[int] = mapped_column(default=0)
      chapters_completed: Mapped[int] = mapped_column(default=0)

      # Timestamps
      started_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)
      last_interaction: Mapped[datetime] = mapped_column(default=datetime.utcnow)

      # Ãndice Ãºnico por usuario
      __table_args__ = (
          Index('idx_user_narrative', 'user_id', unique=True),
      )


  class UserDecisionHistory(Base):
      """Historial de decisiones del usuario."""
      __tablename__ = "user_decision_history"

      id: Mapped[int] = mapped_column(primary_key=True)
      user_id: Mapped[int] = mapped_column(BigInteger, index=True)

      # QuÃ© decidiÃ³
      fragment_key: Mapped[str] = mapped_column(String(50))
      decision_id: Mapped[int] = mapped_column(ForeignKey("fragment_decisions.id"))

      # CuÃ¡ndo
      decided_at: Mapped[datetime] = mapped_column(default=datetime.utcnow)

      # Tiempo de respuesta (para arquetipo)
      response_time_seconds: Mapped[Optional[int]] = mapped_column()

      # Ãndice
      __table_args__ = (
          Index('idx_user_decisions', 'user_id', 'fragment_key'),
      )

  ---
  5. CONTAINER DE SERVICIOS

  # bot/narrative/services/container.py

  class NarrativeContainer:
      """Contenedor de servicios de narrativa con lazy loading."""

      def __init__(self, session: AsyncSession, bot: Optional["Bot"] = None):
          self._session = session
          self._bot = bot

          # Servicios (lazy loaded)
          self._fragment_service = None
          self._progress_service = None
          self._decision_service = None
          self._archetype_service = None
          self._requirements_service = None

      @property
      def fragment(self) -> "FragmentService":
          """Servicio de fragmentos narrativos."""
          if self._fragment_service is None:
              from bot.narrative.services.fragment import FragmentService
              self._fragment_service = FragmentService(self._session)
          return self._fragment_service

      @property
      def progress(self) -> "ProgressService":
          """Servicio de progreso del usuario."""
          if self._progress_service is None:
              from bot.narrative.services.progress import ProgressService
              self._progress_service = ProgressService(self._session)
          return self._progress_service

      @property
      def decision(self) -> "DecisionService":
          """Servicio de procesamiento de decisiones."""
          if self._decision_service is None:
              from bot.narrative.services.decision import DecisionService
              self._decision_service = DecisionService(self._session)
          return self._decision_service

      @property
      def archetype(self) -> "ArchetypeService":
          """Servicio de detecciÃ³n de arquetipos."""
          if self._archetype_service is None:
              from bot.narrative.services.archetype import ArchetypeService
              self._archetype_service = ArchetypeService(self._session)
          return self._archetype_service

      @property
      def requirements(self) -> "RequirementsService":
          """Servicio de validaciÃ³n de requisitos."""
          if self._requirements_service is None:
              from bot.narrative.services.requirements import RequirementsService
              # Este servicio necesita acceso a otros mÃ³dulos
              self._requirements_service = RequirementsService(
                  self._session,
                  gamification_getter=lambda: get_gamification_container(),
                  subscription_getter=lambda: ServiceContainer(self._session, self._bot).subscription
              )
          return self._requirements_service

  ---
  6. SERVICIOS CLAVE

  6.1 FragmentService

  class FragmentService:
      """GestiÃ³n de fragmentos narrativos."""

      async def get_entry_point(self, chapter_id: int) -> Optional[NarrativeFragment]:
          """Obtiene fragmento de inicio de capÃ­tulo."""

      async def get_fragment(self, fragment_key: str) -> Optional[NarrativeFragment]:
          """Obtiene fragmento por key."""

      async def get_next_fragments(self, fragment_key: str) -> List[NarrativeFragment]:
          """Obtiene posibles siguientes fragmentos (vÃ­a decisiones)."""

      async def create_fragment(self, chapter_id: int, **kwargs) -> NarrativeFragment:
          """Crea nuevo fragmento."""

      async def format_fragment_message(self, fragment: NarrativeFragment) -> str:
          """Formatea fragmento para envÃ­o a Telegram."""

  6.2 ProgressService

  class ProgressService:
      """GestiÃ³n del progreso del usuario."""

      async def get_or_create_progress(self, user_id: int) -> UserNarrativeProgress:
          """Obtiene o crea progreso del usuario."""

      async def advance_to(self, user_id: int, fragment_key: str) -> UserNarrativeProgress:
          """Avanza usuario a fragmento especÃ­fico."""

      async def get_current_fragment(self, user_id: int) -> Optional[NarrativeFragment]:
          """Obtiene fragmento actual del usuario."""

      async def can_access_chapter(self, user_id: int, chapter_id: int) -> Tuple[bool, str]:
          """Verifica si usuario puede acceder a capÃ­tulo."""

  6.3 DecisionService

  class DecisionService:
      """Procesamiento de decisiones del usuario."""

      async def get_available_decisions(
          self, 
          user_id: int, 
          fragment_key: str
      ) -> List[FragmentDecision]:
          """Obtiene decisiones disponibles (filtra por requisitos/besitos)."""

      async def process_decision(
          self, 
          user_id: int, 
          decision_id: int,
          response_time: Optional[int] = None
      ) -> Tuple[bool, str, Optional[NarrativeFragment]]:
          """
          Procesa decisiÃ³n del usuario.
          
          Returns:
              (success, message, next_fragment)
          """

      async def record_decision(self, user_id: int, decision: FragmentDecision) -> None:
          """Registra decisiÃ³n en historial."""

  6.4 RequirementsService (IntegraciÃ³n con otros mÃ³dulos)

  class RequirementsService:
      """ValidaciÃ³n de requisitos - PUNTO DE INTEGRACIÃ“N."""

      def __init__(
          self, 
          session: AsyncSession,
          gamification_getter: Callable,  # Lambda para obtener GamificationContainer
          subscription_getter: Callable    # Lambda para obtener SubscriptionService
      ):
          self._session = session
          self._get_gamification = gamification_getter
          self._get_subscription = subscription_getter

      async def check_requirements(
          self, 
          user_id: int, 
          fragment: NarrativeFragment
      ) -> Tuple[bool, Optional[str]]:
          """
          Verifica si usuario cumple requisitos del fragmento.
          
          INTEGRACIÃ“N:
          - VIP_STATUS: usa SubscriptionService.is_vip_active()
          - MIN_BESITOS: usa GamificationContainer.user_gamification.get_balance()
          - ARCHETYPE: verifica UserNarrativeProgress.detected_archetype
          - DECISION: verifica UserDecisionHistory
          
          Returns:
              (can_access, rejection_message_if_not)
          """
          for req in fragment.requirements:
              if req.requirement_type == RequirementType.VIP_STATUS:
                  subscription = self._get_subscription()
                  is_vip = await subscription.is_vip_active(user_id)
                  if not is_vip:
                      return False, req.rejection_message or "Necesitas ser VIP para continuar."

              elif req.requirement_type == RequirementType.MIN_BESITOS:
                  gamification = self._get_gamification()
                  balance = await gamification.user_gamification.get_balance(user_id)
                  required = int(req.value)
                  if balance < required:
                      return False, req.rejection_message or f"Necesitas {required} besitos."

              # ... otros tipos

          return True, None

  ---
  7. FLUJO DE USUARIO

  Usuario: Click "ğŸ“– Historia" (desde /start)
                â”‚
                â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ story.py            â”‚
       â”‚ callback_start_storyâ”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ ProgressService.get_or_create   â”‚
       â”‚ Â¿Tiene progreso previo?         â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ SÃ            â”‚ NO
         â–¼               â–¼
    Continuar donde   FragmentService.get_entry_point("los-kinkys")
    quedÃ³              â”‚
         â”‚             â”‚
         â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ RequirementsService.check       â”‚
       â”‚ Â¿Puede acceder?                 â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”
         â”‚ SÃ            â”‚ NO
         â–¼               â–¼
    Mostrar fragmento   Mostrar mensaje rechazo
    + botones decisiÃ³n  (ej: "Necesitas ser VIP")
         â”‚
         â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ Usuario presiona botÃ³n          â”‚
       â”‚ callback: narr:decision:{id}    â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚ DecisionService.process_decisionâ”‚
       â”‚ - Valida requisitos             â”‚
       â”‚ - Cobra besitos si aplica       â”‚
       â”‚ - Otorga besitos si aplica      â”‚
       â”‚ - Actualiza arquetipo           â”‚
       â”‚ - Avanza a siguiente fragmento  â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                 â”‚
                 â–¼
            Mostrar siguiente fragmento
            (loop recursivo)

  ---
  8. INTEGRACIÃ“N CON MIDDLEWARE

  El DatabaseMiddleware actual ya inyecta session y gamification. Solo necesitamos agregar narrative:

  # bot/middlewares/database.py (modificaciÃ³n mÃ­nima)

  class DatabaseMiddleware(BaseMiddleware):
      async def __call__(self, handler, event, data):
          async with get_session() as session:
              data["session"] = session
              bot = data.get("bot")

              # GamificaciÃ³n (existente)
              gamif_container = GamificationContainer(session, bot)
              set_container(gamif_container)
              data["gamification"] = gamif_container

              # NUEVO: Narrativa
              from bot.narrative.services.container import NarrativeContainer
              narrative_container = NarrativeContainer(session, bot)
              data["narrative"] = narrative_container

              return await handler(event, data)

  ---
  9. INTEGRACIÃ“N CON MENÃš /start

  Agregar botÃ³n de narrativa al menÃº dinÃ¡mico:

  # En _send_welcome_message o configuraciÃ³n de MenuItems

  # BotÃ³n para iniciar/continuar historia
  {
      "button_text": "ğŸ“– Historia",
      "callback_data": "narr:start",
      "target_role": "free",  # Disponible para todos
      "order": 2
  }

  ---
  10. FASES DE IMPLEMENTACIÃ“N

  FASE N1: Modelos y MigraciÃ³n (FundaciÃ³n)

  - Crear estructura bot/narrative/
  - Modelos de BD (6 modelos)
  - MigraciÃ³n Alembic
  - NarrativeContainer base
  - Tests modelos

  Entregable: BD lista, container funcional

  ---
  FASE N2: Servicios Core

  - FragmentService (CRUD fragmentos)
  - ProgressService (avance usuario)
  - DecisionService (procesar decisiones)
  - Tests unitarios servicios

  Entregable: Servicios funcionando sin UI

  ---
  FASE N3: IntegraciÃ³n con MÃ³dulos Existentes

  - RequirementsService (VIP check, besitos)
  - Modificar middleware para inyectar narrative
  - Tests integraciÃ³n

  Entregable: Narrativa puede verificar VIP y cobrar/otorgar besitos

  ---
  FASE N4: Handlers Usuario

  - user/story.py - Mostrar fragmento actual
  - user/decisions.py - Procesar decisiones
  - BotÃ³n "ğŸ“– Historia" en /start
  - FSM si es necesario

  Entregable: Usuario puede navegar historia

  ---
  FASE N5: Admin + Contenido

  - Wizard crear fragmentos
  - Seed data (narrativa de narrativo.md)
  - EstadÃ­sticas bÃ¡sicas

  Entregable: Admin puede crear contenido, historia base cargada

  ---
  FASE N6: Arquetipos (Simple)

  - ArchetypeService bÃ¡sico
  - DetecciÃ³n por tiempo de respuesta
  - Ramificaciones por arquetipo

  Entregable: Sistema detecta arquetipos y adapta caminos

  ---
  11. PUNTOS CLAVE DE DISEÃ‘O

  Pragmatismo:

  1. 6 modelos solamente - Lo mÃ­nimo necesario
  2. Sin IA/NLP - Arquetipos por reglas simples (tiempo respuesta)
  3. Lazy loading - Memoria optimizada para Termux
  4. Reutiliza patrones - Container, middleware, FSM existentes

  Extensibilidad futura:

  1. Arquetipos mÃ¡s complejos (ML)
  2. Contenido multimedia (audios Diana)
  3. Eventos temporales (historias de temporada)
  4. MÃºltiples narradores

  Integraciones:

  | MÃ³dulo        | CÃ³mo se integra                                         |
  |---------------|---------------------------------------------------------|
  | GamificaciÃ³n  | Besitos como moneda, recompensas al completar capÃ­tulos |
  | Canales       | VIP check para "El DivÃ¡n"                               |
  | MenÃº dinÃ¡mico | Entry point desde /start                                |

  ---
  12. PREGUNTAS PARA TI

  Antes de comenzar la implementaciÃ³n:

  1. Â¿El usuario puede "reiniciar" la historia? (Volver a empezar con otro camino)
  2. Â¿Quieres notificaciones cuando hay nuevo contenido narrativo? (Usar NotificationService existente)
  3. Â¿El arquetipo deberÃ­a afectar otras partes del bot? (ej: mensajes de gamificaciÃ³n personalizados segÃºn arquetipo)
  4. Â¿Empezamos por FASE N1 directamente o quieres que refine algo de esta propuesta?

  ---
  Esta propuesta es pragmÃ¡tica y modular: puedes tener una versiÃ³n funcional bÃ¡sica en las primeras 3-4 fases, y el resto son mejoras incrementales. Â¿Procedemos?

> /export 
  â¿  Conversation exported to: 2025-12-26-caveat-the-messages-below-were-generated-by-the-u.txt

> Gran propuesta, excelente. Me gusta demasiado. Antes de proceder, se me 
fue por completo mencionarte tambiÃ©n algo muy importante. Hay un, para la 
gamificaciÃ³n, hay un sistema de configuraciÃ³n que se encarga de propagar la 
configuraciÃ³n de lo que se cree, ya sean recompensas, misiones. Esto se hizo
 con el objetivo de que desde un solo flujo se pudieran configurar 
condiciones, por ejemplo, si una recompensa necesita un nivel, desde la 
configuraciÃ³n de la recompensa se puede crear el nivel, no es necesario ir 
al nivel para actualizarla, para crearla y luego regresar a seguir haciendo 
la recompensa. Esto te digo que fue porque justo se estaba fragmentando 
mucho la configuraciÃ³n, cada sistema tenÃ­a su propia configuraciÃ³n por 
separado y logramos esa integraciÃ³n. este mÃ³dulo tambiÃ©n debe de poder 
integrarse ahÃ­ mismo. Es decir, que se pueda recoger, por ejemplo, un nivel 
de la narrativa para poder entregar una recompensa. Seguramente ya lo 
revisaste, pero si le puedes dar otra checada para ver si es necesario 
adaptar algo o ya lo habÃ­as tomado en cuenta. 

â— Entendido, necesito revisar ese sistema de configuraciÃ³n unificado. DÃ©jame explorarlo para asegurarme de que la narrativa se integre correctamente.

â— Read(bot/gamification/services/orchestrator/configuration.py)
  â¿ Â Read 339 lines

â— Read(bot/gamification/services/orchestrator/reward.py)
  â¿ Â Read 331 lines

â— Read(bot/gamification/services/orchestrator/mission.py)
  â¿ Â Read 320 lines

â— Ahora entiendo perfectamente el sistema de orquestadores. Es un patrÃ³n muy elegante para configuraciÃ³n en cascada. DÃ©jame actualizar la propuesta para integrarlo correctamente:

  ---
  ğŸ”„ ACTUALIZACIÃ“N: INTEGRACIÃ“N CON SISTEMA DE ORQUESTADORES

  1. EL PATRÃ“N ACTUAL

  ConfigurationOrchestrator (maestro)
      â”œâ”€â”€ MissionOrchestrator
      â”‚   â””â”€â”€ Crea: MisiÃ³n â†’ Nivel â†’ Recompensas (atÃ³mico)
      â””â”€â”€ RewardOrchestrator
          â””â”€â”€ Crea: Recompensa â†’ UnlockConditions (mission/level/besitos)

  El flujo actual permite:
  Admin: Crear recompensa "Badge Leyenda"
      â†’ "Â¿Quieres crear un nivel requerido?"
      â†’ SÃ­, crear nivel "FanÃ¡tico"
      â†’ "Â¿Vincular a alguna misiÃ³n?"
      â†’ SÃ­, crear misiÃ³n "Completa 30 dÃ­as"
      â†’ TODO SE CREA EN UNA TRANSACCIÃ“N

  ---
  2. CÃ“MO SE INTEGRA NARRATIVA

  2.1 Nuevos tipos de unlock conditions

  # bot/gamification/utils/validators.py (EXTENDER)

  # Agregar nuevos tipos vÃ¡lidos:
  VALID_UNLOCK_TYPES = [
      "mission",
      "level",
      "besitos",
      "multiple",
      # NUEVOS:
      "narrative_chapter",   # Completar capÃ­tulo
      "narrative_fragment",  # Llegar a fragmento especÃ­fico
      "archetype"            # Tener arquetipo especÃ­fico
  ]

  2.2 ExtensiÃ³n del ConfigurationOrchestrator

  # bot/gamification/services/orchestrator/configuration.py (EXTENDER)

  class ConfigurationOrchestrator:
      def __init__(self, session: AsyncSession):
          self.session = session
          self.mission_orchestrator = MissionOrchestrator(session)
          self.reward_orchestrator = RewardOrchestrator(session)
          # NUEVO:
          self._narrative_orchestrator = None

      @property
      def narrative(self):
          """Orquestador de narrativa (lazy loaded)."""
          if self._narrative_orchestrator is None:
              from bot.narrative.services.orchestrator import NarrativeOrchestrator
              self._narrative_orchestrator = NarrativeOrchestrator(self.session)
          return self._narrative_orchestrator

      async def create_complete_narrative_chapter(
          self,
          chapter_config: dict,
          completion_rewards: Optional[List[dict]] = None,
          unlock_level_on_complete: Optional[dict] = None,
          created_by: int = 0
      ) -> dict:
          """
          Crea capÃ­tulo narrativo con recompensas asociadas.
          
          Flujo:
          1. Crea el capÃ­tulo
          2. Crea fragmentos
          3. Si hay completion_rewards â†’ crea recompensas con unlock_condition="narrative_chapter"
          4. Si hay unlock_level_on_complete â†’ crea nivel desbloqueado al completar
          """
          ...

  2.3 NarrativeOrchestrator (NUEVO)

  # bot/narrative/services/orchestrator.py

  class NarrativeOrchestrator:
      """
      Orquestador de narrativa integrado con gamificaciÃ³n.
      
      Permite crear fragmentos con:
      - Recompensas por llegar al fragmento
      - Misiones vinculadas al fragmento
      - Niveles desbloqueables
      """

      def __init__(self, session: AsyncSession):
          self.session = session
          self._fragment_service = None
          self._reward_orchestrator = None
          self._mission_orchestrator = None

      @property
      def reward_orchestrator(self):
          """Lazy load del RewardOrchestrator de gamificaciÃ³n."""
          if self._reward_orchestrator is None:
              from bot.gamification.services.orchestrator.reward import RewardOrchestrator
              self._reward_orchestrator = RewardOrchestrator(self.session)
          return self._reward_orchestrator

      async def create_fragment_with_rewards(
          self,
          fragment_data: dict,
          arrival_rewards: Optional[List[dict]] = None,
          decision_rewards: Optional[Dict[str, List[dict]]] = None,
          created_by: int = 0
      ) -> dict:
          """
          Crea fragmento narrativo con recompensas.
          
          Args:
              fragment_data: Datos del fragmento
              arrival_rewards: Recompensas por llegar al fragmento
              decision_rewards: {decision_key: [rewards]} - Recompensas por cada decisiÃ³n
              created_by: Admin ID
          
          Returns:
              {
                  'fragment': NarrativeFragment,
                  'created_rewards': List[Reward],
                  'decision_reward_map': Dict[str, List[Reward]]
              }
          
          Ejemplo de uso desde wizard:
              Admin crea fragmento "Escena 3A - Respuesta Impulsiva"
              â†’ "Â¿Otorgar recompensa al llegar?"
              â†’ SÃ­, "Badge Impulsivo" (BADGE, rarity=RARE)
              â†’ TODO se crea junto
          """
          from bot.narrative.services.fragment import FragmentService
          fragment_service = FragmentService(self.session)

          # 1. Crear fragmento
          fragment = await fragment_service.create_fragment(**fragment_data)

          created_rewards = []
          decision_reward_map = {}

          # 2. Crear recompensas por llegada
          if arrival_rewards:
              for reward_data in arrival_rewards:
                  # Crear con unlock_condition = narrative_fragment
                  result = await self.reward_orchestrator.create_reward_with_unlock_condition(
                      reward_data=reward_data,
                      unlock_narrative_fragment=fragment.fragment_key,  # NUEVO parÃ¡metro
                      created_by=created_by
                  )
                  if result.get('reward'):
                      created_rewards.append(result['reward'])

          # 3. Crear recompensas por decisiÃ³n
          if decision_rewards:
              for decision_key, rewards in decision_rewards.items():
                  decision_reward_map[decision_key] = []
                  for reward_data in rewards:
                      result = await self.reward_orchestrator.create_reward_with_unlock_condition(
                          reward_data=reward_data,
                          unlock_narrative_decision=decision_key,
                          created_by=created_by
                      )
                      if result.get('reward'):
                          decision_reward_map[decision_key].append(result['reward'])

          return {
              'fragment': fragment,
              'created_rewards': created_rewards,
              'decision_reward_map': decision_reward_map
          }

      async def create_chapter_system(
          self,
          chapter_data: dict,
          fragments: List[dict],
          completion_config: Optional[dict] = None,
          created_by: int = 0
      ) -> dict:
          """
          Crea capÃ­tulo completo con sistema de gamificaciÃ³n.
          
          Args:
              chapter_data: {name, slug, chapter_type, description}
              fragments: Lista de fragmentos con decisiones
              completion_config: {
                  'rewards': Lista de recompensas por completar capÃ­tulo,
                  'unlock_level': Nivel a desbloquear,
                  'grant_besitos': Besitos a otorgar
              }
          """
          ...

  2.4 ExtensiÃ³n del RewardOrchestrator

  # bot/gamification/services/orchestrator/reward.py (EXTENDER)

  class RewardOrchestrator:

      async def create_reward_with_unlock_condition(
          self,
          reward_data: dict,
          unlock_mission_id: Optional[int] = None,
          unlock_level_id: Optional[int] = None,
          unlock_besitos: Optional[int] = None,
          # NUEVOS parÃ¡metros para narrativa:
          unlock_narrative_chapter: Optional[str] = None,  # slug del capÃ­tulo
          unlock_narrative_fragment: Optional[str] = None,  # key del fragmento
          unlock_narrative_decision: Optional[str] = None,  # key de decisiÃ³n
          unlock_archetype: Optional[str] = None,  # tipo de arquetipo
          created_by: int = 0
      ) -> dict:
          """
          Crea recompensa con unlock condition (extendido para narrativa).
          """
          conditions = []

          # Condiciones existentes
          if unlock_mission_id:
              conditions.append({"type": "mission", "mission_id": unlock_mission_id})
          if unlock_level_id:
              conditions.append({"type": "level", "level_id": unlock_level_id})
          if unlock_besitos:
              conditions.append({"type": "besitos", "min_besitos": unlock_besitos})

          # NUEVAS condiciones de narrativa
          if unlock_narrative_chapter:
              conditions.append({
                  "type": "narrative_chapter",
                  "chapter_slug": unlock_narrative_chapter
              })
          if unlock_narrative_fragment:
              conditions.append({
                  "type": "narrative_fragment",
                  "fragment_key": unlock_narrative_fragment
              })
          if unlock_narrative_decision:
              conditions.append({
                  "type": "narrative_decision",
                  "decision_key": unlock_narrative_decision
              })
          if unlock_archetype:
              conditions.append({
                  "type": "archetype",
                  "archetype": unlock_archetype
              })

          # ... resto igual

  ---
  3. FLUJOS DE CONFIGURACIÃ“N INTEGRADOS

  Flujo A: Desde Admin GamificaciÃ³n â†’ Narrativa

  Admin: /gamification â†’ Crear Recompensa
      â†’ Nombre: "Badge Diana Revelada"
      â†’ Tipo: BADGE
      â†’ "Â¿CondiciÃ³n de desbloqueo?"
      â†’ [MisiÃ³n] [Nivel] [Besitos] [ğŸ“– Narrativa]  â† NUEVO
      â†’ Click [ğŸ“– Narrativa]
      â†’ "Â¿QuÃ© progreso narrativo se requiere?"
          â†’ [Completar CapÃ­tulo]
          â†’ [Llegar a Fragmento]
          â†’ [Tomar DecisiÃ³n]
      â†’ Click [Completar CapÃ­tulo]
      â†’ Seleccionar: "El DivÃ¡n"
      â†’ âœ… Recompensa creada con unlock: narrative_chapter=el-divan

  Flujo B: Desde Admin Narrativa â†’ GamificaciÃ³n

  Admin: /narrative â†’ Crear Fragmento
      â†’ CapÃ­tulo: "Los Kinkys"
      â†’ Key: "scene_3a_impulsive"
      â†’ Speaker: Diana
      â†’ Contenido: "Bueno, eso fue... rÃ¡pido..."
      â†’ "Â¿Otorgar recompensa al llegar?"
      â†’ [SÃ­] â† Click
      â†’ "Tipo de recompensa:"
          â†’ [Crear Nueva] [Vincular Existente]
      â†’ Click [Crear Nueva]
      â†’ Nombre: "Alma Impulsiva"
      â†’ Tipo: BADGE
      â†’ âœ… Fragmento + Recompensa creados juntos

  Flujo C: Desde Admin Misiones â†’ Narrativa

  Admin: /gamification â†’ Crear MisiÃ³n
      â†’ Nombre: "Explorador de Diana"
      â†’ Tipo: ONE_TIME
      â†’ Criterio: "Completar 3 capÃ­tulos narrativos"  â† NUEVO criterio
      â†’ Recompensa: 500 besitos
      â†’ "Â¿Crear nivel asociado?"
      â†’ SÃ­: "Fan de Diana" (min 1000 besitos)
      â†’ âœ… MisiÃ³n + Nivel creados con criterio narrativo

  ---
  4. NUEVOS CRITERIOS DE MISIÃ“N

  # bot/gamification/database/enums.py (EXTENDER)

  class MissionCriteriaType(str, Enum):
      """Tipos de criterios para completar misiones."""
      ONE_TIME = "one_time"
      DAILY = "daily"
      WEEKLY = "weekly"
      STREAK = "streak"
      # NUEVOS para narrativa:
      NARRATIVE_CHAPTERS = "narrative_chapters"    # Completar N capÃ­tulos
      NARRATIVE_FRAGMENTS = "narrative_fragments"  # Visitar N fragmentos
      NARRATIVE_DECISIONS = "narrative_decisions"  # Tomar N decisiones
      ARCHETYPE_REACH = "archetype_reach"          # Alcanzar arquetipo especÃ­fico

  # Ejemplo de criterio:
  {
      "type": "narrative_chapters",
      "count": 2,
      "specific_chapters": ["los-kinkys", "el-divan"]  # Opcional
  }

  ---
  5. VALIDADORES ACTUALIZADOS

  # bot/gamification/utils/validators.py (EXTENDER)

  def validate_unlock_conditions(conditions: dict) -> Tuple[bool, Optional[str]]:
      """Valida unlock conditions incluyendo narrativa."""
      valid_types = [
          "mission", "level", "besitos", "multiple",
          # Nuevos:
          "narrative_chapter", "narrative_fragment",
          "narrative_decision", "archetype"
      ]

      cond_type = conditions.get("type")
      if cond_type not in valid_types:
          return False, f"Invalid condition type: {cond_type}"

      # Validaciones especÃ­ficas para narrativa
      if cond_type == "narrative_chapter":
          if "chapter_slug" not in conditions:
              return False, "narrative_chapter requires chapter_slug"

      if cond_type == "narrative_fragment":
          if "fragment_key" not in conditions:
              return False, "narrative_fragment requires fragment_key"

      if cond_type == "archetype":
          valid_archetypes = ["impulsive", "contemplative", "silent"]
          if conditions.get("archetype") not in valid_archetypes:
              return False, f"Invalid archetype. Valid: {valid_archetypes}"

      return True, None

  ---
  6. CHECKER DE UNLOCK CONDITIONS

  El RewardService necesita saber cÃ³mo verificar las nuevas condiciones:

  # bot/gamification/services/reward.py (EXTENDER check_unlock)

  async def check_unlock_conditions(
      self, 
      user_id: int, 
      conditions: dict
  ) -> Tuple[bool, Optional[str]]:
      """Verifica si usuario cumple condiciones para desbloquear."""

      cond_type = conditions.get("type")

      # Condiciones existentes...
      if cond_type == "mission":
          # ya existe
          pass
      elif cond_type == "level":
          # ya existe
          pass
      elif cond_type == "besitos":
          # ya existe
          pass

      # NUEVAS condiciones de narrativa
      elif cond_type == "narrative_chapter":
          from bot.narrative.services.container import NarrativeContainer
          narrative = NarrativeContainer(self._session)
          completed = await narrative.progress.has_completed_chapter(
              user_id,
              conditions["chapter_slug"]
          )
          if not completed:
              return False, f"Debes completar el capÃ­tulo para desbloquear"

      elif cond_type == "narrative_fragment":
          from bot.narrative.services.container import NarrativeContainer
          narrative = NarrativeContainer(self._session)
          visited = await narrative.progress.has_visited_fragment(
              user_id,
              conditions["fragment_key"]
          )
          if not visited:
              return False, "Debes avanzar en la historia para desbloquear"

      elif cond_type == "archetype":
          from bot.narrative.services.container import NarrativeContainer
          narrative = NarrativeContainer(self._session)
          progress = await narrative.progress.get_progress(user_id)
          if progress.detected_archetype.value != conditions["archetype"]:
              return False, f"Requiere arquetipo: {conditions['archetype']}"

      return True, None

  ---
  7. RESUMEN DE CAMBIOS

  Archivos a MODIFICAR (gamificaciÃ³n):

  | Archivo                                | Cambio                                             |
  |----------------------------------------|----------------------------------------------------|
  | database/enums.py                      | Agregar criterios de misiÃ³n narrativos             |
  | utils/validators.py                    | Agregar validaciÃ³n de unlock conditions narrativos |
  | services/reward.py                     | Extender check_unlock_conditions                   |
  | services/orchestrator/reward.py        | Agregar parÃ¡metros narrativos                      |
  | services/orchestrator/configuration.py | Agregar narrative property + mÃ©todos               |

  Archivos NUEVOS (narrativa):

  | Archivo                            | PropÃ³sito                                           |
  |------------------------------------|-----------------------------------------------------|
  | narrative/services/orchestrator.py | NarrativeOrchestrator integrado                     |
  | narrative/services/progress.py     | MÃ©todos has_completed_chapter, has_visited_fragment |

  ---
  8. DIAGRAMA DE INTEGRACIÃ“N FINAL

  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚                    ConfigurationOrchestrator                     â”‚
  â”‚  (Maestro de configuraciÃ³n - coordina todo)                     â”‚
  â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
  â”‚                                                                  â”‚
  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
  â”‚   â”‚ MissionOrch.     â”‚  â”‚ RewardOrch.      â”‚  â”‚ NarrativeOrchâ”‚ â”‚
  â”‚   â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚  â”‚ â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€-â”‚ â”‚
  â”‚   â”‚ â€¢ create_mission â”‚  â”‚ â€¢ create_reward  â”‚  â”‚ â€¢ create_fragâ”‚ â”‚
  â”‚   â”‚ â€¢ auto_level     â”‚  â”‚ â€¢ unlock_conds   â”‚  â”‚ â€¢ chapter_sysâ”‚ â”‚
  â”‚   â”‚ â€¢ auto_rewards   â”‚  â”‚   â”œâ”€ mission     â”‚  â”‚ â€¢ link_rewardâ”‚ â”‚
  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚   â”œâ”€ level       â”‚  â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
  â”‚            â”‚            â”‚   â”œâ”€ besitos     â”‚         â”‚         â”‚
  â”‚            â”‚            â”‚   â”œâ”€ narrative_* â”‚â—„â”€â”€â”€â”€â”€â”€â”€â”€â”˜         â”‚
  â”‚            â”‚            â”‚   â””â”€ archetype   â”‚                   â”‚
  â”‚            â”‚            â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                   â”‚
  â”‚            â”‚                     â”‚                              â”‚
  â”‚            â–¼                     â–¼                              â”‚
  â”‚   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
  â”‚   â”‚                     SQLAlchemy Session                    â”‚ â”‚
  â”‚   â”‚  (TransacciÃ³n atÃ³mica - todo o nada)                     â”‚ â”‚
  â”‚   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
  â”‚                                                                  â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

  ---
  9. FASES ACTUALIZADAS

  Con esta integraciÃ³n, las fases quedan:

  FASE N1: Modelos + MigraciÃ³n (sin cambios)

  FASE N2: Servicios Core (sin cambios)

  FASE N3: IntegraciÃ³n con Orquestadores â† ACTUALIZADA

  - Extender RequirementType con tipos narrativos
  - Extender validate_unlock_conditions
  - Crear NarrativeOrchestrator
  - Extender RewardOrchestrator con parÃ¡metros narrativos
  - Extender ConfigurationOrchestrator con property narrative
  - Extender check_unlock_conditions en RewardService
  - Tests integraciÃ³n

  FASE N4-N6: (sin cambios mayores)

  ---
  Â¿Esta integraciÃ³n con el sistema de orquestadores te parece correcta? El objetivo es que desde cualquier punto de la configuraciÃ³n puedas crear/vincular entidades de los otros mÃ³dulos sin tener que ir a configurarlas por separado.

> /export 
  â¿  Failed to copy to clipboard. Make sure `xclip` or `wl-copy` is installed on your system and try again.



